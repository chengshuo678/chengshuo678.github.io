<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>记乙亥中秋</title>
      <link href="/2019/09/14/%E8%AE%B0%E4%B9%99%E4%BA%A5%E4%B8%AD%E7%A7%8B/"/>
      <url>/2019/09/14/%E8%AE%B0%E4%B9%99%E4%BA%A5%E4%B8%AD%E7%A7%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>乙亥中秋，于合肥，丢失钥匙等物品。几分感慨，遂记之。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6z2lo1iquj31mm0u04qq.jpg" alt="image-20190914151920088"></p><a id="more"></a><p>中秋佳节，合肥的大街小巷里弥漫着过节和放假的轻松气息。一大早，<strong>室友就兴冲冲地回家了</strong>，一连三天的假期在家里过一定会轻松不少。</p><p>印象中，前两天图书馆的大门上贴了一个通告：<strong>中秋当天不开门</strong>，剩余两天假期开放时间同周末时间点。于是乎，为自己的不看书找了一个非常恰当的“理由”，今天<strong>自由</strong>了！！</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6yyxm0x93j30kk09cact.jpg" alt="image-20190914131227918"></p><p>海底捞？烧烤？电影？还是把买只鸡配着前两天的松茸一起炖了？经过一番思想斗争，决定出去吃。之心城？步行街？漫乐城？<strong>吃得飞起，忘乎所以</strong>。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6yz2vlrs7j30tm0hwhdt.jpg" alt="image-20190914131731528"></p><p>之心城，购物。洗发水，强韧发根？买！汴京茶寮，新桃妖·十样锦？买！胖？胖什么胖，不存在的。我收了收鼓起的肚子，发现吃得太撑，收不回去了。为了出来购物，我专门自己带了手提袋，<strong>把什么钥匙、充电包、吃的喝的用的一股脑儿扔在里面</strong>。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6z0g8f5b3j30zk0d443i.jpg" alt="image-20190914140455768"></p><p>夜幕降临，华灯初上。之心城商场外， 唱歌艺人唱着陈楚生的《有没有人告诉你》：当火车开入这座陌生的城市，那是从来就没有见过的霓虹… 熙熙攘攘，楼下唱歌的、听歌的、卖凉皮的、卖冰糖葫芦的、卖水果的，配合着共享单车，将商城裹了里三层、外三层。耳边悠扬的歌声、商贩的叫卖声、路边逛街人的争论声，连同一楼商铺里强劲的音乐声，彰显合肥市中心的热闹与繁华。</p><p>我提着手提袋杀出重围，用滴滴开始打车，没想到打车的人数贼多，都排到50+号。打车无果，只好扫了个共享电驴。扫了一个，没电；两个，没电；没电，没电，，，，在步行一个街区后，我在一个堆积如山的共享单车下面，终于找到了一个躺着的共享电驴，有电。将手提袋挂在车把上，屁颠屁嗲往回骑，一边骑车一边寻思，回去干嘛好呢，貌似之前的《蜘蛛侠》还没看完…</p><p>到了楼下，把共享电驴停到指定位置，在手机上点击“还车”，显示：还车失败。退出重新打开软件，还车，还车还车，连续点击后，终于还车成功，心里暗自吐槽了一下这坑爹的软件。去了路边的超市，买了瓶酸奶和酸梅汤，结账准备回住处，突然心里一颤，<strong>我的手提袋呢？？</strong></p><p><strong>手提袋呢？</strong></p><p>我记得是挂在共享电驴上了。</p><p>出门一看，刚刚骑的电驴手把上，什么都没有，什么都没有…<strong>我一手拿着酸奶，一手拿着酸梅汤，站在那里愣住了…</strong> 奇怪，明明才三分钟，还车，去超市，买酸奶，出来，没了？我左右看了看，这条街道昏暗的路灯下，稀稀散散的几个人。手提袋呢？？应该被别人拿走了，<strong>我的钥匙还在里面！</strong>室友不在家，而且还不在合肥，<strong>我没钥匙了！！</strong>天呐，我住哪？对了，前两天我身份证还不翼而飞。<strong>苍天呐，岂不是酒店我都无法入住，我要流落街头了吗？！</strong></p><p>奈何？</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6z0jul9iej30ke0i8q8u.jpg" alt="image-20190914140825618"></p><p>观察到，共享电驴的斜上方，有个摄像头，旁边牌子写着公共监控，合肥公安。警察？我还从来没有报过警，试试？</p><p>试试就试试。</p><p>1-1-0，喂？…. 经过一阵balabala的叙述，警察让我去对应区的派出所。我一查，几百米吧，走起。行至途中，收到派出所电话，居然是派出所警察同志派车从区域的另一边去接我，没找到我，还有警车接待服务？哎呀，居然三位警察，这阵势，看来我很重要吗？重倒是真重。</p><p>派出所在一个街道的巷子里。进了大厅，里面坐了五位警察，年纪都不小了，得有四十多岁了。一位接我的警察，比较热情，仔细询问了一下经过并进行登记。另一名年纪较大的警察出来帮我调监控，我看了下红袖章，上面写着：警长。</p><p>什么？监控打不开？连不上网？警长伯伯十五分钟查看无果后，又从里屋叫来一位年轻的警察同志，帮忙调试网络。年轻的警察同志睡眼惺忪，看起来被叫起来还没大清醒。我又等了大概十来分钟，告诉我，连不上网，得周一技术人员来弄。那一刻，作为计算机科班出身的我，真想大喊一句：让我来！</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6z1vjed66j31380eytg0.jpg" alt="image-20190914145415991"></p><p>下面警长建议我，一是在周边找一下，看别人拿走后，有没有把钥匙扔出来；二是，联系开锁人员，帮忙开锁。我立刻网上搜索，找到一家开锁公司，联系后说明情况，同时，警长伯伯也用派出所电话打过去为我证明，并要求科大学生价格上尽量优惠点。我向警长表达感谢后，离开派出所。</p><p>在开锁人员的帮助下，顺利打开了门，并换了新锁。看了下时间，已经快夜里一点了。</p><p>现在做个简单的<strong>总结</strong>：</p><p>​         <strong>自身</strong></p><ol><li><p>离开时，记得<strong>确认下有无东西忘拿</strong>，特别是在这个过程中，<strong>有别的事情打断</strong>，比如还车失败，一定要<strong>接上</strong>之前做的事情。</p></li><li><p>钥匙属于个人<strong>重要物品</strong>，不能与购物商品放在一处，应该<strong>随身携带</strong>。</p></li><li><p><strong>心平气和</strong>地处理以后的事事非非。这次做的还不错。</p><p>其他</p></li><li><p>合肥警察办事还是很<strong>靠谱</strong>的。如果能把实时监控做好就更好了，一是 重要地方有布点监控，这点已经做的不错了。二是，监控出现问题（线路、网络等）没有示警，只有出现问题查看监控的时候才会发现，监控能否使用。应该弥补对监控系统的监控。</p></li><li><p>在别的城市没有遇到这种情况，进店买东西，三分钟，共享电驴还在，东西被别人刻意“拿”走了。</p></li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6z2mdmrytj31a20jitdv.jpg" alt="image-20190914152003559"></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记事 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/09/12/%E4%B8%AA%E6%80%A7%E5%8C%96%E7%94%B5%E5%95%86%E5%B9%BF%E5%91%8A%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
      <url>/2019/09/12/%E4%B8%AA%E6%80%A7%E5%8C%96%E7%94%B5%E5%95%86%E5%B9%BF%E5%91%8A%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python实现多线程 web静态服务器</title>
      <link href="/2019/09/11/%E9%9D%99%E6%80%81Web%E6%9C%8D%E5%8A%A1%E5%99%A8Python%E7%89%88/"/>
      <url>/2019/09/11/%E9%9D%99%E6%80%81Web%E6%9C%8D%E5%8A%A1%E5%99%A8Python%E7%89%88/</url>
      
        <content type="html"><![CDATA[<blockquote><p>今天做了一个题目，用Python实现多线程 web静态服务器，返回固定的页面。</p></blockquote><a id="more"></a><p>题目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">实现一个 多线程 web静态服务器，返回固定的页面。     </span><br><span class="line">1. 使用面向对象实现     </span><br><span class="line">2. 端口 命令行获取</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># readme：python3 xxx.python 运行，记得放置static对应的index.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断输入命令行是否合法</span></span><br><span class="line"><span class="comment"># 合法格式：python3 xxx.python 端口号</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(param)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(param) != <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> param[<span class="number">1</span>].isdigit():</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从系统参数中获取端口号参数</span></span><br><span class="line"><span class="comment"># 如果参数非法，默认采用8089。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_port_param</span><span class="params">(param)</span>:</span></span><br><span class="line">    port = <span class="number">8089</span></span><br><span class="line">    <span class="keyword">if</span> check(param):</span><br><span class="line">        port = param[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"命令行不符合：【python3 xxx.python 端口号】，采用默认端口号: 8089"</span>)</span><br><span class="line">    <span class="keyword">return</span> int(port)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拼接返回数据response</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_response</span><span class="params">(status_code, file_data)</span>:</span></span><br><span class="line">    response_line = <span class="string">"HTTP/1.1 "</span> + status_code + <span class="string">"\r\n"</span></span><br><span class="line">    response_header = <span class="string">"Server: PWS/1.0\r\n"</span></span><br><span class="line">    response_body = file_data</span><br><span class="line">    <span class="comment"># 拼装response</span></span><br><span class="line">    response = (response_line + response_header + <span class="string">"\r\n"</span>).encode(<span class="string">"utf-8"</span>) + response_body</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpWebServer</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, port)</span>:</span></span><br><span class="line">        <span class="comment"># 创建TCP套接字</span></span><br><span class="line">        tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        <span class="comment"># 设置端口号复用</span></span><br><span class="line">        tcp_server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># 绑定端口号</span></span><br><span class="line">        tcp_server_socket.bind((<span class="string">""</span>, port))</span><br><span class="line">        <span class="comment"># 设置监听</span></span><br><span class="line">        tcp_server_socket.listen(<span class="number">128</span>)</span><br><span class="line">        <span class="comment"># tcp服务器的套接字作为web服务器对象的属性赋值</span></span><br><span class="line">        self.tcp_server_socket = tcp_server_socket</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 处理客户端请求</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_client_request</span><span class="params">(new_socket)</span>:</span></span><br><span class="line">        <span class="comment"># 接收客户端请求信息</span></span><br><span class="line">        recv_data = new_socket.recv(<span class="number">4096</span>)</span><br><span class="line">        <span class="comment"># 判断接收是否结束</span></span><br><span class="line">        <span class="keyword">if</span> len(recv_data) == <span class="number">0</span>:</span><br><span class="line">            new_socket.close()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对二进制数据进行解码</span></span><br><span class="line">        recv_content = recv_data.decode(<span class="string">"utf-8"</span>)</span><br><span class="line">        print(recv_content)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对数据按照空格进行分割</span></span><br><span class="line">        request_list = recv_content.split(<span class="string">" "</span>, maxsplit=<span class="number">2</span>)</span><br><span class="line">        <span class="comment"># 获取请求的资源路径</span></span><br><span class="line">        request_path = request_list[<span class="number">1</span>]</span><br><span class="line">        print(request_path)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 判断请求是否是根目录·，如果是，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> request_path == <span class="string">"/"</span>:</span><br><span class="line">            request_path = <span class="string">"/index.html"</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">with</span> open(<span class="string">"static"</span> + request_path, <span class="string">"rb"</span>) <span class="keyword">as</span> file:</span><br><span class="line">                file_data = file.read()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 发送给浏览器的响应报文</span></span><br><span class="line">            response = build_response(<span class="string">"200 OK"</span>, file_data)</span><br><span class="line">            new_socket.send(response)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="comment"># 404页面</span></span><br><span class="line">            <span class="keyword">with</span> open(<span class="string">"static/error.html"</span>, <span class="string">"rb"</span>) <span class="keyword">as</span> file:</span><br><span class="line">                file_data = file.read()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 拼接返回数据response</span></span><br><span class="line">            response = build_response(<span class="string">"404 Not Found"</span>, file_data)</span><br><span class="line">            <span class="comment"># 发送给浏览器的响应报文</span></span><br><span class="line">            new_socket.send(response)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            new_socket.close()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 启动服务器</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 循环等待</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># 等待请求</span></span><br><span class="line">            new_socket, ip_port = self.tcp_server_socket.accept()</span><br><span class="line">            <span class="comment"># 建立连接</span></span><br><span class="line">            sub_thread = threading.Thread(target=self.handle_client_request, args=(new_socket,))</span><br><span class="line">            <span class="comment"># 设置为守护主线程</span></span><br><span class="line">            sub_thread.setDaemon(<span class="literal">True</span>)</span><br><span class="line">            <span class="comment"># 启动子线程执行对应的任务</span></span><br><span class="line">            sub_thread.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 1. 命令行参数获取</span></span><br><span class="line">    port = get_port_param(sys.argv);</span><br><span class="line">    <span class="comment"># 2. 服务器启动</span></span><br><span class="line">    sever = HttpWebServer(port);</span><br><span class="line">    sever.start()</span><br><span class="line">    print(<span class="string">"启动完毕！"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark之数据清洗</title>
      <link href="/2019/09/09/Spark%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97/"/>
      <url>/2019/09/09/Spark%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p>数据来源多样性，记录业务数据的不确定性，将会带来数据重复、缺失甚至错误的问题。为了更好地训练模型，数据清洗是必要的环节。</p></blockquote><a id="more"></a><h3 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h3><p>在大数据整个生产过程中，需要先对数据进行数据清洗，将杂乱无章的数据整理为符合后面处理要求的规整数据。</p><p><strong>数据去重</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">1.删除重复数据</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">groupby().count()：可以看到数据的重复情况</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">df = spark.createDataFrame([</span><br><span class="line">  (<span class="number">1</span>, <span class="number">144.5</span>, <span class="number">5.9</span>, <span class="number">33</span>, <span class="string">'M'</span>),</span><br><span class="line">  (<span class="number">2</span>, <span class="number">167.2</span>, <span class="number">5.4</span>, <span class="number">45</span>, <span class="string">'M'</span>),</span><br><span class="line">  (<span class="number">3</span>, <span class="number">124.1</span>, <span class="number">5.2</span>, <span class="number">23</span>, <span class="string">'F'</span>),</span><br><span class="line">  (<span class="number">4</span>, <span class="number">144.5</span>, <span class="number">5.9</span>, <span class="number">33</span>, <span class="string">'M'</span>),</span><br><span class="line">  (<span class="number">5</span>, <span class="number">133.2</span>, <span class="number">5.7</span>, <span class="number">54</span>, <span class="string">'F'</span>),</span><br><span class="line">  (<span class="number">3</span>, <span class="number">124.1</span>, <span class="number">5.2</span>, <span class="number">23</span>, <span class="string">'F'</span>),</span><br><span class="line">  (<span class="number">5</span>, <span class="number">129.2</span>, <span class="number">5.3</span>, <span class="number">42</span>, <span class="string">'M'</span>),</span><br><span class="line">], [<span class="string">'id'</span>, <span class="string">'weight'</span>, <span class="string">'height'</span>, <span class="string">'age'</span>, <span class="string">'gender'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看重复记录</span></span><br><span class="line"><span class="comment">#无意义重复数据去重：数据中行与行完全重复</span></span><br><span class="line"><span class="comment"># 1.首先删除完全一样的记录</span></span><br><span class="line">df2 = df.dropDuplicates()</span><br><span class="line"></span><br><span class="line"><span class="comment">#有意义去重：删除除去无意义字段之外的完全重复的行数据</span></span><br><span class="line"><span class="comment"># 2.其次，关键字段值完全一模一样的记录（在这个例子中，是指除了id之外的列一模一样）</span></span><br><span class="line"><span class="comment"># 删除某些字段值完全一样的重复记录，subset参数定义这些字段</span></span><br><span class="line">df3 = df2.dropDuplicates(subset = [c <span class="keyword">for</span> c <span class="keyword">in</span> df2.columns <span class="keyword">if</span> c!=<span class="string">'id'</span>])</span><br><span class="line"><span class="comment"># 3.有意义的重复记录去重之后，再看某个无意义字段的值是否有重复（在这个例子中，是看id是否重复）</span></span><br><span class="line"><span class="comment"># 查看某一列是否有重复值</span></span><br><span class="line"><span class="keyword">import</span> pyspark.sql.functions <span class="keyword">as</span> fn</span><br><span class="line">df3.agg(fn.count(<span class="string">'id'</span>).alias(<span class="string">'id_count'</span>),fn.countDistinct(<span class="string">'id'</span>).alias(<span class="string">'distinct_id_count'</span>)).collect()</span><br><span class="line"><span class="comment"># 4.对于id这种无意义的列重复，添加另外一列自增id</span></span><br><span class="line"></span><br><span class="line">df3.withColumn(<span class="string">'new_id'</span>,fn.monotonically_increasing_id()).show()</span><br></pre></td></tr></table></figure><p><strong>缺失值处理</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">2.处理缺失值</span></span><br><span class="line"><span class="string">2.1 对缺失值进行删除操作(行，列)</span></span><br><span class="line"><span class="string">2.2 对缺失值进行填充操作(列的均值)</span></span><br><span class="line"><span class="string">2.3 对缺失值对应的行或列进行标记</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">df_miss = spark.createDataFrame([</span><br><span class="line">(<span class="number">1</span>, <span class="number">143.5</span>, <span class="number">5.6</span>, <span class="number">28</span>,<span class="string">'M'</span>, <span class="number">100000</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="number">167.2</span>, <span class="number">5.4</span>, <span class="number">45</span>,<span class="string">'M'</span>, <span class="literal">None</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="literal">None</span> , <span class="number">5.2</span>, <span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="number">144.5</span>, <span class="number">5.9</span>, <span class="number">33</span>, <span class="string">'M'</span>, <span class="literal">None</span>),</span><br><span class="line">(<span class="number">5</span>, <span class="number">133.2</span>, <span class="number">5.7</span>, <span class="number">54</span>, <span class="string">'F'</span>, <span class="literal">None</span>),</span><br><span class="line">(<span class="number">6</span>, <span class="number">124.1</span>, <span class="number">5.2</span>, <span class="literal">None</span>, <span class="string">'F'</span>, <span class="literal">None</span>),</span><br><span class="line">(<span class="number">7</span>, <span class="number">129.2</span>, <span class="number">5.3</span>, <span class="number">42</span>, <span class="string">'M'</span>, <span class="number">76000</span>),],</span><br><span class="line"> [<span class="string">'id'</span>, <span class="string">'weight'</span>, <span class="string">'height'</span>, <span class="string">'age'</span>, <span class="string">'gender'</span>, <span class="string">'income'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.计算每条记录的缺失值情况</span></span><br><span class="line"></span><br><span class="line">df_miss.rdd.map(<span class="keyword">lambda</span> row:(row[<span class="string">'id'</span>],sum([c==<span class="literal">None</span> <span class="keyword">for</span> c <span class="keyword">in</span> row]))).collect()</span><br><span class="line">[(<span class="number">1</span>, <span class="number">0</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">4</span>, <span class="number">1</span>), (<span class="number">5</span>, <span class="number">1</span>), (<span class="number">6</span>, <span class="number">2</span>), (<span class="number">7</span>, <span class="number">0</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.计算各列的缺失情况百分比</span></span><br><span class="line">df_miss.agg(*[(<span class="number">1</span> - (fn.count(c) / fn.count(<span class="string">'*'</span>))).alias(c + <span class="string">'_missing'</span>) <span class="keyword">for</span> c <span class="keyword">in</span> df_miss.columns]).show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3、删除缺失值过于严重的列</span></span><br><span class="line"><span class="comment"># 其实是先建一个DF，不要缺失值的列</span></span><br><span class="line">df_miss_no_income = df_miss.select([</span><br><span class="line">c <span class="keyword">for</span> c <span class="keyword">in</span> df_miss.columns <span class="keyword">if</span> c != <span class="string">'income'</span></span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4、按照缺失值删除行（threshold是根据一行记录中，缺失字段的百分比的定义）</span></span><br><span class="line">df_miss_no_income.dropna(thresh=<span class="number">3</span>).show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5、填充缺失值，可以用fillna来填充缺失值，</span></span><br><span class="line"><span class="comment"># 对于bool类型、或者分类类型，可以为缺失值单独设置一个类型，missing</span></span><br><span class="line"><span class="comment"># 对于数值类型，可以用均值或者中位数等填充</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># fillna可以接收两种类型的参数：</span></span><br><span class="line"><span class="comment"># 一个数字、字符串，这时整个DataSet中所有的缺失值都会被填充为相同的值。</span></span><br><span class="line"><span class="comment"># 也可以接收一个字典｛列名：值｝这样</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 先计算均值，并组织成一个字典</span></span><br><span class="line">means = df_miss_no_income.agg( *[fn.mean(c).alias(c) <span class="keyword">for</span> c <span class="keyword">in</span> df_miss_no_income.columns <span class="keyword">if</span> c != <span class="string">'gender'</span>]).toPandas().to_dict(<span class="string">'records'</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 然后添加其它的列</span></span><br><span class="line">means[<span class="string">'gender'</span>] = <span class="string">'missing'</span></span><br><span class="line"></span><br><span class="line">df_miss_no_income.fillna(means).show()</span><br></pre></td></tr></table></figure><p><strong>异常值处理</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">3、异常值处理</span></span><br><span class="line"><span class="string">异常值：不属于正常的值 包含：缺失值，超过正常范围内的较大值或较小值</span></span><br><span class="line"><span class="string">分位数去极值</span></span><br><span class="line"><span class="string">中位数绝对偏差去极值</span></span><br><span class="line"><span class="string">正态分布去极值</span></span><br><span class="line"><span class="string">上述三种操作的核心都是：通过原始数据设定一个正常的范围，超过此范围的就是一个异常值</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">df_outliers = spark.createDataFrame([</span><br><span class="line">(<span class="number">1</span>, <span class="number">143.5</span>, <span class="number">5.3</span>, <span class="number">28</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="number">154.2</span>, <span class="number">5.5</span>, <span class="number">45</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="number">342.3</span>, <span class="number">5.1</span>, <span class="number">99</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="number">144.5</span>, <span class="number">5.5</span>, <span class="number">33</span>),</span><br><span class="line">(<span class="number">5</span>, <span class="number">133.2</span>, <span class="number">5.4</span>, <span class="number">54</span>),</span><br><span class="line">(<span class="number">6</span>, <span class="number">124.1</span>, <span class="number">5.1</span>, <span class="number">21</span>),</span><br><span class="line">(<span class="number">7</span>, <span class="number">129.2</span>, <span class="number">5.3</span>, <span class="number">42</span>),</span><br><span class="line">], [<span class="string">'id'</span>, <span class="string">'weight'</span>, <span class="string">'height'</span>, <span class="string">'age'</span>])</span><br><span class="line"><span class="comment"># 设定范围 超出这个范围的 用边界值替换</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># approxQuantile方法接收三个参数：参数1，列名；参数2：想要计算的分位点，可以是一个点，也可以是一个列表（0和1之间的小数），第三个参数是能容忍的误差，如果是0，代表百分百精确计算。</span></span><br><span class="line"></span><br><span class="line">cols = [<span class="string">'weight'</span>, <span class="string">'height'</span>, <span class="string">'age'</span>]</span><br><span class="line"></span><br><span class="line">bounds = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> cols:</span><br><span class="line">    quantiles = df_outliers.approxQuantile(col, [<span class="number">0.25</span>, <span class="number">0.75</span>], <span class="number">0.05</span>)</span><br><span class="line">    IQR = quantiles[<span class="number">1</span>] - quantiles[<span class="number">0</span>]</span><br><span class="line">    bounds[col] = [</span><br><span class="line">        quantiles[<span class="number">0</span>] - <span class="number">1.5</span> * IQR,</span><br><span class="line">        quantiles[<span class="number">1</span>] + <span class="number">1.5</span> * IQR</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bounds</span><br><span class="line">&#123;<span class="string">'age'</span>: [<span class="number">-11.0</span>, <span class="number">93.0</span>], <span class="string">'height'</span>: [<span class="number">4.499999999999999</span>, <span class="number">6.1000000000000005</span>], <span class="string">'weight'</span>: [<span class="number">91.69999999999999</span>, <span class="number">191.7</span>]&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为异常值字段打标志</span></span><br><span class="line">outliers = df_outliers.select(*[<span class="string">'id'</span>] + [( (df_outliers[c] &lt; bounds[c][<span class="number">0</span>]) | (df_outliers[c] &gt; bounds[c][<span class="number">1</span>]) ).alias(c + <span class="string">'_o'</span>) <span class="keyword">for</span> c <span class="keyword">in</span> cols ])</span><br><span class="line">outliers.show()</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># +---+--------+--------+-----+</span></span><br><span class="line"><span class="comment"># | id|weight_o|height_o|age_o|</span></span><br><span class="line"><span class="comment"># +---+--------+--------+-----+</span></span><br><span class="line"><span class="comment"># |  1|   false|   false|false|</span></span><br><span class="line"><span class="comment"># |  2|   false|   false|false|</span></span><br><span class="line"><span class="comment"># |  3|    true|   false| true|</span></span><br><span class="line"><span class="comment"># |  4|   false|   false|false|</span></span><br><span class="line"><span class="comment"># |  5|   false|   false|false|</span></span><br><span class="line"><span class="comment"># |  6|   false|   false|false|</span></span><br><span class="line"><span class="comment"># |  7|   false|   false|false|</span></span><br><span class="line"><span class="comment"># +---+--------+--------+-----+</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再回头看看这些异常值的值，重新和原始数据关联</span></span><br><span class="line"></span><br><span class="line">df_outliers = df_outliers.join(outliers, on=<span class="string">'id'</span>)</span><br><span class="line">df_outliers.filter(<span class="string">'weight_o'</span>).select(<span class="string">'id'</span>, <span class="string">'weight'</span>).show()</span><br><span class="line"><span class="comment"># +---+------+</span></span><br><span class="line"><span class="comment"># | id|weight|</span></span><br><span class="line"><span class="comment"># +---+------+</span></span><br><span class="line"><span class="comment"># |  3| 342.3|</span></span><br><span class="line"><span class="comment"># +---+------+</span></span><br><span class="line"></span><br><span class="line">df_outliers.filter(<span class="string">'age_o'</span>).select(<span class="string">'id'</span>, <span class="string">'age'</span>).show()</span><br><span class="line"><span class="comment"># +---+---+</span></span><br><span class="line"><span class="comment"># | id|age|</span></span><br><span class="line"><span class="comment"># +---+---+</span></span><br><span class="line"><span class="comment"># |  3| 99|</span></span><br><span class="line"><span class="comment"># +---+---+</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
            <tag> 数据清洗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark之RDD的理解</title>
      <link href="/2019/09/09/Spark%E4%B9%8BRDD%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2019/09/09/Spark%E4%B9%8BRDD%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Spark操作数据，数据是以什么样的形式存在的？Spark是如何操作数据的呢？</p></blockquote><a id="more"></a><h3 id="RDD引入"><a href="#RDD引入" class="headerlink" title="RDD引入"></a>RDD引入</h3><p>RDD（Resilient Distributed Dataset）叫做<strong>弹性分布式数据集</strong>，是Spark中最基本的数据抽象，它代表一个<strong>不可变、可分区、里面的元素可并行计算</strong>的集合。</p><ul><li>Dataset:一个数据集，简单的理解为集合，用于存放数据的</li><li>Distributed：它的数据是分布式存储，并且可以做分布式的计算</li><li>Resilient：弹性的<ul><li>它表示的是数据可以保存在磁盘，也可以保存在内存中</li><li>数据分布式也是弹性的</li><li>弹性:并不是指他可以动态扩展，而是<strong>容错机制</strong>。<ul><li>RDD会在多个节点上存储，就和hdfs的分布式道理是一样的。hdfs文件被切分为多个block存储在各个节点上，而RDD是被切分为多个partition。不同的partition可能在不同的节点上</li><li>spark读取hdfs的场景下，spark把hdfs的block读到内存就会抽象为spark的partition。</li><li>spark计算结束，一般会把数据做持久化到hive，hbase，hdfs等等。我们就拿hdfs举例，将RDD持久化到hdfs上，RDD的每个partition就会存成一个文件，如果文件小于128M，就可以理解为一个partition对应hdfs的一个block。反之，如果大于128M，就会被且分为多个block，这样，一个partition就会对应多个block。</li></ul></li></ul></li><li>不可变<ul><li>为了做并行计算，且保证对临界资源访问的数据安全，将数据集做成不可变是比较好的实现方式。</li><li>同时，不可变可以保证数据计算出问题时，从上一个节点开始重新计算，不必从出发点重新计算。如 rdd0 -&gt; rdd1 -&gt; rdd2,  当 rdd1-&gt;rdd2，计算异常时，只需要重新计算rdd1-&gt;rdd2该环节即可。</li></ul></li><li>可分区<ul><li>将RDD数据切分成多个partition容错存储。</li></ul></li><li>并行计算</li></ul><h3 id="RDD的创建"><a href="#RDD的创建" class="headerlink" title="RDD的创建"></a>RDD的创建</h3><p>第一步 创建sparkContext</p><p>SparkContext是Spark程序的入口，代表了和Spark集群的链接。在Spark集群中通过SparkContext来创建RDD。</p><p>在创建sparkContext需要一个SparkConf， 用来保存Spark应用的连接信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conf = SparkConf().setAppName(appName).setMaster(master)</span><br><span class="line">sc = SparkContext(conf=conf)</span><br></pre></td></tr></table></figure><h4 id="parrellelize方式"><a href="#parrellelize方式" class="headerlink" title="parrellelize方式"></a>parrellelize方式</h4><ul><li><p>进入pyspark环境,可以在spark UI中看到当前的Spark作业 在浏览器访问当前centos的4040端口</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6tdupb75wj314q0r2n9t.jpg" alt="image-20190909153011038"></p><p>可以在spark UI中看到当前的Spark作业 在浏览器访问当前的4040端口。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6tduqm4qaj321e0tqn5g.jpg" alt="image-20190909153034238"></p><p>实例如下：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6tduugyaoj314i0ls468.jpg" alt="image-20190909153640092"></p><p>同时，也可以访问spark UI，查看运行情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">distData = sc.parallelize(data,<span class="number">5</span>)</span><br><span class="line">distData.reduce(<span class="keyword">lambda</span> a, b: a + b)</span><br></pre></td></tr></table></figure><p>说明：</p><blockquote><p> Spark将为群集的每个分区（partition）运行一个任务（task）。 </p><p>通常，可以根据CPU核心数量指定分区数量（每个CPU有2-4个分区）</p><p>如未指定分区数量，Spark会自动设置分区数。</p></blockquote></li></ul><h4 id="通过外部数据创建RDD"><a href="#通过外部数据创建RDD" class="headerlink" title="通过外部数据创建RDD"></a>通过外部数据创建RDD</h4><p>​        PySpark可以从Hadoop支持的任何存储源创建RDD，包括本地文件系统，HDFS，Cassandra，HBase，Amazon S3等。</p><p>eg</p><p>将words.txt放入HDFS中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop fs -put words.txt /tmp/</span><br></pre></td></tr></table></figure><p>访问并查看数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rdd1 = sc.textFile(&apos;/tmp/words.txt&apos;)</span><br><span class="line">rdd1.collect()</span><br></pre></td></tr></table></figure><h3 id="RDD的常用操作"><a href="#RDD的常用操作" class="headerlink" title="RDD的常用操作"></a>RDD的常用操作</h3><ul><li>RDD 支持两种类型的操作transformation和action：<ul><li>transformation（创建）<ul><li>从一个已经存在的数据集创建一个新的数据集，eg：map<ul><li>rddA ——-&gt;transformation ——&gt; rddB</li></ul></li></ul></li><li>action（获取结果）<ul><li>获取对数据进行运算操作之后的结果，eg：reduce</li></ul></li></ul></li><li>所有的transformation操作都是惰性的（lazy）<ul><li>不会立即计算结果，只有调用action一类的操作之后才会计算所有transformation。</li><li>这种设计使Spark运行效率更高</li><li>例如map reduce 操作，map创建的数据集将用于reduce，map阶段的结果不会返回，仅会返回reduce结果。</li></ul></li></ul><h4 id="RDD-Transformation算子"><a href="#RDD-Transformation算子" class="headerlink" title="RDD Transformation算子"></a>RDD Transformation算子</h4><ul><li><p>map: map(func)</p><ul><li><p>将func函数作用到数据集的每一个元素上，生成一个新的RDD返回</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>rdd1 = sc.parallelize([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>],<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rdd2 = rdd1.map(<span class="keyword">lambda</span> x: x+<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rdd2.collect()</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>rdd1 = sc.parallelize([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>],<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x+<span class="number">1</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rdd2 = rdd1.map(add)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rdd2.collect()</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure></li></ul></li><li><p>filter</p><ul><li><p>filter(func) 选出所有func返回值为true的元素，生成一个新的RDD返回</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>rdd1 = sc.parallelize([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>],<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rdd2 = rdd1.map(<span class="keyword">lambda</span> x:x*<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rdd3 = rdd2.filter(<span class="keyword">lambda</span> x:x&gt;<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rdd3.collect()</span><br><span class="line">[<span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>]</span><br></pre></td></tr></table></figure></li></ul></li><li><p>flatmap</p><ul><li><p>flatMap会先执行map的操作，再将所有对象合并为一个对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>rdd1 = sc.parallelize([<span class="string">"a b c"</span>,<span class="string">"d e f"</span>,<span class="string">"h i j"</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rdd2 = rdd1.flatMap(<span class="keyword">lambda</span> x:x.split(<span class="string">" "</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rdd2.collect()</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>, <span class="string">'j'</span>]</span><br></pre></td></tr></table></figure><p>flatMap和map的区别：<strong>flatMap在map的基础上将结果合并到一个list中</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; rdd1 = sc.parallelize([&quot;a b c&quot;,&quot;d e f&quot;,&quot;h i j&quot;])</span><br><span class="line">&gt;&gt;&gt; rdd2 = rdd1.map(lambda x:x.split(&quot; &quot;))</span><br><span class="line">&gt;&gt;&gt; rdd2.collect()</span><br><span class="line">[[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], [&apos;d&apos;, &apos;e&apos;, &apos;f&apos;], [&apos;h&apos;, &apos;i&apos;, &apos;j&apos;]]</span><br></pre></td></tr></table></figure></li></ul></li><li><p>intersection</p><ul><li>对两个RDD求交集</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>rdd1 = sc.parallelize([(<span class="string">"a"</span>,<span class="number">1</span>),(<span class="string">"b"</span>,<span class="number">2</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rdd2 = sc.parallelize([(<span class="string">"c"</span>,<span class="number">1</span>),(<span class="string">"b"</span>,<span class="number">3</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rdd3 = rdd1.union(rdd2)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rdd4 = rdd3.intersection(rdd2)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rdd4.collect()</span><br><span class="line">[(<span class="string">'c'</span>, <span class="number">1</span>), (<span class="string">'b'</span>, <span class="number">3</span>)]</span><br></pre></td></tr></table></figure></li><li><p>groupByKey</p><ul><li><p>以元组中的第0个元素作为key，进行分组，返回一个新的RDD</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>rdd1 = sc.parallelize([(<span class="string">"a"</span>,<span class="number">1</span>),(<span class="string">"b"</span>,<span class="number">2</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rdd2 = sc.parallelize([(<span class="string">"c"</span>,<span class="number">1</span>),(<span class="string">"b"</span>,<span class="number">3</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rdd3 = rdd1.union(rdd2)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rdd4 = rdd3.groupByKey()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rdd4.collect()</span><br><span class="line">[(<span class="string">'a'</span>, &lt;pyspark.resultiterable.ResultIterable object at <span class="number">0x7fba6a5e5898</span>&gt;), (<span class="string">'c'</span>, &lt;pyspark.resultiterable.ResultIterable object at <span class="number">0x7fba6a5e5518</span>&gt;), (<span class="string">'b'</span>, &lt;pyspark.resultiterable.ResultIterable object at <span class="number">0x7fba6a5e5f28</span>&gt;)]</span><br></pre></td></tr></table></figure></li><li><p>groupByKey之后的结果中 value是一个Iterable</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>result[<span class="number">2</span>]</span><br><span class="line">(<span class="string">'b'</span>, &lt;pyspark.resultiterable.ResultIterable object at <span class="number">0x7fba6c18e518</span>&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>result[<span class="number">2</span>][<span class="number">1</span>]</span><br><span class="line">&lt;pyspark.resultiterable.ResultIterable object at <span class="number">0x7fba6c18e518</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(result[<span class="number">2</span>][<span class="number">1</span>])</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure></li></ul></li><li><p>reduceByKey</p><ul><li>将key相同的键值对，按照Function进行计算</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>rdd = sc.parallelize([(<span class="string">"a"</span>, <span class="number">1</span>), (<span class="string">"b"</span>, <span class="number">1</span>), (<span class="string">"a"</span>, <span class="number">1</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rdd.reduceByKey(<span class="keyword">lambda</span> x,y:x+y).collect()</span><br><span class="line">[(<span class="string">'b'</span>, <span class="number">1</span>), (<span class="string">'a'</span>, <span class="number">2</span>)]</span><br></pre></td></tr></table></figure></li><li><p>sortByKey</p><ul><li><p><code>sortByKey</code>(<em>ascending=True</em>, <em>numPartitions=None</em>, <em>keyfunc=<function rdd.<lambda>&gt;</function></em>)</p><p>Sorts this RDD, which is assumed to consist of (key, value) pairs.</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tmp = [(<span class="string">'a'</span>, <span class="number">1</span>), (<span class="string">'b'</span>, <span class="number">2</span>), (<span class="string">'1'</span>, <span class="number">3</span>), (<span class="string">'d'</span>, <span class="number">4</span>), (<span class="string">'2'</span>, <span class="number">5</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sc.parallelize(tmp).sortByKey().first()</span><br><span class="line">(<span class="string">'1'</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sc.parallelize(tmp).sortByKey(<span class="literal">True</span>, <span class="number">1</span>).collect()</span><br><span class="line">[(<span class="string">'1'</span>, <span class="number">3</span>), (<span class="string">'2'</span>, <span class="number">5</span>), (<span class="string">'a'</span>, <span class="number">1</span>), (<span class="string">'b'</span>, <span class="number">2</span>), (<span class="string">'d'</span>, <span class="number">4</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sc.parallelize(tmp).sortByKey(<span class="literal">True</span>, <span class="number">2</span>).collect()</span><br><span class="line">[(<span class="string">'1'</span>, <span class="number">3</span>), (<span class="string">'2'</span>, <span class="number">5</span>), (<span class="string">'a'</span>, <span class="number">1</span>), (<span class="string">'b'</span>, <span class="number">2</span>), (<span class="string">'d'</span>, <span class="number">4</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tmp2 = [(<span class="string">'Mary'</span>, <span class="number">1</span>), (<span class="string">'had'</span>, <span class="number">2</span>), (<span class="string">'a'</span>, <span class="number">3</span>), (<span class="string">'little'</span>, <span class="number">4</span>), (<span class="string">'lamb'</span>, <span class="number">5</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tmp2.extend([(<span class="string">'whose'</span>, <span class="number">6</span>), (<span class="string">'fleece'</span>, <span class="number">7</span>), (<span class="string">'was'</span>, <span class="number">8</span>), (<span class="string">'white'</span>, <span class="number">9</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sc.parallelize(tmp2).sortByKey(<span class="literal">True</span>, <span class="number">3</span>, keyfunc=<span class="keyword">lambda</span> k: k.lower()).collect()</span><br><span class="line">[(<span class="string">'a'</span>, <span class="number">3</span>), (<span class="string">'fleece'</span>, <span class="number">7</span>), (<span class="string">'had'</span>, <span class="number">2</span>), (<span class="string">'lamb'</span>, <span class="number">5</span>),...(<span class="string">'white'</span>, <span class="number">9</span>), (<span class="string">'whose'</span>, <span class="number">6</span>)]</span><br></pre></td></tr></table></figure><h3 id="RDD-Action算子"><a href="#RDD-Action算子" class="headerlink" title="RDD Action算子"></a>RDD Action算子</h3><ul><li><p>collect</p><ul><li>返回一个list，list中包含 RDD中的所有元素</li><li>只有当数据量较小的时候使用Collect 因为所有的结果都会加载到内存中</li></ul></li><li><p>reduce</p><ul><li><strong>reduce</strong>将<strong>RDD</strong>中元素两两传递给输入函数，同时产生一个新的值，新产生的值与RDD中下一个元素再被传递给输入函数直到最后只有一个值为止。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span>&gt;&gt; rdd1 = sc.parallelize([1,2,3,4,5])</span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt; rdd1.reduce(lambda x,y : x+y)</span><br><span class="line">15</span><br></pre></td></tr></table></figure></li><li><p>first</p><ul><li>返回RDD的第一个元素</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sc.parallelize([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]).first()</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></li><li><p>take</p><ul><li>返回RDD的前N个元素</li><li><code>take</code>(<em>num</em>)</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span>&gt;&gt; sc.parallelize([2, 3, 4, 5, 6]).take(2)</span><br><span class="line">[2, 3]</span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt; sc.parallelize([2, 3, 4, 5, 6]).take(10)</span><br><span class="line">[2, 3, 4, 5, 6]</span><br><span class="line"><span class="meta">&gt;</span>&gt;&gt; sc.parallelize(range(100), 100).filter(lambda x: x &gt; 90).take(3)</span><br><span class="line">[91, 92, 93]</span><br></pre></td></tr></table></figure></li><li><p>count</p><p>返回RDD中元素的个数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sc.parallelize([2, 3, 4]).count()</span><br><span class="line">3</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
            <tag> RDD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDFS的shell操作整理</title>
      <link href="/2019/09/07/HDFS%E5%B8%B8%E7%94%A8Shell%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/"/>
      <url>/2019/09/07/HDFS%E5%B8%B8%E7%94%A8Shell%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>HDFS常用Shell命令整理，后续不断填充。</p></blockquote><a id="more"></a><h3 id="HDFS-shell操作"><a href="#HDFS-shell操作" class="headerlink" title="HDFS shell操作"></a>HDFS shell操作</h3><ul><li><p>调用文件系统(FS)Shell命令应使用 bin/hadoop fs <args>的形式</args></p><ul><li><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><p>使用方法：hadoop fs -ls <args></args></p><p>如果是文件，则按照如下格式返回文件信息：<br>文件名 &lt;副本数&gt; 文件大小 修改日期 修改时间 权限 用户ID 组ID<br>如果是目录，则返回它直接子文件的一个列表，就像在Unix中一样。目录返回列表的信息如下：<br>目录名 <dir> 修改日期 修改时间 权限 用户ID 组ID<br>示例：<br>hadoop fs -ls /user/hadoop/file1 /user/hadoop/file2 hdfs://host:port/user/hadoop/dir1 /nonexistentfile<br>返回值：<br>成功返回0，失败返回-1。 </dir></p></li><li><h3 id="text"><a href="#text" class="headerlink" title="text"></a>text</h3><p>使用方法：hadoop fs -text <src> </src></p><p>将源文件输出为文本格式。允许的格式是zip和TextRecordInputStream。</p></li><li><h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><p>使用方法：hadoop fs -mv URI [URI …] <dest></dest></p><p>将文件从源路径移动到目标路径。这个命令允许有多个源路径，此时目标路径必须是一个目录。不允许在不同的文件系统间移动文件。<br>示例：</p><ul><li>hadoop fs -mv /user/hadoop/file1 /user/hadoop/file2</li><li>hadoop fs -mv hdfs://host:port/file1 hdfs://host:port/file2 hdfs://host:port/file3 hdfs://host:port/dir1</li></ul><p>返回值：</p><p>成功返回0，失败返回-1。</p></li><li><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p>使用方法：hadoop fs -put <localsrc> … <dst></dst></localsrc></p><p>从本地文件系统中复制单个或多个源路径到目标文件系统。也支持从标准输入中读取输入写入目标文件系统。</p><ul><li>hadoop fs -put localfile /user/hadoop/hadoopfile</li><li>hadoop fs -put localfile1 localfile2 /user/hadoop/hadoopdir</li><li>hadoop fs -put localfile hdfs://host:port/hadoop/hadoopfile</li><li>hadoop fs -put - hdfs://host:port/hadoop/hadoopfile<br>从标准输入中读取输入。</li></ul><p>返回值：</p><p>成功返回0，失败返回-1。</p></li><li><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p>使用方法：hadoop fs -rm URI [URI …]</p><p>删除指定的文件。只删除非空目录和文件。请参考rmr命令了解递归删除。<br>示例：</p><ul><li>hadoop fs -rm hdfs://host:port/file /user/hadoop/emptydir</li></ul><p>返回值：</p><p>成功返回0，失败返回-1。</p></li></ul></li></ul><ul><li><span class="exturl" data-url="aHR0cDovL2hhZG9vcC5hcGFjaGUub3JnL2RvY3MvcjEuMC40L2NuL2hkZnNfc2hlbGwuaHRtbA==" title="http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_shell.html">http://hadoop.apache.org/docs/r1.0.4/cn/hdfs_shell.html<i class="fa fa-external-link"></i></span></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
            <tag> HDFS </tag>
            
            <tag> 工具 </tag>
            
            <tag> 整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark引入与理解</title>
      <link href="/2019/09/07/Spark%E7%9A%84%E5%BC%95%E5%85%A5%E4%B8%8E%E7%90%86%E8%A7%A3/"/>
      <url>/2019/09/07/Spark%E7%9A%84%E5%BC%95%E5%85%A5%E4%B8%8E%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Spark学习</p></blockquote><a id="more"></a><h3 id="Spark介绍"><a href="#Spark介绍" class="headerlink" title="Spark介绍"></a>Spark介绍</h3><ul><li><p>1、什么是spark</p><ul><li>基于内存的计算引擎，它的计算速度非常快。但是仅仅只涉及到数据的计算，并没有涉及到数据的存储。</li></ul></li><li><p>2、spark引入</p><p><strong>MapReduce框架局限性</strong></p><ul><li><p>1，Map结果写磁盘，Reduce写HDFS，多个MR之间通过HDFS交换数据</p></li><li><p>2，任务调度和启动开销大</p></li><li><p>3，不适合迭代计算（如机器学习、图计算等等），交互式处理（数据挖掘）</p></li><li><p>4，不适合流式处理（点击日志分析）</p></li><li><p>5，MapReduce编程不够灵活，仅支持Map和Reduce两种操作</p><p><strong>Hadoop生态圈</strong></p><ul><li>批处理：MapReduce、Hive、Pig</li><li>流式计算：Storm</li><li>交互式计算：Impala、presto</li></ul></li></ul><p><strong>需要一种灵活的框架可同时进行批处理、流式计算、交互式计算</strong></p><ul><li>内存计算引擎，提供cache机制来支持需要反复迭代计算或者多次数据共享，减少数据读取的IO开销</li><li>DAG引擎，较少多次计算之间中间结果写到HDFS的开销</li><li>使用多线程模型来减少task启动开销，shuffle过程中避免不必要的sort操作以及减少磁盘IO</li></ul><p>spark的缺点是：吃内存，不太稳定，优点是速度快，spark中的job中间结果可以不落地，可以存放在内存中。</p></li></ul><h3 id="spark集群相关概念"><a href="#spark集群相关概念" class="headerlink" title="spark集群相关概念"></a>spark集群相关概念</h3><ul><li><p>spark集群架构(Standalone模式)</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6tdvi8km5j30fe06wjtc.jpg" alt></p><ul><li><p>Application</p><p>用户自己写的Spark应用程序，批处理作业的集合。Application的main方法为应用程序的入口，用户通过Spark的API，定义了RDD和对RDD的操作。</p></li><li><p>Master和Worker</p><p>整个集群分为 Master 节点和 Worker 节点，相当于 Hadoop 的 Master 和 Slave 节点。</p><ul><li>Master：Standalone模式中主控节点，负责接收Client提交的作业，管理Worker，并命令Worker启动Driver和Executor。</li><li>Worker：Standalone模式中slave节点上的守护进程，负责管理本节点的资源，定期向Master汇报心跳，接收Master的命令，启动Driver和Executor。</li></ul></li><li><p>Client：客户端进程，负责提交作业到Master。</p></li><li><p>Driver： 一个Spark作业运行时包括一个Driver进程，也是作业的主进程，负责作业的解析、生成Stage并调度Task到Executor上。包括DAGScheduler，TaskScheduler。</p></li><li><p>Executor：即真正执行作业的地方，一个集群一般包含多个Executor，每个Executor接收Driver的命令Launch Task，一个Executor可以执行一到多个Task。</p></li></ul></li><li><p>Spark作业相关概念</p><ul><li><p>Stage：一个Spark作业一般包含一到多个Stage。</p></li><li><p>Task：一个Stage包含一到多个Task，通过多个Task实现并行运行的功能。</p></li><li><p>DAGScheduler： 实现将Spark作业分解成一到多个Stage，每个Stage根据RDD的Partition个数决定Task的个数，然后生成相应的Task set放到TaskScheduler中。</p></li><li><p>TaskScheduler：实现Task分配到Executor上执行。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6tdvc99hyj30e30b1aci.jpg" alt></p></li></ul></li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6tdvfebjgj30dy0c0djd.jpg" alt></p><h3 id="Spark下载与安装"><a href="#Spark下载与安装" class="headerlink" title="Spark下载与安装"></a>Spark下载与安装</h3><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/apache/spark/spark-2.4.4/spark-2.4.4-bin-hadoop2.7.tgz</span><br></pre></td></tr></table></figure><h4 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf spark-2.4.4-bin-hadoop2.7.tgz</span><br></pre></td></tr></table></figure><h4 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd conf/  </span><br><span class="line">cp spark-env.sh.template spark-env.sh  </span><br><span class="line">vi spark-env.sh</span><br></pre></td></tr></table></figure><p>添加如下两行（Java home 路径）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME=/usr/lib/jdk/jdk1.8.0_144 </span><br><span class="line">SPARK_WORKER_MEMORY=2g</span><br></pre></td></tr></table></figure><p>vi ~/.bashrc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export SPARK_HOME=/home/parallels/app/spark-2.4.4-bin-hadoop2.7</span><br><span class="line">export PATH=$SPARK_HOME/bin:$SPARK_HOME/sbin:$PATH</span><br></pre></td></tr></table></figure><h4 id="进入"><a href="#进入" class="headerlink" title="进入"></a>进入</h4><p>命令行终端输入后，可以进行使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spark-shell</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6qy2h4rk6j314u0piam7.jpg" alt="image-20190907143800988"></p><p>另外，参考<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAxNzEwMzEvYXJ0aWNsZS9kZXRhaWxzLzUxODQ5NTYy" title="https://blog.csdn.net/u010171031/article/details/51849562">Ubuntu Spark 环境搭建<i class="fa fa-external-link"></i></span>进行配置PATHHOME。</p><p>在PyCharm创建一个DataFrame如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSession</span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> Row</span><br><span class="line"></span><br><span class="line">spark = SparkSession.builder.appName(<span class="string">'test'</span>).getOrCreate()</span><br><span class="line">sc = spark.sparkContext</span><br><span class="line"><span class="comment"># spark.conf.set("spark.sql.shuffle.partitions", 6)</span></span><br><span class="line"><span class="comment"># ================直接创建==========================</span></span><br><span class="line">l = [(<span class="string">'Ankit'</span>,<span class="number">25</span>),(<span class="string">'Jalfaizy'</span>,<span class="number">22</span>),(<span class="string">'saurabh'</span>,<span class="number">20</span>),(<span class="string">'Bala'</span>,<span class="number">26</span>)]</span><br><span class="line">rdd = sc.parallelize(l)</span><br><span class="line"><span class="comment">#为数据添加列名</span></span><br><span class="line">people = rdd.map(<span class="keyword">lambda</span> x: Row(name=x[<span class="number">0</span>], age=int(x[<span class="number">1</span>])))</span><br><span class="line"><span class="comment">#创建DataFrame</span></span><br><span class="line">schemaPeople = spark.createDataFrame(people)</span><br><span class="line">schemaPeople.show()</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6r47ljlg1j31no0dowi8.jpg" alt="image-20190907164208463"></p><p>通过csv建立</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">from pyspark.sql import SparkSession</span><br><span class="line">from pyspark.sql import Row</span><br><span class="line">from pyspark import SparkConf</span><br><span class="line"></span><br><span class="line">SPARK_APP_NAME = &quot;dataframetest&quot;</span><br><span class="line"></span><br><span class="line">conf = SparkConf()</span><br><span class="line">config = (</span><br><span class="line">    (&quot;spark.app.name&quot;, SPARK_APP_NAME),</span><br><span class="line">    (&quot;spark.executor.memory&quot;, &quot;2g&quot;),</span><br><span class="line">    (&quot;spark.executor.cores&quot;, &quot;2&quot;),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">conf.setAll(config)</span><br><span class="line"></span><br><span class="line">spark = SparkSession.builder.config(conf=conf).appName(&apos;test&apos;).getOrCreate()</span><br><span class="line">sc = spark.sparkContext</span><br><span class="line"># spark.conf.set(&quot;spark.sql.shuffle.partitions&quot;, 6)</span><br><span class="line"># ================直接创建==========================</span><br><span class="line">l = [(&apos;Ankit&apos;,25),(&apos;Jalfaizy&apos;,22),(&apos;saurabh&apos;,20),(&apos;Bala&apos;,26)]</span><br><span class="line">rdd = sc.parallelize(l)</span><br><span class="line">#为数据添加列名</span><br><span class="line">people = rdd.map(lambda x: Row(name=x[0], age=int(x[1])))</span><br><span class="line">#创建DataFrame</span><br><span class="line">schemaPeople = spark.createDataFrame(people)</span><br><span class="line">schemaPeople.show()</span><br><span class="line"></span><br><span class="line"># ==================从csv读取======================</span><br><span class="line">#加载csv类型的数据并转换为DataFrame</span><br><span class="line">df = spark.read.format(&quot;csv&quot;).option(&quot;header&quot;, &quot;true&quot;).load(&quot;/tmp/iris.csv&quot;)</span><br><span class="line">#显示数据结构</span><br><span class="line">df.printSchema()</span><br><span class="line">#显示前10条数据</span><br><span class="line">df.show(10)</span><br><span class="line">#统计总量</span><br><span class="line">print(df.count())</span><br><span class="line">#列名</span><br><span class="line">print(df.columns)</span><br></pre></td></tr></table></figure><p>其中，需要先在HDFS上放置iris.csv数据。spark-env.sh、spark-dafault.sh、slave文件参考<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hma3M1NS9hcnRpY2xlL2RldGFpbHMvODA3ODQ0MjQ=" title="https://blog.csdn.net/xfks55/article/details/80784424">spark学习-spark安装和启动<i class="fa fa-external-link"></i></span></p><p>如果出现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.net.UnknownHostException</span><br></pre></td></tr></table></figure><p>请参考<span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC80NzE2ODk5ZWJhMTk=" title="https://www.jianshu.com/p/4716899eba19">启动Spark报Caused by: java.net.UnknownHostException: iotsparkmaster: unknown error<i class="fa fa-external-link"></i></span></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6r9dhtyamj30u014s112.jpg" alt="image-20190907210906138"></p><h3 id="参考-amp-致谢"><a href="#参考-amp-致谢" class="headerlink" title="参考&amp;致谢"></a>参考&amp;致谢</h3><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAxNzEwMzEvYXJ0aWNsZS9kZXRhaWxzLzUxODQ5NTYy" title="https://blog.csdn.net/u010171031/article/details/51849562">https://blog.csdn.net/u010171031/article/details/51849562<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VuY2hlL2FydGljbGUvZGV0YWlscy84MTE0MjM1Nw==" title="https://blog.csdn.net/Enche/article/details/81142357">https://blog.csdn.net/Enche/article/details/81142357<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC80NzE2ODk5ZWJhMTk=" title="https://www.jianshu.com/p/4716899eba19">https://www.jianshu.com/p/4716899eba19<i class="fa fa-external-link"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间换了什么</title>
      <link href="/2019/09/06/%E6%88%91%E7%94%A8%E6%97%B6%E9%97%B4%E6%8D%A2%E4%BA%86%E4%BB%80%E4%B9%88/"/>
      <url>/2019/09/06/%E6%88%91%E7%94%A8%E6%97%B6%E9%97%B4%E6%8D%A2%E4%BA%86%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<blockquote><p>夜深人静，处理一下博客。简单写两句话。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6paqzphqcj31h80pu4qq.jpg" alt="image-20190906042537889"></p><a id="more"></a><blockquote><p>最近这两个月，我回到学校。<br>在图书馆里看书。内心仍有些焦躁。</p><p>离开杭州，离开阿里。<br>我打算去一个新的城市。</p><p>魔都，上海。</p><p>未来，<br>上海，我用时间换得什么？</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HBase引入与理解</title>
      <link href="/2019/09/05/ubuntu%E5%AE%89%E8%A3%85HBase/"/>
      <url>/2019/09/05/ubuntu%E5%AE%89%E8%A3%85HBase/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Hive适用于离线分析，速度较慢，无法支持在线业务。所以引入HBase，记录本文。</p></blockquote><a id="more"></a><h3 id="HBase特点"><a href="#HBase特点" class="headerlink" title="HBase特点"></a>HBase特点</h3><blockquote><p><em>HBase</em>是一个分布式的、面向列的开源数据库，该技术来源于 Fay Chang 所撰写的Google论文“Bigtable：一个结构化数据的分布式存储系统”。</p></blockquote><p>HBase特点</p><ul><li>面向列</li><li>适合非结构化数据的存储，PB级别。</li><li>分布式：易于扩展、动态伸缩、并发处理。用zookeeper管理。</li></ul><p>应用场景</p><ul><li>瞬间写入量很大</li><li>大量数据需要长期保存, 且数量会持续增长</li><li>HBase不适合有join, 多级索引, 表关系复杂的数据模型</li></ul><p>HBase VS 关系型数据库</p><table>  <tr>    <th></th>    <th>HBase</th>    <th>关系型数据库</th>  </tr>  <tr>    <td> 数据库大小 </td>    <td> PB级别  </td>    <td>GB TB</td>  </tr>  <tr>    <td> 数据类型 </td>    <td> Bytes </td>    <td> 丰富的数据类型 </td>  </tr>    <tr>    <td> 事务支持 </td>    <td> ACID只支持单个Row级别 </td>    <td> 全面的ACID支持, 对Row和表</td>  </tr>  <tr>    <td> 索引 </td>    <td> 只支持Row-key </td>    <td> 支持 </td>  </tr>    <tr>    <td> 吞吐量 </td>    <td> 百万写入/秒 </td>    <td> 数千写入/秒</td>  </tr></table><p>行数据库&amp;列数据库存储方式比较</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6olbd3v70j30g00bb76o.jpg" alt></p><h3 id="Hbase表结构"><a href="#Hbase表结构" class="headerlink" title="Hbase表结构"></a>Hbase表结构</h3><ul><li>NameSpace: 关系型数据库的”数据库”(database)</li><li>表(table)：用于存储管理数据，具有稀疏的、面向列的特点。对于为值为空的列，并不占用存储空间。</li><li>行(Row)：在表里面,每一行代表着一个数据对象,每一行都是以一个行键(Row Key)来进行唯一标识的, 行键并没有什么特定的数据类型, 以二进制的字节来存储.</li><li>列(Column): HBase的列由 Column family 和 Column qualifier 组成, 由冒号: 进行行间隔, 如 family: qualifier</li><li>行键(RowKey)：类似于MySQL中的主键，HBase根据行键来快速检索数据，一个行键对应一条记录。与MySQL主键不同的是，HBase的行键是天然固有的，每一行数据都存在行键。</li><li>列族(ColumnFamily)：是列的集合。列族在表定义时需要指定，而列在插入数据时动态指定。列中的数据都是以二进制形式存在，没有数据类型。在物理存储结构上，每个表中的每个列族单独以一个文件存储。一个表可以有多个列簇。</li><li>列修饰符(<em>Column</em> <em>Qualifier</em>) : 列族中的数据通过列标识来进行映射, 可以理解为一个键值对(key-value), 列修饰符(<em>Column</em> <em>Qualifier</em>) 就是key 对应关系型数据库的列</li><li>时间戳(TimeStamp)：是列的一个属性，是一个64位整数。由行键和列确定的单元格，可以存储多个数据，每个数据含有时间戳属性，数据具有版本特性。可根据版本(VERSIONS)或时间戳来指定查询历史版本数据，如果都不指定，则默认返回最新版本的数据。</li><li>区域(Region)：HBase自动把表水平划分成的多个区域，划分的区域随着数据的增大而增多。</li></ul><p>HBase基础结构<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6qrbsuixfj30pw0e40va.jpg" alt></p><ol><li>Client</li><li>ZooKeeper：保证有一个HMaster存活，元数据存储。</li><li>HMaster：对HRegionSever的负载均衡。</li><li>HRegionServer</li><li>HStore：每个列族对应一个HStore，存储数据，内存（MemStore）+文件硬盘（StoreFile）</li><li>HRegion：水平拆分的单元，10G一个。</li><li>HLog：先写HLog，后写MemStore</li></ol><h4 id="HStore"><a href="#HStore" class="headerlink" title="HStore"></a>HStore</h4><ul><li>HBase存储的核心，由MemStore和StoreFile组成。</li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6tduhp86vj30nq0bzt98.jpg" alt></p><ul><li>用户写入数据的流程为：client访问ZK, ZK返回RegionServer地址-&gt; client访问RegionServer写入数据 -&gt; 数据存入MemStore，一直到MemStore满 -&gt; Flush成StoreFile</li></ul><h4 id="HBase模块协作"><a href="#HBase模块协作" class="headerlink" title="HBase模块协作"></a>HBase模块协作</h4><ul><li>HBase启动<ul><li>HMaster启动, 注册到Zookeeper, 等待RegionServer汇报【HMaster注册】</li><li>RegionServer注册到Zookeeper, 并向HMaster汇报【RegionServer注册】</li><li>对各个RegionServer(包括失效的)的数据进行整理, <strong>分配Region和meta信息</strong></li></ul></li><li>RegionServer失效<ul><li>HMaster将失效RegionServer上的Region分配到其他节点</li><li>HMaster更新hbase: meta 表以保证数据正常访问</li></ul></li><li>HMaster失效<ul><li>处于Backup状态的其他HMaster节点推选出一个转为Active状态</li><li>数据能正常读写, 但是不能创建删除表, 也不能更改表结构</li></ul></li></ul><h3 id="HBase安装"><a href="#HBase安装" class="headerlink" title="HBase安装"></a>HBase安装</h3><h4 id="安装包下载"><a href="#安装包下载" class="headerlink" title="安装包下载"></a>安装包下载</h4><p>一开始用的是国外链接，下载得太慢。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://archive.apache.org/dist/hbase/stable/hbase-1.4.10-bin.tar.gz</span><br></pre></td></tr></table></figure><p>该用清华大学的镜像，快了好多，感谢！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/apache/hbase/stable/hbase-1.4.10-bin.tar.gz</span><br></pre></td></tr></table></figure><h4 id="安装过程记录"><a href="#安装过程记录" class="headerlink" title="安装过程记录"></a>安装过程记录</h4><p>配置伪分布式环境</p><ul><li><p>环境变量配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export HBASE_HOME=/usr/local/development/hbase-1.2.4</span><br><span class="line">export PATH=$HBASE_HOME/bin:$PATH</span><br></pre></td></tr></table></figure></li><li><p>配置hbase-env.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/development/jdk1.7.0_15</span><br><span class="line">export HBASE_MANAGES_ZK=false  --如果你是使用hbase自带的zk就是true，如果使用自己的zk就是false</span><br></pre></td></tr></table></figure></li><li><p>配置hbase-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span>　　--hbase持久保存的目录</span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://hadoop001:8020/opt/hbase<span class="tag">&lt;/<span class="name">value</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.cluster.distributed<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  --是否是分布式</span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span>     </span><br><span class="line">          <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.property.clientPort<span class="tag">&lt;/<span class="name">name</span>&gt;</span>    --指定要连接zk的端口</span><br><span class="line">          <span class="tag">&lt;<span class="name">value</span>&gt;</span>2181<span class="tag">&lt;/<span class="name">value</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span>        </span><br><span class="line">          <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.property.dataDir<span class="tag">&lt;/<span class="name">name</span>&gt;</span>            <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/hadoop/app/hbase/zkData<span class="tag">&lt;/<span class="name">value</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>启动hbase（启动的hbase的时候要保证hadoop集群已经启动）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/hbase/bin/start-hbase.sh</span><br></pre></td></tr></table></figure></li><li><p>输入hbase shell（进入shell命令行）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase shell</span><br></pre></td></tr></table></figure></li></ul><h3 id="参考-amp-致谢"><a href="#参考-amp-致谢" class="headerlink" title="参考&amp;致谢"></a>参考&amp;致谢</h3><p><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9IQmFzZS83NjcwMjEzP2ZyPWFsYWRkaW4=" title="https://baike.baidu.com/item/HBase/7670213?fr=aladdin">https://baike.baidu.com/item/HBase/7670213?fr=aladdin<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZseWZpc2gxMTEyMjIvYXJ0aWNsZS9kZXRhaWxzLzUxODkzMDk2" title="https://blog.csdn.net/flyfish111222/article/details/51893096">https://blog.csdn.net/flyfish111222/article/details/51893096<i class="fa fa-external-link"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HBase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive使用</title>
      <link href="/2019/09/05/Hive%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/09/05/Hive%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>对Hive使用的归纳。</p></blockquote><a id="more"></a><h3 id="Hive理解"><a href="#Hive理解" class="headerlink" title="Hive理解"></a>Hive理解</h3><p>在使用hadoop时，开发MapReduce成本较大。为了降低开发成本，引入Hive作为媒介操控MapReduce。类似于汇编语言开发成本高，引入高级语言进行开发，编译执行时转化为汇编语言。</p><h4 id="Hive模块结构"><a href="#Hive模块结构" class="headerlink" title="Hive模块结构"></a>Hive模块结构</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6ok75c4e6j30g308cjsn.jpg" alt="hive模块结构"></p><p>从上图看 Hive整体上可以分为三大块： <strong>用户接口、元数据存储和Driver。</strong></p><ul><li>用户接口：包括 CLI、JDBC/ODBC、WebGUI。<ul><li>CLI(command line interface)为 shell 命令行</li><li>JDBC/ODBC 是 Hive 的 JAVA 实现，与传统数据库JDBC 类似</li><li>WebGUI 是通过浏览器访问 Hive。</li><li>HiveServer2基于Thrift, 允许远程客户端使用多种编程语言如Java、Python向Hive提交请求</li></ul></li><li>元数据存储：通常是存储在关系数据库如 mysql/derby 中。<ul><li>Hive 将元数据存储在数据库中。</li><li>Hive 中的元数据包括<ul><li>表的名字</li><li>表的列</li><li>分区及其属性</li><li>表的属性（是否为外部表等）</li><li>表的数据所在目录等。</li></ul></li></ul></li><li>Driver：<strong>HQL 查询语句生成查询计划交由MapReduce执行</strong>。包括解释器、编译器、优化器、执行器，完成 HQL 查询语句从词法分析、语法分析、编译、优化以及查询计划的生成。生成的查询计划存储在 HDFS 中，并在随后由 MapReduce 调用执行。</li></ul><h3 id="Hive的使用"><a href="#Hive的使用" class="headerlink" title="Hive的使用"></a>Hive的使用</h3><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student(classNo <span class="keyword">string</span>, stuNo <span class="keyword">string</span>, score <span class="built_in">int</span>) <span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">','</span>;</span><br></pre></td></tr></table></figure><p>说明:需要通过row format delimited fields terminated by ‘,’指定列的分隔符。</p><p>表创建完毕后，加载数据使用load命令。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">'文件名.txt'</span> overwrite <span class="keyword">into</span> <span class="keyword">table</span> student;</span><br></pre></td></tr></table></figure><p>其中，文件名是放在执行hive命令的相对目录下。</p><h5 id="内部表与外部表"><a href="#内部表与外部表" class="headerlink" title="内部表与外部表"></a>内部表与外部表</h5><ul><li><p>数据由Hive自身管理，是内部表（managed table）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名（字段名 字段类型，）row format delimited fields terminated by &apos;,&apos;;</span><br></pre></td></tr></table></figure></li><li><p>数据由HDFS管理，为外部表（external table）。创建时，使用external修饰。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">External</span> <span class="keyword">TABLE</span> 表名（字段名 字段类型，）<span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">','</span> location <span class="string">'数据在hdfs上的路径'</span>;</span><br></pre></td></tr></table></figure></li><li><p>区别： </p><ol><li>内部表数据存储的位置是hive.metastore.warehouse.dir（默认：/user/hive/warehouse），外部表数据的存储位置由自己制定； </li><li>删除内部表会直接删除元数据（metadata）及存储数据；删除外部表仅仅会删除元数据，HDFS上的文件并不会被删除； </li><li>对内部表的修改会将修改直接同步给元数据，而对外部表的表结构和分区进行修改，则需要修复（MSCK REPAIR TABLE table_name;）</li></ol></li></ul><h5 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h5><p>分区表实际上就是在表的目录下创建的子目录。通过指定某个分区从而减少查询范围。</p><p>创建</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名 (字段名，字段类型....) partitioned <span class="keyword">by</span> (分区字段名 分区字段类型) <span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">','</span> <span class="keyword">lines</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\n'</span> <span class="keyword">stored</span> <span class="keyword">as</span> textfile;</span><br></pre></td></tr></table></figure><p>存储数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load data local inpath &apos;/home/hadoop/tmp/employee.txt&apos; into table 表名 partition(分区字段名字=&apos;分区的具体值&apos;);</span><br></pre></td></tr></table></figure><p>添加分区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 add if not exists partition(分区字段名字=&apos;分区的具体值&apos;);</span><br></pre></td></tr></table></figure><p>动态分区</p><p>插入数据的时候指定分区的字段，会自动帮助创建分区所对应的文件夹。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> hive.exec.dynamic.partition.mode=nonstrict;</span><br></pre></td></tr></table></figure><h3 id="函数的使用"><a href="#函数的使用" class="headerlink" title="函数的使用"></a>函数的使用</h3><h4 id="lateral-view-explode"><a href="#lateral-view-explode" class="headerlink" title="lateral view explode"></a>lateral view explode</h4><ul><li><p>explode函数 把复杂数据类型 array map 拆开 一行变多行</p></li><li><p>lateral view 和explode函数 配合使用 创建虚拟视图 可以把explode的结果和其它列一起查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> article_id,kw <span class="keyword">from</span> articles</span><br><span class="line"><span class="keyword">lateral</span> <span class="keyword">view</span> <span class="keyword">outer</span> <span class="keyword">explode</span>(key_words) t <span class="keyword">as</span> kw</span><br></pre></td></tr></table></figure></li></ul><p>还有其他函数，可以通过以下命令查看函数说明。</p><ul><li>show functions;  显示所有函数</li><li>desc function 函数名;</li><li>desc function extended 函数名;</li></ul><h3 id="参考-amp-致谢"><a href="#参考-amp-致谢" class="headerlink" title="参考&amp;致谢"></a>参考&amp;致谢</h3><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NzQzNDgyL2FydGljbGUvZGV0YWlscy83ODM5MzY3OA==" title="https://blog.csdn.net/qq_36743482/article/details/78393678">https://blog.csdn.net/qq_36743482/article/details/78393678<i class="fa fa-external-link"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu16安装HIVE全程记录</title>
      <link href="/2019/09/04/ubuntu%E5%AE%89%E8%A3%85Hive/"/>
      <url>/2019/09/04/ubuntu%E5%AE%89%E8%A3%85Hive/</url>
      
        <content type="html"><![CDATA[<blockquote><p>为了方便的使用hdfs，我安装个hive，记录如下。</p></blockquote><a id="more"></a><h3 id="什么是-Hive"><a href="#什么是-Hive" class="headerlink" title="什么是 Hive"></a>什么是 Hive</h3><ul><li>Hive 由 Facebook 实现并开源，是基于 Hadoop 的一个数据仓库工具，可以将结构化的数据映射为一张数据库表，并提供 HQL(Hive SQL)查询功能，底层数据是存储在 HDFS 上。</li><li>Hive 本质: 将 SQL 语句转换为 MapReduce 任务运行，使不熟悉 MapReduce 的用户很方便地利用 HQL 处理和计算 HDFS 上的结构化的数据,是一款基于 HDFS 的 MapReduce <strong>计算框架</strong></li><li>主要用途：用来做离线数据分析，比直接用 MapReduce 开发效率更高。但是运行还是一样的慢～</li></ul><h3 id="安装-数据获取"><a href="#安装-数据获取" class="headerlink" title="安装-数据获取"></a>安装-数据获取</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/apache/hive/hive-3.1.2/apache-hive-3.1.2-bin.tar.gz</span><br></pre></td></tr></table></figure><p>然后解压</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf apache-hive-3.1.2-bin.tar.gz</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6ntd70athj314g04ijsq.jpg" alt="image-20190904154919744"></p><h3 id="安装-配置"><a href="#安装-配置" class="headerlink" title="安装-配置"></a>安装-配置</h3><ol><li><p>hive conf 配置</p><p>进入到 解压后的hive目录 找到 conf目录, 修改配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp hive-env.sh.template hive-env.sh</span><br><span class="line">vi hive-env.sh</span><br></pre></td></tr></table></figure><p>在hive-env.sh中指定hadoop的路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HADOOP_HOME=/home/parallels/app/hadoop-3.1.2</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6ntd5uy85j314g04ijsq.jpg" alt="image-20190904155205013"></p><p>在系统环境变量里添加(我的是在 ~/.bashrc) 并 source该文件，使其生效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export HIVE_HOME=/home/hadoop/app/hive-1.1.0-cdh5.7.0</span><br><span class="line">export PATH=$HIVE_HOME/bin:$PATH</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>数据库参数配置</p><ol><li><p>配置日志（不管有没有问题，先把日志配上，不然后面不好定位问题）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cp hive-log4j2.properties.template hive-log4j2.properties</span><br><span class="line">$ vi hive-log4j2.properties</span><br><span class="line"></span><br><span class="line">配置property.hive.log.dir</span><br><span class="line">property.hive.log.dir =/opt/hive/apache-hive-3.1.1/logs </span><br><span class="line">##注意：logs需要自己创建，在hive目录下mkdir logs）</span><br></pre></td></tr></table></figure></li><li><p>配置hive-site.xml</p><p>配置与mysql的连接。包括 MySql用户、密码、连接地址、驱动。</p><p>其中驱动需要下载、解压jar至hive目录的lib下。</p><p><strong>下载驱动。解压后放入lib目录下</strong>。</p><figure class="highlight plain"><figcaption><span>l</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/mysql/downloads/Connector-J/mysql-connector-java-5.1.48.tar.gz</span><br></pre></td></tr></table></figure><p>下面配置连接信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp hive-default.xml.template   hive-site.xml</span><br></pre></td></tr></table></figure><p>找到以下节点并修改</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionUserName<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>hive<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="comment">&lt;!-- 指定mysql用户名 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionPassword<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>hive<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="comment">&lt;!-- 指定mysql密码 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionURL<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>jdbc:mysql://127.0.0.1:3306/hive<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="comment">&lt;!-- 指定mysql数据库地址 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionDriverName<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="comment">&lt;!-- 指定mysql驱动 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在最前面添加以下2个节点，其中system:java.io.tmpdir对应的value值是你自己建立目录的路径。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>system:java.io.tmpdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>你自己建立的目录<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>system:user.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">value</span>&gt;</span>$&#123;user.name&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>hive.metastore.schema.verification value值改为false</strong></p></li></ol></li><li><p>mySql中的Hive需要初始化</p><p>该操作是初始化hive数据库中的与元数据相关的表。<strong>不要忘记！</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schematool -dbType mysql -initSchema</span><br></pre></td></tr></table></figure></li></ol><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>首先，执行<strong>hive —service metastore</strong> 启动Thrift服务端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive --service metastore</span><br></pre></td></tr></table></figure><p>然后执行hive命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6ntd6ba2tj314g04ijsq.jpg" alt="image-20190904212215830"></p><p>如果没有得到你想要的结果，请在你配置的property.hive.log.dir路径下查看日志，比上网查找原因有用多了，因为配置项比较多，每个人的原因不尽相同。</p><p>比如我，进入hive后，在show databases; 总是提示：Unable to instantiate org.apache.hadoop.hive.ql.metadata.SessionHiveMetaStoreClient，后面经过排查是没有初始化mysql的元数据信息。同时，网上因版本问题，配置的方法可能并不适用，自己多看日志多思考。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>ubuntu16.04中开启和关闭防火墙 </p><ol><li><p>开启防火墙</p><blockquote><p>ufw enable</p></blockquote></li><li><p>关闭防火墙</p><blockquote><p>ufw disable</p></blockquote></li></ol><h3 id="参考-amp-致谢"><a href="#参考-amp-致谢" class="headerlink" title="参考&amp;致谢"></a>参考&amp;致谢</h3><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDEwNTk5MS9hcnRpY2xlL2RldGFpbHMvOTc3ODA3Nzg=" title="https://blog.csdn.net/weixin_44105991/article/details/97780778">https://blog.csdn.net/weixin_44105991/article/details/97780778<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5ndmFsdWUvYXJ0aWNsZS9kZXRhaWxzLzg0MjgyODI3" title="https://blog.csdn.net/zhangvalue/article/details/84282827">https://blog.csdn.net/zhangvalue/article/details/84282827<i class="fa fa-external-link"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu16安装MySQL</title>
      <link href="/2019/09/03/Ubuntu%E5%AE%89%E8%A3%85MySql/"/>
      <url>/2019/09/03/Ubuntu%E5%AE%89%E8%A3%85MySql/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言，因为使用hive需要使用mysql存储元数据，所以我需要在虚拟机ubuntu上安装mysql。之前用压缩包安装过，没有记录，本次形成文档，记录下来。在查询过程中，发现网上有更简单的方法，参考记录如下。</p></blockquote><a id="more"></a><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mysql-server</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6nhfdpgtqj314i0e245z.jpg" alt="image-20190904144532735"></p><p>安装过程中出现</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6nhdgq7evj31420nkae8.jpg" alt="image-20190904144340287"></p><p>输入你要设置的密码即可。<strong>请牢记密码，后面连接数据库需要用到。</strong></p><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mysql-client</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6nhgt1y56j314i0g4ajy.jpg" alt="image-20190904144639079"></p><h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libmysqlclient-dev</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6nhx6579oj314c0e4adb.jpg" alt="image-20190904144853673"></p><h3 id="检验安装是否成功"><a href="#检验安装是否成功" class="headerlink" title="检验安装是否成功"></a>检验安装是否成功</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo netstat -tap | grep mysql</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6nhl1q2cbj314m02ydh8.jpg" alt="image-20190904145057696"></p><p>如上图，则表示<strong>安装成功</strong></p><h3 id="连接与使用"><a href="#连接与使用" class="headerlink" title="连接与使用"></a>连接与使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure><p>会提示你输入密码，输入你之前在第一步设置的密码即可。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6nhx3bccgj314c0e40yc.jpg" alt="image-20190904145642751"></p><p>输入sql即可使用，完毕。</p><hr><p>如果需要远程连接，请继续阅读。</p><p>因为我会有别的服务器访问我的mysql，所以需要数据库开启远程连接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf</span><br></pre></td></tr></table></figure><p>注释bind-address = 127.0.0.1  截图如下：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6nhyoltafj314e0o211x.jpg" alt="image-20190904150359066"></p><p>在数据库操作命令行下授权</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant all on *.* to root@&apos;%&apos; identified by &apos;你的密码&apos; with grant option;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6ni1lc47lj314i0iitda.jpg" alt="image-20190904150638389"></p><p>完毕。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机Ubuntu16安装Hadoop记录</title>
      <link href="/2019/09/01/%E8%99%9A%E6%8B%9F%E6%9C%BAUbuntu16%E5%AE%89%E8%A3%85Hadoop%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/09/01/%E8%99%9A%E6%8B%9F%E6%9C%BAUbuntu16%E5%AE%89%E8%A3%85Hadoop%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>之前安装过但是没有形成文档，这次在虚拟机上重新安装，写个文档记录一下。</p></blockquote><a id="more"></a><h3 id="JDK的安装"><a href="#JDK的安装" class="headerlink" title="JDK的安装"></a>JDK的安装</h3><ol><li><p>jdk获取(网上找的资源，官网比较慢，近期还需要登录): <span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMThJaWNQWWY3VzBqLXNIQlh2Zkt5eWc=" title="https://pan.baidu.com/s/18IicPYf7W0j-sHBXvfKyyg">百度网盘<i class="fa fa-external-link"></i></span>，下载后并解压至 你想要安装的目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf jdk-8u161-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6n85q0jlxj31gu03m758.jpg" alt="image-20190902153125453"></p></li><li><p>环境变量配置(<strong>在~/.bashrc 最下面添加</strong>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#set java evironment </span><br><span class="line">export JAVA_HOME=/home/parallels/app/jdk1.8.0_161</span><br><span class="line">export CLASSPATH=.$JAVA_HOME/lib/dt.jar:JAVA_HOME/lib/tools.jar</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br></pre></td></tr></table></figure><p>注意：JAVA_HOME<strong>需要改成解压后所在的目录</strong></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6n85r9yavj31ig0o6dmg.jpg" alt="image-20190902161002701"></p><p>注意：如果无法编辑，记得前面加sudo， <strong>记得保存wq</strong></p></li><li><p>配置生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure></li><li><p>检验</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6n85qbwrzj31fy03ujsk.jpg" alt="image-20190902161224672"></p><p>返回如上结果，JDK安装完毕。</p></li></ol><h3 id="Hadoop的安装"><a href="#Hadoop的安装" class="headerlink" title="Hadoop的安装"></a>Hadoop的安装</h3><ol><li><p>安装包获取</p><p>到<span class="exturl" data-url="aHR0cDovL3d3dy5hcGFjaGUub3JnL2R5bi9jbG9zZXIuY2dpL2hhZG9vcC9jb21tb24vaGFkb29wLTMuMS4wL2hhZG9vcC0zLjEuMC50YXIuZ3o=" title="http://www.apache.org/dyn/closer.cgi/hadoop/common/hadoop-3.1.0/hadoop-3.1.0.tar.gz">官网<i class="fa fa-external-link"></i></span>下载对应的安装包，然后解压到本地目录下。</p></li><li><p>设置环境变量（~/.bashrc）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export HADOOP_HOME=/home/parallels/app/hadoop-3.1.2</span><br><span class="line">export PATH=$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$PATH</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6n85qw1bcj31ik0ougsb.jpg" alt="image-20190902163351443"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc  ## source一下，使之生效。</span><br></pre></td></tr></table></figure></li><li><p>配置（../etc/hadoop/）</p><ol><li><p><strong>core-site.xml</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;hdfs://localhost:9000&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>hdfs-site.xml</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;1&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>hadoop-env.sh</strong></p><p>在尾部设置JAVA_HOME</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/home/parallels/app/jdk1.8.0_161</span><br></pre></td></tr></table></figure></li><li><p>初始格式化（仅需运行一次）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop namenode -format</span><br></pre></td></tr></table></figure></li></ol></li><li><p>启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sbin/start-dfs.sh</span><br></pre></td></tr></table></figure><ol><li><p>提示出错（没有则跳过）</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6n85rpnksj31ca070aco.jpg" alt="image-20190902165318600"></p><p>解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -e|grep ssh</span><br></pre></td></tr></table></figure><p>没有返回，则可能没有安装ssh, 则安装ssh</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure></li><li><p>提示出错（没有则跳过）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Starting namenodes on [localhost]</span><br><span class="line">ERROR: Attempting to operate on hdfs namenode as root</span><br><span class="line">ERROR: but there is no HDFS_NAMENODE_USER defined. Aborting operation.</span><br><span class="line">Starting datanodes</span><br><span class="line">ERROR: Attempting to operate on hdfs datanode as root</span><br><span class="line">ERROR: but there is no HDFS_DATANODE_USER defined. Aborting operation.</span><br><span class="line">Starting secondary namenodes [account.jetbrains.com]</span><br><span class="line">ERROR: Attempting to operate on hdfs secondarynamenode as root</span><br><span class="line">ERROR: but there is no HDFS_SECONDARYNAMENODE_USER defined. Aborting operation.</span><br></pre></td></tr></table></figure><p>解决：</p><p>添加如下</p><p>在start-dfs.sh中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HDFS_DATANODE_USER=root</span><br><span class="line">HADOOP_SECURE_DN_USER=hdfs</span><br><span class="line">HDFS_NAMENODE_USER=root</span><br><span class="line">HDFS_SECONDARYNAMENODE_USER=root</span><br></pre></td></tr></table></figure><p>在start-yarn.sh中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YARN_RESOURCEMANAGER_USER=root</span><br><span class="line">HADOOP_SECURE_DN_USER=yarn</span><br><span class="line">YARN_NODEMANAGER_USER=root</span><br></pre></td></tr></table></figure></li><li><p>提示出错（没有则跳过）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">WARNING: HADOOP_SECURE_DN_USER has been replaced by HDFS_DATANODE_SECURE_USER. Using value of HADOOP_SECURE_DN_USER.</span><br><span class="line">Starting namenodes on [localhost]</span><br><span class="line">/etc/profile: line 30: Shared: command not found</span><br><span class="line">localhost: Warning: Permanently added &apos;localhost&apos; (ECDSA) to the list of known hosts.</span><br><span class="line">localhost: Permission denied (publickey,password).</span><br><span class="line">Starting datanodes</span><br><span class="line">/etc/profile: line 30: Shared: command not found</span><br><span class="line">localhost: Permission denied (publickey,password).</span><br><span class="line">Starting secondary namenodes [account.jetbrains.com]</span><br><span class="line">/etc/profile: line 30: Shared: command not found</span><br><span class="line">account.jetbrains.com: Warning: Permanently added &apos;account.jetbrains.com,0.0.0.0&apos; (ECDSA) to the list of known hosts.</span><br><span class="line">account.jetbrains.com: Permission denied (publickey,password).</span><br></pre></td></tr></table></figure><p>解决：</p><p>此时 <code>ssh localhost</code>也会失败，原因是秘钥没有给自己。</p><p>在~目录的.ssh下生成秘钥 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -P &quot;&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id -i /home/hadoop/.ssh/id_rsa.pub 用户名@localhost</span><br></pre></td></tr></table></figure></li></ol><p>启动成功后显示</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6n85s6ewlj314e0ac418.jpg" alt="image-20190904085030339"></p></li></ol><h3 id="HDFS-shell操作"><a href="#HDFS-shell操作" class="headerlink" title="HDFS shell操作"></a>HDFS shell操作</h3><ul><li><p>在centos 中创建 test.txt  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch test.txt</span><br></pre></td></tr></table></figure></li><li><p>在centos中为test.txt 添加文本内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi test.txt</span><br></pre></td></tr></table></figure></li><li><p>在HDFS中创建 hadoop001/test 文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop fs -mkdir -p /hadoop001/test</span><br></pre></td></tr></table></figure></li><li><p>把text.txt文件上传到HDFS中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop fs -put test.txt /hadoop001/test/</span><br></pre></td></tr></table></figure></li><li><p>查看hdfs中 hadoop001/test/test.txt 文件内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop fs -cat /hadoop001/test/test.txt</span><br></pre></td></tr></table></figure></li><li><p>将hdfs中 hadoop001/test/test.txt文件下载到centos</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop fs -get /hadoop001/test/test.txt test.txt</span><br></pre></td></tr></table></figure></li><li><p>删除HDFS中 hadoop001/test/</p><p>hadoop fs -rm -r /hadoop001</p></li></ul><h3 id="页面访问"><a href="#页面访问" class="headerlink" title="页面访问"></a>页面访问</h3><p>因为hadoop用的是3.1版本</p><p>对应的web访问链接是</p><ul><li><p><span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4MDg4" title="http://localhost:8088">http://localhost:8088<i class="fa fa-external-link"></i></span></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6naeq5szbj322n0u0h1z.jpg" alt="image-20190904104242706"></p></li><li><p><span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo5ODcw" title="http://localhost:9870">http://localhost:9870<i class="fa fa-external-link"></i></span></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6naf2eq7bj323o0oowml.jpg" alt="image-20190904104301551"></p></li></ul><p>端口不是50070</p><h3 id="坑点"><a href="#坑点" class="headerlink" title="坑点"></a>坑点</h3><p>我配置mysql、hive后，重启一次，发现namenode没有启动起来，<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo5ODcw5peg5rOV6K6/6Zeu77yM5ZCO5p2l5ZyoaGRmcy1zaXRlLnhtbA==" title="http://localhost:9870无法访问，后来在hdfs-site.xml">http://localhost:9870无法访问，后来在hdfs-site.xml<i class="fa fa-external-link"></i></span> 在 configuration节点中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;/home/hadoop/app/tmp/dfs/name&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;/home/hadoop/app/tmp/dfs/data&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><p>然后有运行了一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop namenode -format</span><br></pre></td></tr></table></figure><p>重新启动才好。但是在启动日志里没有发现异常，坑点。</p><h3 id="参考-amp-致谢"><a href="#参考-amp-致谢" class="headerlink" title="参考&amp;致谢"></a>参考&amp;致谢</h3><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNjM1MDY5L2FydGljbGUvZGV0YWlscy84MDg1OTc5MA==" title="https://blog.csdn.net/qq_32635069/article/details/80859790">安装hadoop3.0版本踩坑<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01yX0xvbi9hcnRpY2xlL2RldGFpbHMvODgxOTgxMTk=" title="https://blog.csdn.net/Mr_Lon/article/details/88198119">localhost: Permission denied<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpdHVsaWFuZy9hcnRpY2xlL2RldGFpbHMvNzI5MDQ0NDk=" title="https://blog.csdn.net/situliang/article/details/72904449">Ubuntu下搭建hadoop出现Permission denied<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE0OTIwL2FydGljbGUvZGV0YWlscy84MDUyNjM3Ng==" title="https://blog.csdn.net/qq_35614920/article/details/80526376">Ubuntu16.04下Hadoop3.1的安装与配置<i class="fa fa-external-link"></i></span><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NjE0OTIwL2FydGljbGUvZGV0YWlscy84MDUyNjM3Ng==" title="https://blog.csdn.net/qq_35614920/article/details/80526376">https://blog.csdn.net/qq_35614920/article/details/80526376<i class="fa fa-external-link"></i></span>)</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KNN在推荐领域的应用</title>
      <link href="/2019/08/30/KNN%E5%9C%A8%E6%8E%A8%E8%8D%90%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2019/08/30/KNN%E5%9C%A8%E6%8E%A8%E8%8D%90%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>介绍KNN在推荐领域的应用。<br><a id="more"></a></p></blockquote><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前面已经初步介绍了<span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9kNWQ2NDU5N2VlMjM=" title="https://www.jianshu.com/p/d5d64597ee23">推荐系统<i class="fa fa-external-link"></i></span>，同时作者也介绍了<span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9lY2JmNzQ5MGY4ZDY=" title="https://www.jianshu.com/p/ecbf7490f8d6">机器学习算法KNN<i class="fa fa-external-link"></i></span>，那么本文着重介绍如何具体将KNN算法应用于推荐领域。</p><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>利用与该用户喜好相似（皮尔逊相关）的前N个用户，对某电影的评分来预测该用户对某电影的评分</p><p><strong>评分预测公式：</strong></p><script type="math/tex; mode=display">pred(u,i)=\hat{r}_{ui}=\cfrac{\sum_{v\in U}sim(u,v)*r_{vi}}{\sum_{v\in U}|sim(u,v)|}</script><h3 id="数据集获取"><a href="#数据集获取" class="headerlink" title="数据集获取"></a>数据集获取</h3><p>数据集来自于<span class="exturl" data-url="aHR0cHM6Ly9ncm91cGxlbnMub3JnL2RhdGFzZXRzL21vdmllbGVucy9sYXRlc3Qv" title="https://grouplens.org/datasets/movielens/latest/">MovieLens Latest Datasets Small<i class="fa fa-external-link"></i></span></p><p>为方便单机实验，本文采用<span class="exturl" data-url="aHR0cDovL2ZpbGVzLmdyb3VwbGVucy5vcmcvZGF0YXNldHMvbW92aWVsZW5zL21sLWxhdGVzdC1zbWFsbC56aXA=" title="http://files.grouplens.org/datasets/movielens/ml-latest-small.zip">ml-latest-small.zip<i class="fa fa-external-link"></i></span></p><h3 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h3><blockquote><ol><li><p>数据获取。</p></li><li><p>数据准备（为提高速度，本文采用pandas的read_pickle&amp;to_pickle进行中间结果缓存）</p><p>缓存&amp;计算皮尔逊相似度。</p></li><li><p>预测（核心）</p><ol><li>找到皮尔逊正相关前N个相似用户。</li><li>利用pred(u,i)公式计算相似用户对某个电影的评分，即预测出的评分。</li></ol></li><li><p>对上述算法流程调用&amp;调试。</p></li></ol></blockquote><p>对应代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">DATA_PATH = <span class="string">"./data/ml-latest-small/ratings.csv"</span></span><br><span class="line">CACHE_DIR = <span class="string">"./data/"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span><span class="params">(data_path)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    加载数据</span></span><br><span class="line"><span class="string">    :param data_path: 数据集路径</span></span><br><span class="line"><span class="string">    :param cache_path: 数据集缓存路径</span></span><br><span class="line"><span class="string">    :return: 用户-物品评分矩阵</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># 数据集缓存地址</span></span><br><span class="line">    cache_path = os.path.join(CACHE_DIR, <span class="string">"ratings_matrix.cache"</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"开始加载数据集..."</span>)</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(cache_path):    <span class="comment"># 判断是否存在缓存文件</span></span><br><span class="line">        print(<span class="string">"加载缓存中..."</span>)</span><br><span class="line">        ratings_matrix = pd.read_pickle(cache_path)</span><br><span class="line">        print(<span class="string">"从缓存加载数据集完毕"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"加载新数据中..."</span>)</span><br><span class="line">        <span class="comment"># 设置要加载的数据字段的类型</span></span><br><span class="line">        dtype = &#123;<span class="string">"userId"</span>: np.int32, <span class="string">"movieId"</span>: np.int32, <span class="string">"rating"</span>: np.float32&#125;</span><br><span class="line">        <span class="comment"># 加载数据，分别是用户ID，电影ID，已经用户对电影的对应评分(使用前3列)</span></span><br><span class="line">        ratings = pd.read_csv(data_path, dtype=dtype, usecols=range(<span class="number">3</span>))</span><br><span class="line">        <span class="comment"># 透视表，将电影ID转换为列名称，转换成为一个User-Movie的评分矩阵</span></span><br><span class="line">        ratings_matrix = ratings.pivot_table(index=[<span class="string">"userId"</span>], columns=[<span class="string">"movieId"</span>], values=<span class="string">"rating"</span>)</span><br><span class="line">        <span class="comment"># 存入缓存文件</span></span><br><span class="line">        ratings_matrix.to_pickle(cache_path)</span><br><span class="line">        print(<span class="string">"数据集加载完毕"</span>)</span><br><span class="line">    <span class="keyword">return</span>  ratings_matrix</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_pearson_similarity</span><span class="params">(ratings_matrix)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    计算用户皮尔逊相关系数</span></span><br><span class="line"><span class="string">    :param ratings_matrix: 用户-物品评分矩阵</span></span><br><span class="line"><span class="string">    :return: 相似度矩阵</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    user_similarity_cache_path = os.path.join(CACHE_DIR, <span class="string">"user_similarity.cache"</span>)</span><br><span class="line">    <span class="comment"># 基于皮尔逊相关系数计算相似度</span></span><br><span class="line">    <span class="comment"># 用户相似度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(user_similarity_cache_path):</span><br><span class="line">        print(<span class="string">"正从缓存加载用户相似度矩阵"</span>)</span><br><span class="line">        similarity = pd.read_pickle(user_similarity_cache_path)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"开始计算用户相似度矩阵"</span>)</span><br><span class="line">        similarity = ratings_matrix.T.corr()</span><br><span class="line">        similarity.to_pickle(user_similarity_cache_path)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"相似度矩阵计算/加载完毕"</span>)</span><br><span class="line">    <span class="keyword">return</span> similarity</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(uid, iid, ratings_matrix, user_similar)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    预测给定用户对给定物品的评分值</span></span><br><span class="line"><span class="string">    :param uid: 用户ID</span></span><br><span class="line"><span class="string">    :param iid: 物品ID</span></span><br><span class="line"><span class="string">    :param ratings_matrix: 用户-物品评分矩阵</span></span><br><span class="line"><span class="string">    :param user_similar: 用户两两相似度矩阵</span></span><br><span class="line"><span class="string">    :return: 预测的评分值</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    print(<span class="string">"开始预测用户&lt;%d&gt;对电影&lt;%d&gt;的评分..."</span>%(uid, iid))</span><br><span class="line">    <span class="comment"># 1. 找出uid用户的相似用户</span></span><br><span class="line">    similar_users = user_similar[uid].drop([uid]).dropna().sort_values(ascending=<span class="literal">False</span>)[:<span class="number">25</span>]</span><br><span class="line">    <span class="comment"># 相似用户筛选规则：正相关的用户</span></span><br><span class="line">    similar_users = similar_users.where(similar_users&gt;<span class="number">0</span>).dropna()</span><br><span class="line">    <span class="keyword">if</span> similar_users.empty <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">"用户&lt;%d&gt;没有相似的用户"</span> % uid)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 从uid用户的近邻相似用户中筛选出对iid物品有评分记录的近邻用户</span></span><br><span class="line">    ids = set(ratings_matrix[iid].dropna().index)&amp;set(similar_users.index)</span><br><span class="line">    finally_similar_users = similar_users.ix[list(ids)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> finally_similar_users.empty <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">"用户&lt;%d&gt;相似的用户没有对&lt;%d&gt;电影的评分"</span> % (uid, iid))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 结合uid用户与其近邻用户的相似度预测uid用户对iid物品的评分</span></span><br><span class="line">    sum_up = <span class="number">0</span>    <span class="comment"># 评分预测公式的分子部分的值</span></span><br><span class="line">    sum_down = <span class="number">0</span>    <span class="comment"># 评分预测公式的分母部分的值</span></span><br><span class="line">    <span class="keyword">for</span> sim_uid, similarity <span class="keyword">in</span> finally_similar_users.iteritems():</span><br><span class="line">        <span class="comment"># 近邻用户的评分数据</span></span><br><span class="line">        <span class="comment"># sim_user_rated_movies = ratings_matrix.ix[sim_uid].dropna()</span></span><br><span class="line">        <span class="comment"># 近邻用户对iid物品的评分</span></span><br><span class="line">        <span class="comment"># sim_user_rating_for_item = sim_user_rated_movies[iid]</span></span><br><span class="line">        sim_user_rating_for_item = ratings_matrix.ix[sim_uid, iid]</span><br><span class="line">        <span class="comment"># 计算分子的值</span></span><br><span class="line">        sum_up += similarity * sim_user_rating_for_item</span><br><span class="line">        <span class="comment"># 计算分母的值</span></span><br><span class="line">        sum_down += similarity</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算预测的评分值并返回</span></span><br><span class="line">    predict_rating = sum_up/sum_down</span><br><span class="line">    print(<span class="string">"预测出用户&lt;%d&gt;对电影&lt;%d&gt;的评分：%0.2f"</span> % (uid, iid, predict_rating))</span><br><span class="line">    <span class="keyword">return</span> round(predict_rating, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    ratings_matrix = load_data(DATA_PATH)</span><br><span class="line">    print(ratings_matrix.head())</span><br><span class="line">    user_similar = compute_pearson_similarity(ratings_matrix)</span><br><span class="line">    print(user_similar.head())</span><br><span class="line">    <span class="comment"># 预测用户1对物品1的评分</span></span><br><span class="line">    predict(<span class="number">1</span>, <span class="number">1</span>, ratings_matrix, user_similar)</span><br><span class="line">    <span class="comment"># 预测用户1对物品2的评分</span></span><br><span class="line">    predict(<span class="number">1</span>, <span class="number">2</span>, ratings_matrix, user_similar)</span><br></pre></td></tr></table></figure><h3 id="参考-amp-致谢"><a href="#参考-amp-致谢" class="headerlink" title="参考&amp;致谢"></a>参考&amp;致谢</h3><blockquote><ol><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RhbmxhbmdxaWUvYXJ0aWNsZS9kZXRhaWxzLzc4NjU2NTg4" title="https://blog.csdn.net/tanlangqie/article/details/78656588">python中dataframe常见操作：取行、列、切片、统计特征值<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8xMTE1Njk5ZTA2NzQ=" title="https://www.jianshu.com/p/1115699e0674">Python 基本操作- 数据选取loc、iloc、ix函数<i class="fa fa-external-link"></i></span></li><li>黑马机器学习讲义</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推荐系统 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基准预测思想在推荐里的应用</title>
      <link href="/2019/08/30/%E5%9F%BA%E5%87%86%E9%A2%84%E6%B5%8B%E6%80%9D%E6%83%B3%E5%9C%A8%E6%8E%A8%E8%8D%90%E9%87%8C%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2019/08/30/%E5%9F%BA%E5%87%86%E9%A2%84%E6%B5%8B%E6%80%9D%E6%83%B3%E5%9C%A8%E6%8E%A8%E8%8D%90%E9%87%8C%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>介绍基准预测思想在推荐里的应用</p></blockquote><a id="more"></a><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>接上文，<span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8yNzZhNDM2Y2E3YTk=" title="https://www.jianshu.com/p/276a436ca7a9">KNN在推荐领域的应用<i class="fa fa-external-link"></i></span>文章里介绍了KNN在推荐系统里如何预测评分。但是，在实际用户评论时，每个用户都有自己的评分体系，有的用户要求相对苛刻，五分制的评分里一般只给到一二分，有的用户相对“心慈手软”一般会给到四五分。同时，对于电影来说，有的电影本身自带光环，随上映时间等因素也会有偏差。如何减少上述问题给预测带来的负面影响，本文将着重阐述。</p><h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><p>无论是个体用户还是物品，评分普遍高于或低于平均值的差值，我们称为偏置(bias)。</p><blockquote><p>所有电影的平均评分$\mu$（即全局平均评分）</p><p>每个用户评分与平均评分$\mu$的偏置值$b_u$</p><p>每部电影所接受的评分与平均评分$\mu$的偏置值$b_i$</p></blockquote><p>那么，预测用户对电影的评分则是：</p><script type="math/tex; mode=display">\hat{r}_{ui} = b_{ui} = \mu + b_u + b_i</script><p>举例<sup>[1]</sup>：</p><p>​    比如我们想通过Baseline来预测用户A对电影“阿甘正传”的评分，那么首先计算出整个评分数据集的平均评分$\mu$是3.5分；而用户A是一个比较苛刻的用户，他的评分比较严格，普遍比平均评分低0.5分，即用户A的偏置值$b_i$是-0.5；而电影“阿甘正传”是一部比较热门而且备受好评的电影，它的评分普遍比平均评分要高1.2分，那么电影“阿甘正传”的偏置值$b_i$是+1.2，因此就可以预测出用户A对电影“阿甘正传”的评分为：$3.5+(-0.5)+1.2$，也就是4.2分。</p><p><strong>由此而来，我们把预测某个用户对某个电影的评分，转变成求偏置参数$b_u$和$b_i$的最优解的线性回归问题。</strong></p><p>代价函数是：</p><script type="math/tex; mode=display">\begin{split}Cost &= \sum_{u,i\in R}(r_{ui}-\hat{r}_{ui})^2\\&=\sum_{u,i\in R}(r_{ui}-\mu-b_u-b_i)^2\end{split}</script><p>最优化问题是应用数学的重要研究领域，主要研究在给定约束的情况下如何寻求某个因素，使某一指标达到最优。</p><h3 id="梯度下降解法"><a href="#梯度下降解法" class="headerlink" title="梯度下降解法"></a>梯度下降解法</h3><p>如果将代价函数是 $y=k(x+b)^2$,求当y的最小值时，x应该为多少。这个问题很简单，属于高中数学。但是问题在复杂一些，变成$y=k(x+z+b)^2$，x和z 与将会组成一个三维图形。如何找到最低点，可以采用一个逐步逼近的策略，即梯度下降。具体可以参见<span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9jN2U2NDI4NzdiMGU=" title="https://www.jianshu.com/p/c7e642877b0e">深入浅出—梯度下降法及其实现<i class="fa fa-external-link"></i></span>。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6h2dyvnq9j30wi0u016x.jpg" alt="image-20190830012131423"></p><h4 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h4><p>损失函数：</p><script type="math/tex; mode=display">\begin{split}&J(\theta)=Cost=f(b_u, b_i)\\\\&J(\theta)=\sum_{u,i\in R}(r_{ui}-\mu-b_u-b_i)^2 + \lambda*(\sum_u {b_u}^2 + \sum_i {b_i}^2)\end{split}</script><p>梯度下降参数更新原始公式：</p><script type="math/tex; mode=display">\theta_j:=\theta_j-\alpha\cfrac{\partial }{\partial \theta_j}J(\theta)</script><p>损失函数偏导推导：</p><script type="math/tex; mode=display">\begin{split}\cfrac{\partial}{\partial b_u} J(\theta)&=\cfrac{\partial}{\partial b_u} f(b_u, b_i)\\&=2\sum_{u,i\in R}(r_{ui}-\mu-b_u-b_i)(-1) + 2\lambda{b_u}\\&=-2\sum_{u,i\in R}(r_{ui}-\mu-b_u-b_i) + 2\lambda*b_u\end{split}</script><p>bu更新(因为alpha可以人为控制，所以2可以省略掉)：</p><script type="math/tex; mode=display">\begin{split}b_u&:=b_u - \alpha*(-\sum_{u,i\in R}(r_{ui}-\mu-b_u-b_i) + \lambda * b_u)\\&:=b_u + \alpha*(\sum_{u,i\in R}(r_{ui}-\mu-b_u-b_i) - \lambda* b_u)\end{split}</script><p>同理可得，梯度下降更新$b_i$:</p><script type="math/tex; mode=display">b_i:=b_i + \alpha*(\sum_{u,i\in R}(r_{ui}-\mu-b_u-b_i) -\lambda*b_i)</script><h3 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 数据加载</span></span><br><span class="line">dtype = [(<span class="string">"userId"</span>, np.int32), (<span class="string">"movieId"</span>, np.int32), (<span class="string">"rating"</span>, np.float32)]</span><br><span class="line">dataset = pd.read_csv(<span class="string">"./data/ml-latest-small/ratings.csv"</span>, usecols=range(<span class="number">3</span>), dtype=dict(dtype))</span><br><span class="line">print(dataset.head())</span><br><span class="line">users_ratings = dataset.groupby(<span class="string">"userId"</span>).agg([list])</span><br><span class="line">print(users_ratings.head())</span><br><span class="line">items_ratings = dataset.groupby(<span class="string">"movieId"</span>).agg([list])</span><br><span class="line">print(items_ratings.head())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算全局的平均分</span></span><br><span class="line">global_mean = dataset[<span class="string">'rating'</span>].mean()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化bu bi</span></span><br><span class="line">bu = dict(zip(users_ratings.index, np.zeros(len(users_ratings.index))))</span><br><span class="line">bi = dict(zip(items_ratings.index, np.zeros(len(items_ratings.index))))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    print(<span class="string">'iter%d'</span> % i)</span><br><span class="line">    <span class="keyword">for</span> uid, iid, real_rating <span class="keyword">in</span> dataset.itertuples(index=<span class="literal">False</span>):</span><br><span class="line">        <span class="comment"># 计算损失</span></span><br><span class="line">        error = real_rating - (global_mean + bu[uid] + bi[iid])</span><br><span class="line">        bu[uid] += <span class="number">0.1</span> * (error - <span class="number">0.1</span> * bu[uid])</span><br><span class="line">        bi[iid] += <span class="number">0.1</span> * (error - <span class="number">0.1</span> * bi[iid])</span><br><span class="line"></span><br><span class="line">print(bu)</span><br><span class="line">print(bi)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测评分</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predit</span><span class="params">(uid, iid)</span>:</span></span><br><span class="line">    predit_rating = global_mean + bu[uid] + bi[iid]</span><br><span class="line">    <span class="keyword">return</span> predit_rating</span><br><span class="line"></span><br><span class="line">print(predit(<span class="number">1</span>,<span class="number">1</span>))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推荐系统 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推荐系统的引入</title>
      <link href="/2019/08/30/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%95%E5%85%A5/"/>
      <url>/2019/08/30/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%95%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>介绍推荐系统的背景和算法实践。<br><a id="more"></a></p></blockquote><h3 id="背景-amp-条件"><a href="#背景-amp-条件" class="headerlink" title="背景&amp;条件"></a>背景&amp;条件</h3><blockquote><ol><li><p>信息过载</p><p>人们逐渐从信息匮乏的时代走入了信息过载<sup>[1]</sup>，如何从大量信息中找到自己感兴趣的信息是一件非常困难的事情。</p></li><li><p>用户需求不明确</p><p>当用户需求明确，虽然有信息过载，也可以使用搜索系统解决用户需求。</p></li></ol></blockquote><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>电子商务</li><li>社交</li><li>个性化音乐、图书、电影、邮件</li><li>广告</li></ul><h3 id="系统评测"><a href="#系统评测" class="headerlink" title="系统评测"></a>系统评测</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6fcljv3koj30ce0c8my0.jpg" alt="image-20190828135357751"></p><ul><li><p>用户角度</p><blockquote><p>给用户推荐那些他们感兴趣的内容</p></blockquote></li><li><p>内容提供方角度</p><blockquote><p>各内容提供方都能够被推荐给对其感兴趣的用户</p></blockquote></li><li><p>网站角度</p><blockquote><p>推荐系统本身收集到高质量的用户反馈，自身系统不断迭代，提高推荐质量。从而产生效益。</p></blockquote></li></ul><h3 id="推荐系统基础算法"><a href="#推荐系统基础算法" class="headerlink" title="推荐系统基础算法"></a>推荐系统基础算法</h3><h4 id="基于邻域的算法"><a href="#基于邻域的算法" class="headerlink" title="基于邻域的算法"></a>基于邻域的算法</h4><p>算法思想：<strong>物以类聚，人以群分</strong></p><p>基本的协同过滤推荐算法基于以下假设：</p><ul><li>“跟你喜好<strong>相似的人</strong>喜欢的东西你也很有可能喜欢” ：基于用户的协同过滤推荐（User-based CF）</li><li>“跟你喜欢的东西<strong>相似的东西</strong>你也很有可能喜欢 ”：基于物品的协同过滤推荐（Item-based CF）</li></ul><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6fr2yke46j312x05ujss.jpg" alt></p><p>备注</p><ol><li>构建数据集：注意这里构建评分数据时，对于缺失的部分我们需要保留为None，如果设置为0那么会被当作评分值为0去对待</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">users = [<span class="string">"User1"</span>, <span class="string">"User2"</span>, <span class="string">"User3"</span>, <span class="string">"User4"</span>, <span class="string">"User5"</span>]</span><br><span class="line">items = [<span class="string">"Item A"</span>, <span class="string">"Item B"</span>, <span class="string">"Item C"</span>, <span class="string">"Item D"</span>, <span class="string">"Item E"</span>]</span><br><span class="line"><span class="comment"># 用户购买记录数据集</span></span><br><span class="line">datasets = [</span><br><span class="line">    [<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="literal">None</span>],</span><br><span class="line">    [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>],</span><br><span class="line">    [<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>],</span><br><span class="line">    [<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ol><li><p>计算相似度：对于评分数据这里我们采用皮尔逊相关系数[-1,1]来计算，-1表示强负相关，+1表示强正相关</p><blockquote><p>pandas中corr方法可直接用于计算皮尔逊相关系数，备注：<strong>按列计算！</strong></p></blockquote></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(datasets,</span><br><span class="line">                  columns=items,</span><br><span class="line">                  index=users)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"用户之间的两两相似度："</span>)</span><br><span class="line"><span class="comment"># 直接计算皮尔逊相关系数</span></span><br><span class="line"><span class="comment"># 默认是按列进行计算，因此如果计算用户间的相似度，当前需要进行转置</span></span><br><span class="line">user_similar = df.T.corr()</span><br><span class="line">print(user_similar.round(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">print(<span class="string">"物品之间的两两相似度："</span>)</span><br><span class="line">item_similar = df.corr()</span><br><span class="line">print(item_similar.round(<span class="number">4</span>))</span><br></pre></td></tr></table></figure><p>对应结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行结果：</span></span><br><span class="line">用户之间的两两相似度：</span><br><span class="line">        User1   User2   User3   User4   User5</span><br><span class="line">User1  <span class="number">1.0000</span>  <span class="number">0.8528</span>  <span class="number">0.7071</span>  <span class="number">0.0000</span> <span class="number">-0.7921</span></span><br><span class="line">User2  <span class="number">0.8528</span>  <span class="number">1.0000</span>  <span class="number">0.4677</span>  <span class="number">0.4900</span> <span class="number">-0.9001</span></span><br><span class="line">User3  <span class="number">0.7071</span>  <span class="number">0.4677</span>  <span class="number">1.0000</span> <span class="number">-0.1612</span> <span class="number">-0.4666</span></span><br><span class="line">User4  <span class="number">0.0000</span>  <span class="number">0.4900</span> <span class="number">-0.1612</span>  <span class="number">1.0000</span> <span class="number">-0.6415</span></span><br><span class="line">User5 <span class="number">-0.7921</span> <span class="number">-0.9001</span> <span class="number">-0.4666</span> <span class="number">-0.6415</span>  <span class="number">1.0000</span></span><br><span class="line">物品之间的两两相似度：</span><br><span class="line">        Item A  Item B  Item C  Item D  Item E</span><br><span class="line">Item A  <span class="number">1.0000</span> <span class="number">-0.4767</span> <span class="number">-0.1231</span>  <span class="number">0.5322</span>  <span class="number">0.9695</span></span><br><span class="line">Item B <span class="number">-0.4767</span>  <span class="number">1.0000</span>  <span class="number">0.6455</span> <span class="number">-0.3101</span> <span class="number">-0.4781</span></span><br><span class="line">Item C <span class="number">-0.1231</span>  <span class="number">0.6455</span>  <span class="number">1.0000</span> <span class="number">-0.7206</span> <span class="number">-0.4276</span></span><br><span class="line">Item D  <span class="number">0.5322</span> <span class="number">-0.3101</span> <span class="number">-0.7206</span>  <span class="number">1.0000</span>  <span class="number">0.5817</span></span><br><span class="line">Item E  <span class="number">0.9695</span> <span class="number">-0.4781</span> <span class="number">-0.4276</span>  <span class="number">0.5817</span>  <span class="number">1.0000</span></span><br></pre></td></tr></table></figure><p>可以看到与用户1最相似的是用户2和用户3；与物品A最相似的物品分别是物品E和物品D。</p><h5 id="基于用户的协同过滤算法（User-Based-CF）"><a href="#基于用户的协同过滤算法（User-Based-CF）" class="headerlink" title="基于用户的协同过滤算法（User-Based CF）"></a>基于用户的协同过滤算法（User-Based CF）</h5><p>该方案考虑了用户本身的评分评分以及近邻用户的加权平均相似度打分来进行预测：</p><script type="math/tex; mode=display">pred(u,i)=\hat{r}_{ui}=\cfrac{\sum_{v\in U}sim(u,v)*r_{vi}}{\sum_{v\in U}|sim(u,v)|}</script><p>我们要预测用户1对物品E的评分，那么可以根据与用户1最近邻的用户2和用户3进行预测，计算如下：</p><p>​ </p><script type="math/tex; mode=display">pred(u_1, i_5) =\cfrac{0.85*3+0.71*5}{0.85+0.71} = 3.91</script><p>最终预测出用户1对物品5的评分为3.91</p><h5 id="基于物品的协同过滤算法（Item-Based-CF）"><a href="#基于物品的协同过滤算法（Item-Based-CF）" class="headerlink" title="基于物品的协同过滤算法（Item-Based CF）"></a>基于物品的协同过滤算法（Item-Based CF）</h5><p>这里利用物品相似度预测的计算同上，同样考虑了用户自身的平均打分因素，结合预测物品与相似物品的加权平均相似度打分进行来进行预测</p><script type="math/tex; mode=display">pred(u,i)=\hat{r}_{ui}=\cfrac{\sum_{j\in I_{rated}}sim(i,j)*r_{uj}}{\sum_{j\in I_{rated}}sim(i,j)}</script><p>我们要预测用户1对物品E的评分，那么可以根据与物品E最近邻的物品A和物品D进行预测，计算如下：</p><script type="math/tex; mode=display">pred(u_1, i_5) = \cfrac {0.97*5+0.58*4}{0.97+0.58} = 4.63</script><p>对比可见，User-Based CF预测评分和Item-Based CF的评分结果也是存在差异的，因为严格意义上他们其实应当属于两种不同的推荐算法。</p><p>各自在不同的领域不同场景下，都会比另一种的效果更佳，但具体哪一种更佳，必须经过合理的效果评估。个人认为二者也可以加上各自的权重，类似与机器学习中的集成学习boosting。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>皮尔逊相关系数Pearson</p><ul><li>实际上也是一种余弦相似度, 不过先对向量做了中心化, 向量a b 各自减去向量的均值后, 再计算余弦相似度</li><li>皮尔逊相似度计算结果在-1,1之间 -1表示负相关, 1表示正相关</li><li>度量两个变量是不是同增同减</li><li>皮尔逊相关系数度量的是两个变量的变化趋势是否一致, <strong>不适合计算布尔值向量之间的相关度</strong></li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6fvut3zbaj30yy0cqn0z.jpg" alt="image-20190829010014701"></p><h3 id="参考-amp-致谢"><a href="#参考-amp-致谢" class="headerlink" title="参考&amp;致谢"></a>参考&amp;致谢</h3><blockquote><p>[1] 项亮. 推荐系统实践[M]. 2012.</p><p>佚名，黑马机器学习讲义</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推荐系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习-线性回归</title>
      <link href="/2019/08/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
      <url>/2019/08/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<blockquote><p>线性回归的理解。</p></blockquote><a id="more"></a><h4 id="一、线性回归"><a href="#一、线性回归" class="headerlink" title="一、线性回归"></a>一、线性回归</h4><blockquote><p>线性回归(Linear regression)是利用回归方程(函数)对一个或多个自变量(特征值)和因变量(目标值)之间关系进行建模的一种分析方式。</p><p>特点：只有一个自变量的情况称为单变量回归，多于一个自变量情况的叫做多元回归</p><p>表示方式</p></blockquote><script type="math/tex; mode=display">h(w) = w1x1 + w2x2 + w3x3 + ... + b     = w^Tx + b</script><p>也可以表述为h(x) = w^Tx</p><script type="math/tex; mode=display">w=\left[ \begin{matrix} b \\ w1 \\ w2 \end{matrix} \right],x=\left[ \begin{matrix} 1 \\ x1 \\ x2 \end{matrix} \right]</script><h4 id="二、线性回归的特征与目标的关系分析"><a href="#二、线性回归的特征与目标的关系分析" class="headerlink" title="二、线性回归的特征与目标的关系分析"></a>二、线性回归的特征与目标的关系分析</h4><ul><li><p>线性关系</p><blockquote><p>单特征与目标值的关系呈直线关系，或者两个特征与目标值呈现平面的关系</p></blockquote></li><li>非线性关系</li></ul><h4 id="三、线性回归的损失和优化"><a href="#三、线性回归的损失和优化" class="headerlink" title="三、线性回归的损失和优化"></a>三、线性回归的损失和优化</h4><h5 id="3-1-损失函数（最小二乘法）"><a href="#3-1-损失函数（最小二乘法）" class="headerlink" title="3.1 损失函数（最小二乘法）"></a>3.1 损失函数（最小二乘法）</h5><h5 id="3-2-优化算法"><a href="#3-2-优化算法" class="headerlink" title="3.2 优化算法"></a>3.2 优化算法</h5><p>线性回归经常使用的两种优化算法</p><ul><li>正规方程<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">W = (X^TX)^&#123;-1&#125;X^Ty</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>理解：X为特征值矩阵，y为目标值矩阵。直接求到最好的结果<br>缺点：当特征过多过复杂时，求解速度太慢并且得不到结果</p></blockquote><p>推导过程</p><ul><li>梯度下降法</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 线性回归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习-KNN算法</title>
      <link href="/2019/08/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-KNN%E7%AE%97%E6%B3%95/"/>
      <url>/2019/08/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-KNN%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>KNN算法的理解。</p></blockquote><a id="more"></a><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><blockquote><p>如果一个样本在特征空间中的k个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别，则该样本也属于这个类别。<br>本文采用欧式距离，即两点之间的直接距离。</p></blockquote><h4 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h4><blockquote><p>通过你的邻居，判断你是哪种类型</p></blockquote><h4 id="KNN算法流程总结"><a href="#KNN算法流程总结" class="headerlink" title="KNN算法流程总结"></a>KNN算法流程总结</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1）计算已知类别数据集中的点与当前点之间的距离</span><br><span class="line">2）按距离递增次序排序</span><br><span class="line">3）选取与当前点距离最小的k个点</span><br><span class="line">4）统计前k个点所在的类别出现的频率</span><br><span class="line">5）返回前k个点出现频率最高的类别作为当前点的预测分类</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"></span><br><span class="line"><span class="comment"># achieve data</span></span><br><span class="line">x = [[<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">3</span>],[<span class="number">-1</span>],[<span class="number">-4</span>]]</span><br><span class="line">y = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">estimator = KNeighborsClassifier(n_neighbors=<span class="number">3</span>)</span><br><span class="line">estimator.fit(x,y)</span><br><span class="line">result = estimator.predict([[<span class="number">-3</span>]])</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><pre><code>[-1]</code></pre><h4 id="问题一：距离选取"><a href="#问题一：距离选取" class="headerlink" title="问题一：距离选取"></a>问题一：距离选取</h4><p>1.距离公式，除了欧式距离，还有哪些距离公式可以使用？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">（1）欧式距离（两点距离问题）：两个点在空间中的距离。</span><br><span class="line">（2）曼哈顿距离（城市街区问题）：在曼哈顿街区要从一个十字路口开车到另一个十字路口，驾驶距离显然不是两点间的直线距离。这个实际驾驶距离就是“曼哈顿距离”。曼哈顿距离也称为“城市街区距离”(City Block distance)。</span><br><span class="line">    d(i,j)=|X1-X2|+|Y1-Y2|</span><br><span class="line">（3）切比雪夫距离 (Chebyshev Distance)：国际象棋中，国王可以直行、横行、斜行，所以国王走一步可以移动到相邻8个方格中的任意一个。国王从格子(x1,y1)走到格子(x2,y2)最少需要多少步？这个距离就叫切比雪夫距离。在公式里体现就是某个维度上的最大距离。</span><br><span class="line">（4）闵可夫斯基距离(Minkowski Distance)：闵氏距离不是一种距离，而是一组距离的定义，是对多个距离度量公式的概括性的表述。</span><br><span class="line">两个n维变量a(x11,x12,…,x1n)与b(x21,x22,…,x2n)间的闵可夫斯基距离定义为：</span><br><span class="line">其中p是一个变参数：</span><br><span class="line">当p=1时，就是曼哈顿距离；</span><br><span class="line">当p=2时，就是欧氏距离；</span><br><span class="line">当p→∞时，就是切比雪夫距离。</span><br><span class="line">根据p的不同，闵氏距离可以表示某一类/种的距离</span><br></pre></td></tr></table></figure><p>小结：</p><blockquote><p>1 闵氏距离，包括曼哈顿距离、欧氏距离和切比雪夫距离都存在明显的缺点:<br>e.g. 二维样本(身高[单位:cm],体重[单位:kg]),现有三个样本：a(180,50)，b(190,50)，c(180,60)。</p><p>a与b的闵氏距离（无论是曼哈顿距离、欧氏距离或切比雪夫距离）等于a与c的闵氏距离。但实际上身高的10cm并不能和体重的10kg划等号。</p></blockquote><p>闵氏距离的缺点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">​ (1)将各个分量的量纲(scale)，也就是“单位”相同的看待了;</span><br><span class="line">​ (2)未考虑各个分量的分布（期望，方差等）可能是不同的。</span><br></pre></td></tr></table></figure></p><h4 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">标准化欧氏距离 (Standardized EuclideanDistance)：标准化欧氏距离是针对欧氏距离的缺点而作的一种改进。</span><br><span class="line">思路：既然数据各维分量的分布不一样，那先将各个分量都“标准化”到均值、方差相等。</span><br></pre></td></tr></table></figure><h4 id="其他距离"><a href="#其他距离" class="headerlink" title="其他距离"></a>其他距离</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(1)余弦距离(Cosine Distance):</span><br><span class="line">几何中，夹角余弦可用来衡量两个向量方向的差异；机器学习中，借用这一概念来衡量样本向量之间的差异。</span><br><span class="line">(2)汉明距离(Hamming Distance):</span><br><span class="line">两个等长字符串s1与s2的汉明距离为：将其中一个变为另外一个所需要作的最小字符替换次数。</span><br><span class="line">(3)杰卡德距离(Jaccard Distance):</span><br><span class="line">杰卡德相似系数(Jaccard similarity coefficient)：两个集合A和B的交集元素在A，B的并集中所占的比例，称为两个集合的杰卡德相似系数，用符号J(A,B)。</span><br><span class="line">杰卡德距离(Jaccard Distance)：与杰卡德相似系数相反，用两个集合中不同元素占所有元素的比例来衡量两个集合的区分度</span><br><span class="line">（4）马氏距离(Mahalanobis Distance):马氏距离是由印度统计学家马哈拉诺比斯提出的，表示数据的协方差距离。它是一种有效的计算两个位置样本集的相似度的方法。马氏距离也可以定义为两个服从同一分布并且其协方差矩阵为∑的随机变量的差异程度：如果协方差矩阵为单位矩阵，马氏距离就简化为欧式距离；如果协方差矩阵为对角矩阵，则其也可称为正规化的欧式距离。</span><br><span class="line">马氏距离特性：</span><br><span class="line"></span><br><span class="line">    1.量纲无关，排除变量之间的相关性的干扰；</span><br><span class="line"></span><br><span class="line">    2.马氏距离的计算是建立在总体样本的基础上的，如果拿同样的两个样本，放入两个不同的总体中，最后计算得出的两个样本间的马氏距离通常是不相同的，除非这两个总体的协方差矩阵碰巧相同；</span><br><span class="line"></span><br><span class="line">    3 .计算马氏距离过程中，要求总体样本数大于样本的维数，否则得到的总体样本协方差矩阵逆矩阵不存在，这种情况下，用欧式距离计算即可。</span><br><span class="line"></span><br><span class="line">    4.还有一种情况，满足了条件总体样本数大于样本的维数，但是协方差矩阵的逆矩阵仍然不存在，比如三个样本点（3，4），（5，6），（7，8），这种情况是因为这三个样本在其所处的二维空间平面内共线。这种情况下，也采用欧式距离计算。</span><br></pre></td></tr></table></figure><h4 id="问题二：K值的选取"><a href="#问题二：K值的选取" class="headerlink" title="问题二：K值的选取"></a>问题二：K值的选取</h4><blockquote><p>2.选取K值的大小？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">K值过小：</span><br><span class="line">容易受到异常点的影响</span><br><span class="line">k值过大：</span><br><span class="line">受到样本均衡的问题</span><br></pre></td></tr></table></figure></p></blockquote><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p>参考：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">K值选择问题，李航博士的一书「统计学习方法」上所说：</span><br><span class="line"></span><br><span class="line">1) 选择较小的K值，就相当于用较小的领域中的训练实例进行预测，“学习”近似误差会减小，只有与输入实例较近或相似的训练实例才会对预测结果起作用，与此同时带来的问题是“学习”的估计误差会增大，换句话说，K值的减小就意味着整体模型变得复杂，容易发生过拟合；</span><br><span class="line"></span><br><span class="line">2) 选择较大的K值，就相当于用较大领域中的训练实例进行预测，其优点是可以减少学习的估计误差，但缺点是学习的近似误差会增大。这时候，与输入实例较远（不相似的）训练实例也会对预测器作用，使预测发生错误，且K值的增大就意味着整体的模型变得简单。</span><br><span class="line"></span><br><span class="line">3) K=N（N为训练样本个数），则完全不足取，因为此时无论输入实例是什么，都只是简单的预测它属于在训练实例中最多的类，模型过于简单，忽略了训练实例中大量有用信息。</span><br></pre></td></tr></table></figure></p><p>在实际应用中，K值一般取一个比较小的数值，例如采用交叉验证法（简单来说，就是把训练数据在分成两组:训练集和验证集）来选择最优的K值。</p><h4 id="近似误差："><a href="#近似误差：" class="headerlink" title="近似误差："></a>近似误差：</h4><blockquote><p>对现有训练集的训练误差，关注训练集.</p><p>如果近似误差过小可能会出现过拟合的现象，对现有的训练集能有很好的预测，但是对未知的测试样本将会出现较大偏差的预测。</p><p>模型本身不是最接近最佳模型。</p><h4 id="估计误差："><a href="#估计误差：" class="headerlink" title="估计误差："></a>估计误差：</h4><p>理解为对测试集的测试误差，关注测试集。</p><p>估计误差小说明对未知数据的预测能力好。</p><p>模型本身最接近最佳模型。</p></blockquote><p>鸢尾花代码实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">1.获取数据集</span><br><span class="line">2，数据基本处理</span><br><span class="line">3. 特征工程</span><br><span class="line">4. 机器学习（模型训练）</span><br><span class="line">5. 模型评估</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">from sklearn.datasets import load_iris</span><br><span class="line">from sklearn.model_selection import train_test_split</span><br><span class="line">from sklearn.preprocessing import StandardScaler</span><br><span class="line">from sklearn.neighbors import KNeighborsClassifier</span><br><span class="line"></span><br><span class="line"># 1.获取数据集</span><br><span class="line">iris = load_iris()</span><br><span class="line"># 2，数据基本处理</span><br><span class="line"># 2.1 数据分割</span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(iris.data, iris.target, random_state=23, test_size=0.1)</span><br><span class="line"></span><br><span class="line"># 3. 特征工程</span><br><span class="line"># 3.1 实例化一个转化器</span><br><span class="line">transfer = StandardScaler()</span><br><span class="line"># 3.2 调用fit_transform方法</span><br><span class="line">x_train = transfer.fit_transform(x_train)</span><br><span class="line">x_test = transfer.fit_transform(x_test)</span><br><span class="line"></span><br><span class="line"># 4. 机器学习（模型训练）</span><br><span class="line"># 4.1 实例化一个估计器</span><br><span class="line">estimator = KNeighborsClassifier(n_neighbors=5)</span><br><span class="line"># 4.2 模型训练</span><br><span class="line">estimator.fit(x_train,y_train)</span><br><span class="line"># 5. 模型评估</span><br><span class="line"># 5.1 输出预测值</span><br><span class="line">y_pre = estimator.predict(x_test)</span><br><span class="line">print(&quot;预测值是：\n&quot;, y_pre)</span><br><span class="line"></span><br><span class="line"># 5.2 输出准确率</span><br><span class="line">ret = estimator.score(x_test, y_test)</span><br><span class="line">print(&quot;准确率：\n&quot;, ret)</span><br></pre></td></tr></table></figure><h4 id="KNN-算法总结"><a href="#KNN-算法总结" class="headerlink" title="KNN 算法总结"></a>KNN 算法总结</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li>简单有效</li><li>重新训练代价低</li><li>适合类域交叉样本：KNN方法主要靠周围有限的邻近的样本,而不是靠判别类域的方法来确定所属类别的，因此对于类域的交叉或重叠较多的待分样本集来说，KNN方法较其他方法更为适合。</li><li>该算法比较适用于样本容量比较大的类域的自动分类，而那些样本容量较小的类域采用这种算法比较容易产生误分。</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>惰性算法</li><li>类别评分不是规格化</li><li>对不均衡的样本不擅长<br>当样本不平衡时，如一个类的样本容量很大，而其他类样本容量很小时，有可能导致当输入一个新样本时，该样本的K个邻居中大容量类的样本占多数。该算法只计算“最近的”邻居样本，某一类的样本数量很大，那么或者这类样本并不接近目标样本，或者这类样本很靠近目标样本。无论怎样，数量并不能影响运行结果。可以采用权值的方法（和该样本距离小的邻居权值大）来改进。</li><li>计算量较大<br>目前常用的解决方法是事先对已知样本点进行剪辑，事先去除对分类作用不大的样本。</li></ul><h4 id="【引入】交叉验证-amp-网格搜索"><a href="#【引入】交叉验证-amp-网格搜索" class="headerlink" title="【引入】交叉验证&amp;网格搜索"></a>【引入】交叉验证&amp;网格搜索</h4><h5 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h5><blockquote><p>交叉验证：将拿到的训练数据，分为训练和验证集。以下图为例：将数据分成4份，其中一份作为验证集。然后经过4次(组)的测试，每次都更换不同的验证集。即得到4组模型的结果，取平均值作为最终结果。又称4折交叉验证。</p><p>目的：为了让被评估的模型更加准确可信<br>为了让从训练得到模型结果更加准确。做以下处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">训练集：训练集+验证集</span><br><span class="line">测试集：测试集</span><br></pre></td></tr></table></figure></p></blockquote><p><img src="https://note.youdao.com/yws/api/personal/file/WEB4184dca878d04a0887b7286c1ba9d436?method=download&amp;shareKey=d3720ab97a07c17977664b620b96bdb2" alt="avater"></p><h5 id="网格搜索"><a href="#网格搜索" class="headerlink" title="网格搜索"></a>网格搜索</h5><blockquote><p>通常情况下，有很多参数是需要手动指定的（如k-近邻算法中的K值），这种叫超参数。但是手动过程繁杂，所以需要对模型预设几种超参数组合。每组超参数都采用交叉验证来进行评估。最后选出最优参数组合建立模型。</p></blockquote><p><img src="https://note.youdao.com/yws/api/personal/file/WEB436486d4788779c3049d73bd9e2ce313?method=download&amp;shareKey=371f904a95da7c413cf190d19f3cd6ac" alt="atater"></p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sklearn.model_selection.GridSearchCV(estimator, param_grid=None,cv=None)</span><br><span class="line">estimator -- 选择了哪个训练模型</span><br><span class="line">param_grid -- 需要传递的超参数</span><br><span class="line">cv -- 几折交叉验证</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">1.获取数据集</span><br><span class="line">2，数据基本处理</span><br><span class="line">3. 特征工程</span><br><span class="line">4. 机器学习（模型训练）</span><br><span class="line">5. 模型评估</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">from sklearn.datasets import load_iris</span><br><span class="line">from sklearn.model_selection import train_test_split, GridSearchCV</span><br><span class="line">from sklearn.preprocessing import StandardScaler</span><br><span class="line">from sklearn.neighbors import KNeighborsClassifier</span><br><span class="line"></span><br><span class="line"># 1.获取数据集</span><br><span class="line">iris = load_iris()</span><br><span class="line"># 2，数据基本处理</span><br><span class="line"># 2.1 数据分割</span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(iris.data, iris.target, test_size=0.2)</span><br><span class="line"></span><br><span class="line"># 3. 特征工程</span><br><span class="line"># 3.1 实例化一个转化器</span><br><span class="line">transfer = StandardScaler()</span><br><span class="line"># 3.2 调用fit_transform方法</span><br><span class="line">x_train = transfer.fit_transform(x_train)</span><br><span class="line">x_test = transfer.fit_transform(x_test)</span><br><span class="line"></span><br><span class="line"># 4. 机器学习（模型训练）</span><br><span class="line"># 4.1 实例化一个估计器</span><br><span class="line">estimator = KNeighborsClassifier(n_neighbors=1)</span><br><span class="line"></span><br><span class="line"># 4.2 调用交叉验证网格搜索模型</span><br><span class="line">param_grid = &#123;&quot;n_neighbors&quot;: [1, 3, 5, 7, 9]&#125;</span><br><span class="line">estimator = GridSearchCV(estimator, param_grid=param_grid, cv=10, n_jobs=4)</span><br><span class="line"></span><br><span class="line"># 4.3 模型训练</span><br><span class="line">estimator.fit(x_train, y_train)</span><br><span class="line"># 5. 模型评估</span><br><span class="line"># 5.1 输出预测值</span><br><span class="line">y_pre = estimator.predict(x_test)</span><br><span class="line">print(&quot;预测值是：\n&quot;, y_pre)</span><br><span class="line"></span><br><span class="line"># 5.2 输出准确率</span><br><span class="line">ret = estimator.score(x_test, y_test)</span><br><span class="line">print(&quot;准确率：\n&quot;, ret)</span><br><span class="line"></span><br><span class="line"># 5.3 其他平均指标</span><br><span class="line">print(&quot;最好的模型:\n&quot;, estimator.best_estimator_)</span><br><span class="line">print(&quot;最好的结果:\n&quot;, estimator.best_score_)</span><br><span class="line">print(&quot;整体模型结果:\n&quot;, estimator.cv_results_)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> Numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习实践Numpy【3】矩阵</title>
      <link href="/2019/08/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Numpy%E3%80%903%E3%80%91%E7%9F%A9%E9%98%B5/"/>
      <url>/2019/08/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Numpy%E3%80%903%E3%80%91%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>复习了Python的基础语法，开始使用Numpy进行数据操作，同时使用JuPyter notebook 实践、记录。</p></blockquote><a id="more"></a><h3 id="矩阵与数组"><a href="#矩阵与数组" class="headerlink" title="矩阵与数组"></a>矩阵与数组</h3><h4 id="一、矩阵"><a href="#一、矩阵" class="headerlink" title="一、矩阵"></a>一、矩阵</h4><h5 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1. 矩阵加减</span><br><span class="line">- 对应位置+-</span><br><span class="line">2. 矩阵乘</span><br><span class="line">- 标量*矩阵：标量和矩阵每个位置相乘</span><br><span class="line">- 矩阵*矩阵：[M行，N列]*[N行，L列] = [M行，L列]</span><br><span class="line">- 满足结合律，不满足交换律</span><br><span class="line">3. 单位矩阵</span><br><span class="line">- 对角线为1，其他位置为0</span><br><span class="line">3. 矩阵的逆</span><br><span class="line">- 矩阵A * 矩阵B = 单位矩阵，则A与B互为逆矩阵</span><br><span class="line">- 参考链接：https://jingyan.baidu.com/article/1709ad8095e1924634c4f03a.html</span><br><span class="line">5. 矩阵转置</span><br><span class="line">- 行列互换</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">90</span>,<span class="number">80</span>],[<span class="number">90</span>,<span class="number">88</span>],[<span class="number">70</span>,<span class="number">98</span>]])</span><br><span class="line">a</span><br></pre></td></tr></table></figure><pre><code>array([[90, 80],       [90, 88],       [70, 98]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b = np.array([[<span class="number">0.3</span>],[<span class="number">0.7</span>]])</span><br><span class="line">np.matmul(a,b) <span class="comment"># 仅能矩阵*矩阵</span></span><br><span class="line">np.dot(a,b) <span class="comment"># 能矩阵*矩阵；能矩阵*数</span></span><br></pre></td></tr></table></figure><pre><code>array([[83. ],       [88.6],       [89.6]])</code></pre><h4 id="二、数组"><a href="#二、数组" class="headerlink" title="二、数组"></a>二、数组</h4><h5 id="数组运算"><a href="#数组运算" class="headerlink" title="数组运算"></a>数组运算</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 数组与数运算(直接运算)</span><br><span class="line">2. 数组与数组运算（满足广播机制）</span><br><span class="line">- numpy会比较数组的shape，满足以下情况，数组才能进行运算</span><br><span class="line">    - 维度相等</span><br><span class="line">    - shape（其中相对应的一个地方为1）</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">arr = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">arr</span><br></pre></td></tr></table></figure><pre><code>array([1, 2, 3, 4])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>*arr <span class="comment"># 乘</span></span><br></pre></td></tr></table></figure><pre><code>array([2, 4, 6, 8])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>*arr + <span class="number">1</span> <span class="comment"># 加</span></span><br></pre></td></tr></table></figure><pre><code>array([3, 5, 7, 9])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">2</span>*arr + <span class="number">1</span>)/<span class="number">2</span> <span class="comment"># 除以</span></span><br></pre></td></tr></table></figure><pre><code>array([1.5, 2.5, 3.5, 4.5])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr1 = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]])</span><br><span class="line">arr2 = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]])</span><br><span class="line">arr1+arr2</span><br></pre></td></tr></table></figure><pre><code>array([[2, 4, 6],       [2, 4, 6]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> Numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习实践Numpy【2】np运算</title>
      <link href="/2019/08/14/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Numpy%E3%80%902%E3%80%91np%E8%BF%90%E7%AE%97/"/>
      <url>/2019/08/14/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Numpy%E3%80%902%E3%80%91np%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p>复习了Python的基础语法，开始使用Numpy进行数据操作，同时使用JuPyter notebook 实践、记录。</p></blockquote><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><h3 id="一、逻辑运算"><a href="#一、逻辑运算" class="headerlink" title="一、逻辑运算"></a>一、逻辑运算</h3><h4 id="1-1-基本判断"><a href="#1-1-基本判断" class="headerlink" title="1.1 基本判断"></a>1.1 基本判断</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 大于、小于可以直接进行判断</span><br><span class="line">2. 赋值：根据1的删选可以直接赋值 &gt; stock_front[stock_front &gt; 0.5] = 2 # 筛选&gt;0.5的值，设置成2</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stock_change = np.random.normal(<span class="number">0</span>,<span class="number">1</span>,(<span class="number">8</span>,<span class="number">10</span>))</span><br><span class="line">stock_change</span><br></pre></td></tr></table></figure><pre><code>array([[-0.75254896,  0.13800347, -1.82692041,  0.67962715, -0.95599639,        -0.01967562, -0.02826683, -1.19649466, -0.90110178, -1.77988564],       [ 0.10673182, -0.55881195, -0.14170679, -0.89750724, -0.46186144,        -0.29916581, -1.2683926 , -0.47452052,  2.03079179, -0.61752357],       [ 0.45919586,  0.22145301,  0.52497513, -0.60608082,  0.57323945,        -0.1365155 , -0.71665469,  0.09672215, -1.56701887,  1.77477174],       [ 0.99457294,  1.97057607, -1.40286495,  1.3425013 ,  2.00707248,        -0.90091719, -1.14843654, -1.14711919, -0.16398829, -0.59108646],       [ 1.26721256, -1.0386193 , -1.61032871, -0.81512405,  0.60494824,         1.69766176,  1.71788956,  1.47036844,  1.3739853 ,  0.87082525],       [-0.41096473,  2.96331414,  1.46354672, -0.94421902, -0.05690433,        -0.97004494, -1.59407176, -1.52980795, -0.4887531 , -0.51847338],       [-0.25098181, -0.85611159,  1.89772287, -0.57752288,  0.39839749,         1.06381376, -0.03351005,  1.58241277, -0.93007033,  0.62067707],       [ 0.80110324, -0.095168  , -2.26290159, -0.81397822, -0.71994656,        -0.68902653,  0.60960571,  0.47935453,  0.57727384, -1.34628842]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stock_front = stock_change[<span class="number">0</span>:<span class="number">5</span>,<span class="number">0</span>:<span class="number">5</span>]</span><br><span class="line">stock_front</span><br></pre></td></tr></table></figure><pre><code>array([[-0.75254896,  0.13800347, -1.82692041,  0.67962715, -0.95599639],       [ 0.10673182, -0.55881195, -0.14170679, -0.89750724, -0.46186144],       [ 0.45919586,  0.22145301,  0.52497513, -0.60608082,  0.57323945],       [ 0.99457294,  1.97057607, -1.40286495,  1.3425013 ,  2.00707248],       [ 1.26721256, -1.0386193 , -1.61032871, -0.81512405,  0.60494824]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stock_front &gt; <span class="number">0.5</span>  <span class="comment"># 判断</span></span><br></pre></td></tr></table></figure><pre><code>array([[False, False, False,  True, False],       [False, False, False, False, False],       [False, False,  True, False,  True],       [ True,  True, False,  True,  True],       [ True, False, False, False,  True]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stock_front[stock_front &gt; <span class="number">0.5</span>] = <span class="number">2</span> <span class="comment"># 筛选&gt;0.5的值，设置成2</span></span><br><span class="line">stock_front</span><br></pre></td></tr></table></figure><pre><code>array([[-0.75254896,  0.13800347, -1.82692041,  2.        , -0.95599639],       [ 0.10673182, -0.55881195, -0.14170679, -0.89750724, -0.46186144],       [ 0.45919586,  0.22145301,  2.        , -0.60608082,  2.        ],       [ 2.        ,  2.        , -1.40286495,  2.        ,  2.        ],       [ 2.        , -1.0386193 , -1.61032871, -0.81512405,  2.        ]])</code></pre><h4 id="1-2-通用判断函数"><a href="#1-2-通用判断函数" class="headerlink" title="1.2 通用判断函数"></a>1.2 通用判断函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. np.all()  #all 所有都满足要求，True</span><br><span class="line">2. np.any()  #any 只要有一个满足要求，True</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.all(stock_front&lt;=<span class="number">2</span>)  <span class="comment"># all 所有都满足要求，True 否则 False</span></span><br></pre></td></tr></table></figure><pre><code>True</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.any(stock_front&lt;=<span class="number">0.2</span>) <span class="comment"># any 只要有一个满足要求，True</span></span><br></pre></td></tr></table></figure><pre><code>True</code></pre><h4 id="1-3-三元运算符"><a href="#1-3-三元运算符" class="headerlink" title="1.3 三元运算符"></a>1.3 三元运算符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. np.where(condition, 值1, 值1) # condition为true，值1，否则 值2</span><br><span class="line">2. np.where(np.logical_and(stock_front&gt;0,stock_front&lt;1), 1, 0)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.where(stock_front&gt;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><pre><code>array([[0, 1, 0, 1, 0],       [1, 0, 0, 0, 0],       [1, 1, 1, 0, 1],       [1, 1, 0, 1, 1],       [1, 0, 0, 0, 1]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.where(np.logical_and(stock_front&gt;<span class="number">0</span>,stock_front&lt;<span class="number">1</span>), <span class="number">1</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><pre><code>array([[0, 1, 0, 0, 0],       [1, 0, 0, 0, 0],       [1, 1, 0, 0, 0],       [0, 0, 0, 0, 0],       [0, 0, 0, 0, 0]])</code></pre><h3 id="二、-统计运算"><a href="#二、-统计运算" class="headerlink" title="二、 统计运算"></a>二、 统计运算</h3><h4 id="2-1-统计指标"><a href="#2-1-统计指标" class="headerlink" title="2.1 统计指标"></a>2.1 统计指标</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">min()</span><br><span class="line">max()</span><br><span class="line">median()</span><br><span class="line">mean()</span><br><span class="line">std() # 标准差</span><br><span class="line">var() # 方差</span><br><span class="line">argmax() # 最大值的坐标</span><br><span class="line">argmin() # 最小值的坐标</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stock_front.max()</span><br></pre></td></tr></table></figure><pre><code>2.0</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stock_front.max(axis=<span class="number">1</span>) <span class="comment"># 0是列 1是行</span></span><br></pre></td></tr></table></figure><pre><code>array([2.        , 0.10673182, 2.        , 2.        , 2.        ])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stock_front.argmax() <span class="comment"># 最大值的坐标</span></span><br></pre></td></tr></table></figure><pre><code>3</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> Numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习实践Numpy【1】引入</title>
      <link href="/2019/08/14/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Numpy%E3%80%901%E3%80%91%E5%BC%95%E5%85%A5/"/>
      <url>/2019/08/14/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5Numpy%E3%80%901%E3%80%91%E5%BC%95%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>复习了Python的基础语法，开始使用Numpy进行数据操作，同时使用JuPyter notebook 实践、记录。</p></blockquote><a id="more"></a><h3 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 定义：开源的Python科学计算库，用于快速处理任意维度的数组。</span><br><span class="line">2. 存储对象： ndarray</span><br><span class="line">3. 创建：np.array([])</span><br><span class="line">4. 优势</span><br><span class="line">    - 内存块存储一体</span><br><span class="line">    - 支持并行运算，内部C实现，释放GIL（释放全局锁）</span><br></pre></td></tr></table></figure><h4 id="Numpy-N维数组-ndarray"><a href="#Numpy-N维数组-ndarray" class="headerlink" title="Numpy - N维数组 ndarray"></a>Numpy - N维数组 ndarray</h4><ol><li>属性&amp;形状&amp;类型<ul><li>shape</li><li>ndim</li><li>size</li><li>itemsize</li></ul></li></ol><h3 id="生成初始化数组"><a href="#生成初始化数组" class="headerlink" title="生成初始化数组"></a>生成初始化数组</h3><h4 id="普通"><a href="#普通" class="headerlink" title="普通"></a>普通</h4><h5 id="1-生成0和1的数组"><a href="#1-生成0和1的数组" class="headerlink" title="1.生成0和1的数组"></a>1.生成0和1的数组</h5><blockquote><p>np.ones([4,5])</p><p>np.zeros([3,3])</p></blockquote><h5 id="2-从现有数组中生成"><a href="#2-从现有数组中生成" class="headerlink" title="2.从现有数组中生成"></a>2.从现有数组中生成</h5><blockquote><p>np.array(one_array) # 深拷贝，全新一个实例</p><p>np.asarray(one_array) # 浅拷贝，指向原有</p></blockquote><h5 id="3-生成固定范围数组"><a href="#3-生成固定范围数组" class="headerlink" title="3.生成固定范围数组"></a>3.生成固定范围数组</h5><blockquote><p>np.linspace(0,10,5) # [0,10] 生成等间隔的5个item</p><p>np.arange(0,10,2) # [0,10] 生成以2为间隔生成</p></blockquote><h4 id="分布"><a href="#分布" class="headerlink" title="分布"></a>分布</h4><h5 id="1-均匀分布"><a href="#1-均匀分布" class="headerlink" title="1.均匀分布"></a>1.均匀分布</h5><blockquote><p>np.random.uniform(0,10,5) # 均匀分布（low，high，size）</p></blockquote><h5 id="2-正态分布"><a href="#2-正态分布" class="headerlink" title="2.正态分布"></a>2.正态分布</h5><blockquote><p>np.random.normal(0,10,20) # 正态分布（loc，标准差，size）</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">one_array = np.ones([<span class="number">4</span>,<span class="number">5</span>]) <span class="comment"># 按照参数维度，生成全1的数组</span></span><br><span class="line">np.ones_like(one_array)  <span class="comment"># 按照参数数组，生成全1的数组</span></span><br><span class="line">np.zeros([<span class="number">3</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure><pre><code>array([[0., 0., 0.],       [0., 0., 0.],       [0., 0., 0.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.array(one_array) <span class="comment"># 深拷贝，全新一个实例</span></span><br><span class="line">np.asarray(one_array) <span class="comment"># 浅拷贝，指向原有</span></span><br></pre></td></tr></table></figure><pre><code>array([[1., 1., 1., 1., 1.],       [1., 1., 1., 1., 1.],       [1., 1., 1., 1., 1.],       [1., 1., 1., 1., 1.]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.linspace(<span class="number">0</span>,<span class="number">10</span>,<span class="number">5</span>) <span class="comment"># [0,10] 生成等间隔的5个item</span></span><br><span class="line">np.arange(<span class="number">0</span>,<span class="number">10</span>,<span class="number">2</span>) <span class="comment"># [0,10] 生成以2为间隔生成</span></span><br></pre></td></tr></table></figure><pre><code>array([0, 2, 4, 6, 8])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.random.uniform(<span class="number">0</span>,<span class="number">10</span>,<span class="number">5</span>) <span class="comment"># 均匀分布</span></span><br></pre></td></tr></table></figure><pre><code>array([5.08178447, 4.02888709, 4.59175026, 6.21041799, 0.90498804])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.random.normal(<span class="number">0</span>,<span class="number">10</span>,<span class="number">20</span>) <span class="comment"># 正态分布</span></span><br></pre></td></tr></table></figure><pre><code>array([  5.67674523,   5.77575242,  -1.85493383,   7.33692221,        -0.05362885,   8.37029132,   7.95216801,  21.64118456,        14.00327488,  -0.52143642,  -4.40416346,  13.31843223,        -6.6974112 ,  19.52709879,  -6.95182398,  -0.90412052,       -11.02669012,   4.27056343,  18.97736721,  24.2468938 ])</code></pre><h3 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h3><h4 id="数组切片"><a href="#数组切片" class="headerlink" title="数组切片"></a>数组切片</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[行数，列数]  </span><br><span class="line">1. 先行后列，左闭右开</span><br><span class="line">2. 索引从外及里</span><br></pre></td></tr></table></figure><h4 id="数组类型修改"><a href="#数组类型修改" class="headerlink" title="数组类型修改"></a>数组类型修改</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象.astype()</span><br></pre></td></tr></table></figure><h4 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.unique(temp)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">stock_change = np.random.normal(<span class="number">0</span>, <span class="number">1</span>, (<span class="number">8</span>,<span class="number">10</span>))</span><br></pre></td></tr></table></figure><pre><code>array([[-0.21431481, -0.94781074,  0.72798452,  0.16755977, -0.21868384,        -0.76869999, -0.42344986,  1.88452471, -1.09014707,  0.04393599],       [ 0.1480258 , -0.83848401, -1.36803501, -1.41729986, -0.95472286,         1.59203922, -0.65986402,  0.03174573, -0.18274345, -1.44023589],       [ 1.22951175, -0.10736634,  0.0224487 , -0.76569652,  0.39459141,         2.11813401,  0.61387705, -1.19309158,  0.81355314,  0.56004444],       [-1.19703107, -1.02937508,  0.60327008,  0.18401519, -1.61605819,         0.65697408,  0.98575318,  1.78356349,  1.5498125 , -1.06082879],       [-1.93006799, -1.19670857,  1.35584068, -0.96465165, -0.42776941,        -2.45202067,  0.54192585,  1.05160372, -0.20648608, -1.46869715],       [-1.10488814,  0.75455409,  0.13580849,  0.10064928,  0.04829683,        -0.52473154, -0.30782629,  1.475804  , -0.93086951,  0.49169795],       [-1.52363283, -1.53559218, -0.32670834, -0.75836768, -0.47355597,         0.6849614 ,  0.32947873,  0.42595307,  0.86099386,  0.24105507],       [-1.34253205,  0.13808892, -0.3581911 ,  0.16412846, -0.01493121,        -0.78940982,  0.20047251, -0.69006736,  0.78435666,  0.05314826]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stock_change[<span class="number">0</span>:<span class="number">3</span>,<span class="number">0</span>:<span class="number">2</span>]</span><br></pre></td></tr></table></figure><pre><code>array([[-0.21431481, -0.94781074],       [ 0.1480258 , -0.83848401],       [ 1.22951175, -0.10736634]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stock_change[<span class="number">0</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><pre><code>-0.9478107415708911</code></pre><h3 id="数组矩阵形状修改"><a href="#数组矩阵形状修改" class="headerlink" title="数组矩阵形状修改"></a>数组矩阵形状修改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 数组.T # 行列互换</span><br><span class="line">2. 数组.reshape([行，列]) # 排成一行后，重新行列划分。不修改原有变量，如果传-1，代表以另一维度拆分。</span><br><span class="line">3. 数组.resize([行，列]) # 排成一行后，重新行列划分。修改原有变量</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stock_sharp_change = np.random.normal(<span class="number">0</span>,<span class="number">1</span>,(<span class="number">4</span>,<span class="number">5</span>))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stock_sharp_change</span><br></pre></td></tr></table></figure><pre><code>array([[-0.54011821,  1.68452432,  0.01165422,  0.92022483, -1.76956384],       [ 0.12076425,  0.48550684, -2.07158306,  0.11184936,  0.13483726],       [-1.08849942, -0.33872445,  0.19081035, -0.51772807, -0.05330802],       [ 1.72971777,  1.15105593, -0.70068092,  0.50980343,  2.6761524 ]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stock_sharp_change.reshape([<span class="number">5</span>,<span class="number">4</span>]) <span class="comment"># 排成一行后，重新行列划分。</span></span><br></pre></td></tr></table></figure><pre><code>array([[-0.54011821,  1.68452432,  0.01165422,  0.92022483],       [-1.76956384,  0.12076425,  0.48550684, -2.07158306],       [ 0.11184936,  0.13483726, -1.08849942, -0.33872445],       [ 0.19081035, -0.51772807, -0.05330802,  1.72971777],       [ 1.15105593, -0.70068092,  0.50980343,  2.6761524 ]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stock_sharp_change.reshape([<span class="number">-1</span>,<span class="number">2</span>]) <span class="comment"># 排成一行后，按照2列划分，行数待确定。</span></span><br></pre></td></tr></table></figure><pre><code>array([[-0.54011821,  1.68452432],       [ 0.01165422,  0.92022483],       [-1.76956384,  0.12076425],       [ 0.48550684, -2.07158306],       [ 0.11184936,  0.13483726],       [-1.08849942, -0.33872445],       [ 0.19081035, -0.51772807],       [-0.05330802,  1.72971777],       [ 1.15105593, -0.70068092],       [ 0.50980343,  2.6761524 ]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stock_sharp_change.resize([<span class="number">5</span>,<span class="number">4</span>]) <span class="comment"># 修改原有变量</span></span><br><span class="line">stock_sharp_change</span><br></pre></td></tr></table></figure><pre><code>array([[-0.54011821,  1.68452432,  0.01165422,  0.92022483],       [-1.76956384,  0.12076425,  0.48550684, -2.07158306],       [ 0.11184936,  0.13483726, -1.08849942, -0.33872445],       [ 0.19081035, -0.51772807, -0.05330802,  1.72971777],       [ 1.15105593, -0.70068092,  0.50980343,  2.6761524 ]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stock_sharp_change.T <span class="comment"># 矩阵转置，行列互换</span></span><br></pre></td></tr></table></figure><pre><code>array([[-0.54011821, -1.76956384,  0.11184936,  0.19081035,  1.15105593],       [ 1.68452432,  0.12076425,  0.13483726, -0.51772807, -0.70068092],       [ 0.01165422,  0.48550684, -1.08849942, -0.05330802,  0.50980343],       [ 0.92022483, -2.07158306, -0.33872445,  1.72971777,  2.6761524 ]])</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> Numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务能力输出小结</title>
      <link href="/2019/02/02/%E6%9C%8D%E5%8A%A1%E8%83%BD%E5%8A%9B%E8%BE%93%E5%87%BA%E5%B0%8F%E7%BB%93/"/>
      <url>/2019/02/02/%E6%9C%8D%E5%8A%A1%E8%83%BD%E5%8A%9B%E8%BE%93%E5%87%BA%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>近期没什么项目做，就做了一个小改进，因目前各个系统中有不少需要pdf转图片的功能。遂将将之提炼成一个服务。既然是服务，如何提供给使用方使用才比较好呢。这里单就如何提供服务做个小总结。</p></blockquote><a id="more"></a><h3 id="一、定位、明确应用场景"><a href="#一、定位、明确应用场景" class="headerlink" title="一、定位、明确应用场景"></a>一、定位、明确应用场景</h3><p>第一步明确自己所提供服务所要服务的场景，即该服务提供的范围，也就是自身定位。</p><blockquote><p>因为没有定位，就没有该服务所要提供能力的约束。<br>一方面，自己这个服务所要支持多大体量（qps等）,此处会直接影响后面的设计方案；<br>另一方面，通过定位划分领域边界，不属于该边界之内的应用方可以直接拒绝，从而避免服务的业务方过多过杂，最终吃力不讨好，还容易引起自己服务不支持的口舌之争。</p></blockquote><h3 id="二、引入的风险"><a href="#二、引入的风险" class="headerlink" title="二、引入的风险"></a>二、引入的风险</h3><p>采用自己的新服务产生的优点不必详谈。<br>重点说问题，引入该服务对原有系统的业务逻辑是否会产生影响？</p><p>明确该服务的应用场景，尤其是改动之后对原有逻辑产生的影响至关重要。<br>一般涉及如下两点：</p><ul><li>业务方面的影响，如果涉及用户体验方面的，需要同步产品、业务方；</li><li>服务稳定性的影响，如果使用该服务出现问题，最坏情况会对业务方产生多大影响；</li></ul><blockquote><p>对于正常逻辑，业务、开发都知道，但是异常情况，才是需要关注的重点。<br>先考虑风险，在设计时，才可以合理规避，且发生极端情况时，有容灾、兜底和人工干预的方案。</p></blockquote><h3 id="三、技术评估"><a href="#三、技术评估" class="headerlink" title="三、技术评估"></a>三、技术评估</h3><p>经历上述两轮的调研与思考后，才可以制定方案。<br>【题设】制定方案的时候，服务的能力是转换（文件转图片），其他应该由使用方实现，这样的话就需要预留扩展点，从而设计的不会太僵硬，满足对扩展开放。</p><h5 id="下面重点说说体验。"><a href="#下面重点说说体验。" class="headerlink" title="下面重点说说体验。"></a>下面重点说说体验。</h5><blockquote><p>为什么要说体验，因为经过一年的开发，可以明显感觉到：功能完成只能说是硬性指标，而使用的舒畅程度（用起来简不简单），才会影响对方对该功能的评价。</p></blockquote><p>好的体验自然是接入成本很低，如何达到较低的接入成本呢？</p><p>我后来整体上考虑，通过提供maven二方包的形式提供服务，减少使用方提供回调服务的配置过程（因为异步转换服务转换完成会有回调，回调需要让业务方暴露回调接口，业务方使用体验不佳）。</p><p>在二方包里会有HSF服务的发布过程，使用方如果需要回调，在引入bean使用的过程中实现回调接口方法即可，无需该感知回调接口如何发布。</p><p>同时利用模板方法的设计模式，在client二方包中增加扩展点（before&amp;after），增加使用方的扩展性。</p><h5 id="接下来，再说下示警。"><a href="#接下来，再说下示警。" class="headerlink" title="接下来，再说下示警。"></a>接下来，再说下示警。</h5><blockquote><p>  任何一个靠谱的服务都离不开示警</p></blockquote><p>示警可以在触发异常时，给开发者发送信息（邮件&amp;电话&amp;短信&amp;钉钉）。</p><p>示警信息里需要包含上下文环境，因为示警后，自然会面临排查、处理。一个好的示警信息，可以大大提高问题排查的效率。当然，对应异常的异常日志也是需要打印的。</p><blockquote><p>日志的作用，不只是记录，关键节点没有日志是一件非常头痛的事情。所以，我认为 日志之于系统，相当于黑匣子之于飞机。飞机出问题的时候，黑匣子的作用无与伦比。</p></blockquote><h5 id="最后，说说数据"><a href="#最后，说说数据" class="headerlink" title="最后，说说数据"></a>最后，说说数据</h5><p>Last but not least</p><p>一个服务，开发者应该可以说出rt时间，时间瓶颈花费在何处。</p><blockquote><p>因为之前在做导购的时候，很纠结于rt的时间。为了避免和别的团队的撕逼现象，用数据说话是最有力的方式。所以记录接口的rt时间、成功率也是比较重要的一个环节。同时，使用数据，对于使用方把控整个服务也具有指导性意义。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>级联更新-基于EventBus发布订阅的应用</title>
      <link href="/2019/01/09/%E7%BA%A7%E8%81%94%E6%9B%B4%E6%96%B0-%E5%9F%BA%E4%BA%8EEventBus%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2019/01/09/%E7%BA%A7%E8%81%94%E6%9B%B4%E6%96%B0-%E5%9F%BA%E4%BA%8EEventBus%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前段时间，小名同学review原有系统时，提出我们的系统应该引入用于级联更新的机制。说白了，就是发布订阅模式的应用。当时技术评估结论是暂时不需要，但是如果需要实现应该怎么实现呢？后来，我在阅读代码&amp;文档时，发现一个很好的模型可以用来实现上述逻辑。</p></blockquote><a id="more"></a><h4 id="先说说应用场景。"><a href="#先说说应用场景。" class="headerlink" title="先说说应用场景。"></a>先说说应用场景。</h4><p>在写应用系统时，经常会有这样的场景：</p><ol><li>更新订单时，需要将这样的变更通知到供应商&amp;商家&amp;卖家。</li><li>子类目发生变动时，让父类目感知，或者是父父类目感知。</li><li>某一事件触发发送不同类型的通知邮件。</li><li>规则变更产生的一系列级联的操作。</li></ol><p>…</p><h4 id="槽糕的实现"><a href="#槽糕的实现" class="headerlink" title="槽糕的实现"></a>槽糕的实现</h4><blockquote><p>如果说只是通知，采用同步&amp;异步调用的方式，也可以满足上述功能。</p></blockquote><p>弊端</p><ol><li>完全面向过程的思考方式，这样的写法会产生又长又软的面条式代码。</li><li>扩展性较差，调用的方式容易将代码写乱，同一类操作格式不统一（毕竟是多人并行开发）。而且如果是异步的话，在主流程里各自需要有起线程的代码。</li><li>耦合性强，“通知”这种类消息的做法，其步骤往往不应该在主流程主要步骤里。</li><li>可读性较差。</li></ol><h4 id="有没有什么可以避免上述弊端的解决方案呢？"><a href="#有没有什么可以避免上述弊端的解决方案呢？" class="headerlink" title="有没有什么可以避免上述弊端的解决方案呢？"></a>有没有什么可以避免上述弊端的解决方案呢？</h4><p>答案肯定是有的。</p><p>首先映入我脑海的就是设计模式中的发布-订阅模式，但是这样需要实现一整套代码逻辑，定义一堆类。虽然能实现，但是方便吗？no。</p><p>searching… let me see</p><p>EventBus -&gt; <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dyZWVucm9ib3QvRXZlbnRCdXM=" title="https://github.com/greenrobot/EventBus">https://github.com/greenrobot/EventBus<i class="fa fa-external-link"></i></span></p><blockquote><p>EventBus is a publish/subscribe event bus for Android and Java.</p></blockquote><p>简单、高效、体积小。<br>另外，<strong>事件总线EventBus的实现，从DDD的角度来说，</strong>以事件的弱引用方式对我们的模块和领域边界有很好的解耦作用。<em>**</em></p><p>科普：</p><blockquote><p>Publisher发布者：用于分发我们的Event事件，在EventBus中通过post方法进行分发传送。<br>Subscriber订阅者：用于接受我们的事件，我们在订阅事件中处理我们接收的数据。<br>Event事件：任何一个对象都可以作为事件，比如任何字符串，事件是发布者和订阅者之间的通信载体。<br>EventBus：类似于中转站，将我们的事件进行对应的分发处理。</p></blockquote><p>按照我的理解，示意图如下：<br><img src="https://cdn.nlark.com/yuque/0/2019/png/143212/1546912321007-34ba518c-91c0-4de3-9567-7ccb2aa15f3c.png#align=left&amp;display=inline&amp;height=163&amp;linkTarget=_blank&amp;name=image.png&amp;originHeight=191&amp;originWidth=464&amp;size=16142&amp;width=395" alt="image.png"></p><p>具体代码的简单实现</p><h4 id="EventBus-in-3-steps-copied-from-github"><a href="#EventBus-in-3-steps-copied-from-github" class="headerlink" title="EventBus in 3 steps( copied from github)"></a>EventBus in 3 steps( copied from github)</h4><p>1.Define events:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageEvent</span> </span>&#123; <span class="comment">/* Additional fields if needed */</span> &#125;</span><br></pre></td></tr></table></figure><p>2.Prepare subscribers: Declare and annotate your subscribing method, optionally specify a <span class="exturl" data-url="aHR0cDovL2dyZWVucm9ib3Qub3JnL2V2ZW50YnVzL2RvY3VtZW50YXRpb24vZGVsaXZlcnktdGhyZWFkcy10aHJlYWRtb2RlLw==" title="http://greenrobot.org/eventbus/documentation/delivery-threads-threadmode/">thread mode<i class="fa fa-external-link"></i></span>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Subscribe</span>(threadMode = ThreadMode.MAIN)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessageEvent</span><span class="params">(MessageEvent event)</span> </span>&#123;<span class="comment">/* Do something */</span>&#125;;</span><br></pre></td></tr></table></figure><p>Register and unregister your subscriber. For example on Android, activities and fragments should usually register according to their life cycle:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">super</span>.onStart();</span><br><span class="line">     EventBus.getDefault().register(<span class="keyword">this</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">super</span>.onStop();</span><br><span class="line">     EventBus.getDefault().unregister(<span class="keyword">this</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>3.Post events:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().post(<span class="keyword">new</span> MessageEvent())</span><br></pre></td></tr></table></figure><hr><p>具体进一步如何实现，可以参考官网：<br></p><h2 id="http-greenrobot-org-eventbus-documentation-how-to-get-started"><a href="#http-greenrobot-org-eventbus-documentation-how-to-get-started" class="headerlink" title="http://greenrobot.org/eventbus/documentation/how-to-get-started/"></a><span class="exturl" data-url="aHR0cDovL2dyZWVucm9ib3Qub3JnL2V2ZW50YnVzL2RvY3VtZW50YXRpb24vaG93LXRvLWdldC1zdGFydGVkLw==" title="http://greenrobot.org/eventbus/documentation/how-to-get-started/">http://greenrobot.org/eventbus/documentation/how-to-get-started/<i class="fa fa-external-link"></i></span></h2><p>from my point:</p><p>step1. 定义Event基础类（<strong>implements </strong>Serializable），在Event中定义EventBus。<strong>同时，定义成异步的事件总线 和 异常处理。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> EventBus TEST_BUS = <span class="keyword">new</span> AsyncEventBus(</span><br><span class="line">    <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>,<span class="number">20</span>,<span class="number">0L</span>,TimeUnit.MILLISECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(),<span class="keyword">new</span> NamedThreadFactory(<span class="string">"test"</span>)),</span><br><span class="line">    ((t, context)-&gt;&#123;&#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>step2. 定义用于传输的ConcreteEvent类。该类extends Event。有自己的属性信息。</p><p>step3. 定义订阅类</p><ol><li><p>在订阅类初始化的时候，Event.TEST_BUS.register(<strong>this</strong>);</p></li><li><p>在订阅类的方法上配置 @Subscribe</p></li><li><p>同时，配置@AllowConcurrentEvents，用于线程安全。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Subscribe</span><br><span class="line">@AllowConcurrentEvents</span><br><span class="line">public void testSubscribe(@NonNull ConcreteEvent event)&#123;</span><br><span class="line">// TODO 订阅方处理自己的逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="参考-amp-致谢"><a href="#参考-amp-致谢" class="headerlink" title="参考&amp;致谢"></a>参考&amp;致谢</h4><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dyZWVucm9ib3QvRXZlbnRCdXM=" title="https://github.com/greenrobot/EventBus">https://github.com/greenrobot/EventBus<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9mOWFlNTY5MWUxYmI=" title="https://www.jianshu.com/p/f9ae5691e1bb">https://www.jianshu.com/p/f9ae5691e1bb<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9jMzVmMGM1NDVmYzk=" title="https://www.jianshu.com/p/c35f0c545fc9">https://www.jianshu.com/p/c35f0c545fc9<i class="fa fa-external-link"></i></span></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 想法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事物的状态-状态模式</title>
      <link href="/2018/09/05/%E4%BA%8B%E7%89%A9%E7%9A%84%E7%8A%B6%E6%80%81-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/09/05/%E4%BA%8B%E7%89%A9%E7%9A%84%E7%8A%B6%E6%80%81-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前段时间看到有代码在用状态机，而这段时间重温软件设计模式，刚好有状态模式，记录一下。</p></blockquote><a id="more"></a><p>场景：</p><blockquote><p>对于一个自动售卖机的小系统，往往会有，投币、售出、售罄、退钱等状态。状态之间需要转换，才能完成一系列操作，实现某一个完整的功能。</p></blockquote><p>糟糕的解决方案</p><blockquote><p>旧的解决方案是怎样的呢？<br>首先，用常量定义出所有状态。<br>在进行操作时，用if判断当前状态是否是定义出来的某个状态，然后进行相应的操作。同时进行状态的切换。</p></blockquote><p>问题点：</p><blockquote><p>用上述方法解决的问题，会有如下痛点：</p><ol><li>扩展性极差，如果新增一个状态，需要变动原有逻辑代码，严重违反【对扩展开放】的原则。</li><li>随着时间流逝，主流程出现大量的if判断，导致某个方法过于庞大，不利于阅读维护。</li><li>完全是面向过程思维方式，不是面向对象的思考方式。</li></ol></blockquote><p>改良的解决方案</p><blockquote><p>切入点：<strong>将每个状态的行为放在对应的状态类中，每个状态只要实现自己的动作就可以了。</strong><br>思路：</p><ol><li>定义一个状态接口（or 抽象类）。每个动作在接口中都有对应的方法。</li><li>每个具体的状态实现状态接口，并负责自己当前状态下各个方法的实现，eg:售出状态的退钱方法，取东西方法等。</li><li>最后，主流程里将动作委托给对应的状态类。</li></ol></blockquote><p>类图如下</p><div id="0kwigz" data-type="puml" data-display="block" data-align="left" data-src="https://cdn.nlark.com/__puml/4fcbbb2937d1b0ea3d7cde1a9076c21d.svg" data-width="711" data-height="200" data-text="%40startuml%0A%0AInterface%20State%7B%0A%09%2Bhandle()%0A%7D%0A%0Aclass%20ConcreteStateA%7B%0A%09%2Bhandle()%0A%7D%0A%0Aclass%20ConcreteStateB%7B%0A%09%2Bhandle()%0A%7D%0A%0Aclass%20Context%7B%0A%09%2Brequest()%0A%7D%0A%0A%0AConcreteStateA%20..%7C%3E%20State%0AConcreteStateB%20..%7C%3E%20State%0AContext%20--%20State%0A%0Anote%20right%20of%20(Context)%0A%20%20Context%E6%98%AF%E4%B8%8A%E4%B8%8B%E6%96%87%E7%8E%AF%E5%A2%83.%0A%20%20%E5%BD%93%E8%B0%83%E7%94%A8request()%E6%97%B6%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%A7%94%E6%89%98%E7%BB%99state.handle()%0Aend%20note%0A%0A%40enduml"><img src="https://cdn.nlark.com/__puml/4fcbbb2937d1b0ea3d7cde1a9076c21d.svg" width="711"></div><div data-type="alignment" data-value="center" style="text-align:center">  <div data-type="p">图1 状态模式类图</div>  <div data-type="p"></div></div><p>如图1状态模式类图所示，State是定义状态动作的接口，ConcreteStateA与ConcreteStateB是接口State的具体状态。Context是上下文中进行调用，调用State.handle方法，用多态代替了if。</p><p>在具体使用过程中，ConcreteStateA与ConcreteStateB或其他状态可以相互转换，也可以在Context中转换。同时，当遇到拓展时，比如新增状态ConcreteStateC，只需要新增ConcreteStateC实现State接口，完成handle，并在Context里进行调用。</p>]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组合模式遇到迭代器（一）</title>
      <link href="/2018/08/05/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E9%81%87%E5%88%B0%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2018/08/05/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E9%81%87%E5%88%B0%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>引入：最近开发过程中，遇到场景组、场景嵌套的情况，看到代码中运用了组合模式。于是乎，温习了组合模式的应用场景和设计过程。同时，在组合模式运用的过程中，很自然地会出现遍历的情况，这时候迭代器模式就有用武之地。</p></blockquote><a id="more"></a><h4 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h4><p>为了更好地说明，我用一个生活中的case进行阐述。菜单和子菜单是生活中常见的名称。菜单包含子菜单和其他选项，子菜单里会有子子菜单和其他选项，依次类推，嵌套结构。<br>如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">文档菜单</span><br><span class="line">   - 新标签页</span><br><span class="line">   - 打开</span><br><span class="line">      - 通过链接打开</span><br><span class="line">      - 最近使用</span><br><span class="line">           - 按日期</span><br><span class="line">           - 使用记录</span><br><span class="line">   - 分享</span><br><span class="line">      - 钉钉分享</span><br><span class="line">      - Email分享</span><br><span class="line">      - 微信分享</span><br><span class="line">   - 关闭</span><br></pre></td></tr></table></figure></p><p>我们如何在系统中表达这种关系，同时让使用者（调用方）不需要理解其中的细节就可以直接处理其中的子菜单和其他选项呢？</p><hr><p>其实，这种情况就非常适合使用组合模式，<strong>组合模式允许系统将对象组合成树形结构来表现“整体|部分”的层次结构</strong>。优点是能让客户（使用者）以统一的方式处理其中的个别对象（其他选项）和对象组合（子菜单）。</p><h5 id="思路如下："><a href="#思路如下：" class="headerlink" title="思路如下："></a>思路如下：</h5><p>为了使“子菜单”和“其他选项”在形式上实现统一，我们需要定义一个统一的接口对外提供使用，同时规范“子菜单”与“其他选项”的具体实现。对于这个接口，我们希望有一些默认的实现，故而在这里使用抽象类作为这个“接口”。</p><div id="llagsa" data-type="puml" data-display="block" data-align="center" data-src="https://cdn.nlark.com/__puml/b6b371c8ef0ee3241f39a768b0b6fe60.svg" data-width="313" data-height="422" data-text="%40startuml%0A%0AClass%20BaseMenuComponent%20%7B%0A%20%20name%0A%20%20desc%0A%20%20%2BgetName()%0A%20%20%2BgetDesc()%0A%09%2Badd(BaseMenuComponent)%0A%09%2Bremove(BaseMenuComponent)%0A%09%2BgetChild(int)%0A%7D%0A%0AClass%20MenuItem%20%7B%0A%20%20%2BgetName()%0A%20%20%2BgetDesc()%0A%7D%0A%0AClass%20Menu%20%7B%0A%09baseMenuComponents%0A%09%2Badd(BaseMenuComponent)%0A%09%2Bremove(BaseMenuComponent)%0A%09%2BgetChile(int)%0A%7D%0A%0AClass%20MenuVisitor%20%7B%0A%09%0A%7D%0A%0ABaseMenuComponent%20%3C%7C--%20MenuItem%0ABaseMenuComponent%20%3C%7C--%20Menu%0AMenu%20--%3E%20BaseMenuComponent%0AMenuVisitor%20--%3E%20BaseMenuComponent%0A%0A%0A%40enduml"><img src="https://cdn.nlark.com/__puml/b6b371c8ef0ee3241f39a768b0b6fe60.svg" width="313"></div><div data-type="alignment" data-value="center" style="text-align:center">  <div data-type="p">图1 组合模式类图</div></div><p>如图1  组合模式类图所示，Menu代表子菜单，MenuItem代表其他选项，BaseMenuComponent是统一抽象类。MenuVisitor是使用者。Menu和MenuItem都继承了BaseMenuComponent，Menu同时也会使用List<basemenucomponent>用来维护层级关系。</basemenucomponent></p><h5 id="问题-amp-思考："><a href="#问题-amp-思考：" class="headerlink" title="问题&amp;思考："></a>问题&amp;思考：</h5><p>Q：<strong>我们都知道单一职责原则：一个类只有一个责任，但是，这么设计的情况下，一个类有两个职责了</strong>：1. 菜单的固有操作；2. 维护层级关系。这岂不是违反的单一职责原则了吗？<br>A：其实，组合模式就是用这种方式，以违反单一职责原则的方式换取透明性，List<basemenucomponent>里面的元素是“子菜单”还是“其他选项”对使用者来说是透明的。</basemenucomponent></p><p>Q:BaseMenuComponent同时具体两种类型的操作，包括“子菜单”和“其他选项”，<strong>这种情况下，“子菜单”中不就继承了自己不需要的“其他选项”里面的方法了吗</strong>？会造成冗余和数据不安全的问题。<br>A：没错，会产生上述问题。如果要解决上述问题，就需要将责任区分开来放在不同的接口。这么设计会比较安全，但也因此失去“透明性”。回到问题的初衷：让使用者（调用方）不需要理解其中的细节就可以直接处理其中的子菜单和其他选项。为了不让用户使用条件语句和instanceof操作处理不同类型的问题，所以采用了以上设计。换一种理解方式，可以把MenuItem看成没有子菜单的Menu。</p><h4 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h4><p>在软件系统中，有很多方式来表达集合的概念，比如：数组、堆栈等。但是如果调用方如何遍历集合中的对象，不应该需要访知道这些对象的具体实现。而是用通用的方式去遍历这些集合种的对象,所以遍历的这种操作应该被抽象出来。</p><p>为了解决遍历集合的问题，出现了迭代器模式。<br><strong>迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其中内部的表示</strong>。迭代器的突出优点是，将遍历元素的能力交给迭代器，而不是聚合对象，让聚合的接口更简洁。如图2 迭代器类图所示。</p><div id="g2ybzv" data-type="puml" data-display="block" data-align="center" data-src="https://cdn.nlark.com/__puml/ab998bb0480fda99250a92109542e380.svg" data-width="306" data-height="371" data-text="%40startuml%0A%0AInterface%20Aggregate%7B%0A%09%2BcreateIterator()%0A%7D%0A%0Aclass%20Client%7B%0A%09%0A%7D%0A%0AInterface%20Iterator%7B%0A%09%2BhasNext()%0A%09%2Bnext()%0A%09%2Bremove()%0A%7D%0A%0Aclass%20ConcreteIterator%7B%0A%09%2BhasNext()%0A%09%2Bnext()%0A%09%2Bremove()%0A%7D%0A%0Aclass%20ConcreteAggregate%7B%0A%09%2BcreateIterator()%0A%7D%0A%0A%0AConcreteIterator%20..%7C%3E%20Iterator%0AConcreteAggregate%20--%3E%20ConcreteIterator%0AConcreteAggregate%20..%7C%3E%20Aggregate%0AClient%20--%3E%20Iterator%0AClient%20--%3E%20Aggregate%0A%0A%40enduml"><img src="https://cdn.nlark.com/__puml/ab998bb0480fda99250a92109542e380.svg" width="306"></div><div data-type="alignment" data-value="center" style="text-align:center">  <div data-type="p">图2 迭代器模式类图</div></div><p>如图2所示，迭代器模式中, Aggregate是供所有具体ConcreteAggregate类实现的接口，使用户Client不再依赖于具体的ConcreteAggregate实现。Aggregate中创建Iterator进行遍历访问。<br>调用代码实例如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator iterator = aggregate.createIterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    Item item = iterator.next();</span><br><span class="line">    <span class="comment">// 以下可以进一步操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新的阶段-这仨月</title>
      <link href="/2018/07/10/%E6%96%B0%E9%98%B6%E6%AE%B5-%E8%BF%99%E4%BB%A8%E6%9C%88/"/>
      <url>/2018/07/10/%E6%96%B0%E9%98%B6%E6%AE%B5-%E8%BF%99%E4%BB%A8%E6%9C%88/</url>
      
        <content type="html"><![CDATA[<blockquote><p>2018.4.9日以正式员工的身份参加工作，转眼间，三个月过去了。这段时间从杭州-合肥-杭州奔走，也是我人生中从学校到职场社会的一个转折点。就像十九年前父亲把我送入学前班一样。</p></blockquote><a id="more"></a><h4 id="一、毕业"><a href="#一、毕业" class="headerlink" title="一、毕业"></a>一、毕业</h4><p>每次毕业都离不开拍照、聚餐和道别。既有对原来时光的不舍，也有对未来日子的憧憬。好在之前有过实习的经验，对入职、工作的流程也是轻车熟路。每个阶段都会有一群人陪你一同走过，而我是个极其恋旧的人，往往不舍会更多一些。曾经人声鼎沸的同学微信群渐渐归于平淡，偶尔出现的零星消息大都是“点赞”、“招实习”之类的消息，难免乏味。之前一起嘻嘻哈哈的哥们儿都分散在不同的城市，北京居多、上海次之，基本上都是互联网研发岗，工作繁忙，联系渐渐少了很多。纵然有再多的不舍，也只能安慰自己分离是相聚的开始。在百阿培训的教室里，有着一句话，叫做“聚是一团火，散是满天星”，感觉很是贴切。希望每位同学都能在自己的岗位、领域燃烧青春，实现价值。</p><h4 id="二、工作"><a href="#二、工作" class="headerlink" title="二、工作"></a>二、工作</h4><p>我从来没有只是把一份工作简单地当作一个赚钱的行为，还是用学生的心态去看待工作。把手里的工作当成学习的一个过程，每一天都有自己的思考与沉淀。阅读前人写过的代码，同时也回顾自己写完的代码。不得不说，我自己看自己一个月前的代码，都不禁有点汗颜，毫无设计感。希望自己能够把握好工作的节奏，可以聪明、乐观、皮实、自省。不久前，在百阿培训上认识一伙人，他们有和我一样的应届毕业生，也有工作多年的行业大佬，无论怎样，交谈起来都很顺畅。两周时间，他们身上很多闪光点感染着我，给了我很多的启迪。每每想到这，都会感觉一定要出去看看这个世界和这个世界上有趣的人，有不少人我很佩服，希望几年后，我也能像他们一样。</p><p>当然，加班很多。有几次下班都第二天了，我自己骑着自行车在回家的路上，天空泛白。</p><h4 id="三、杭州的日子"><a href="#三、杭州的日子" class="headerlink" title="三、杭州的日子"></a>三、杭州的日子</h4><p>杭州的日子对于我来说，平平淡淡。每天按时上班，不按时下班，到家一般都比较晚了。天气炎热，时常回家路上买上半个冰西瓜，虽然吃不完，但是喜欢用勺子挖的感觉。回到出租屋，带上耳机，会听听“百词斩”英语广播剧，大概是听力一直是我的一个弱项，而且公司的“歪果仁”越来越多了，不得不防啊。</p><p>周末或者周五晚上，通常会跑跑步，做几个卧推，然后回去冲个澡，躺在床上看一部感觉不错的科幻电影。有时会翻翻书，整理一下。因为公司内部有技术论坛，也会去逛上一逛。日子慢慢趋于稳定和平淡，偶尔去市里同学家蹭顿说不上好吃还是难吃的饭，大概只是图个热闹，聊聊天。</p><p>就这样，不喜不悲。</p><h4 id="四、未来"><a href="#四、未来" class="headerlink" title="四、未来"></a>四、未来</h4><p>写到这里，听到窗外又下起了雨，配合轰轰空调运转的声音，很有夏天的感觉。关于未来，我想过很多，也有所规划。下笔时，顿了一下，写太多也没有作用，还是慢慢付诸实践，希望自己会更好。</p><p><span class="exturl" data-url="aHR0cDovL2FtbWdnLmNvbS9pbWFnZS9sODRF" title="http://ammgg.com/image/l84E"><img src="http://ammgg.com/images/2018/07/10/l84E.md.jpg" alt="future"><i class="fa fa-external-link"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java线程池的技巧及应用小结</title>
      <link href="/2018/07/05/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%8A%80%E5%B7%A7%E5%8F%8A%E5%BA%94%E7%94%A8%E5%B0%8F%E7%BB%93/"/>
      <url>/2018/07/05/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%8A%80%E5%B7%A7%E5%8F%8A%E5%BA%94%E7%94%A8%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>近来重温了一些Java方面关于线程池使用的书籍及使用场景，使用后感觉有必要整理归纳一下。</p></blockquote><a id="more"></a><blockquote><p>引入：我们使用线程的时候就去创建一个线程，这样实现起来非常简便。但是会有一个问题：如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p><h5 id="一、基础且必须知道的"><a href="#一、基础且必须知道的" class="headerlink" title="一、基础且必须知道的"></a>一、基础且必须知道的</h5></blockquote><p>线程池主要是围绕着java.util.concurrent.ThreadPoolExecutor展开的，如果要透彻地了解Java中的线程池，必须先了解这个类。</p><p>ThreadPoolExecutor继承自AbstractExecutorService类，并提供了四个构造器。但是，仔细观察每个构造器的源码具体实现，发现前面三个构造器其实是调用的第四个构造器进行的初始化工作。</p><p>那我们直接看第四个构造器的具体功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">undefined</span><br><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          ThreadFactory threadFactory,</span><br><span class="line">                          RejectedExecutionHandler handler) ;</span><br></pre></td></tr></table></figure><p>这个构造器的功能自然是创建一个线程池（Creates a new {@code ThreadPoolExecutor} with the given initial parameters）</p><ol><li>具体参数的含义如下：</li></ol><ul><li>corePoolSize:<br>  the number of threads to keep in the pool，即常驻在线程池中的线程数目。在创建了线程池后，<strong>默认情况下，线程池中并没有任何线程</strong>，而是等待有任务到来才创建线程去执行任务。当然也可以使用”预热”的方法：prestartCoreThread() 和 prestartAllCoreThreads()，前者是启动corePoolSize个线程，后者是启动一个线程。当有任务来之后，就会创建一个线程去执行任务，<strong>当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中</strong>。</li><li>maximumPoolSize<br>  表示在线程池中最多能创建多少个线程。</li><li>keepAliveTime<br>  表示线程没有任务执行时最多保持多久时间会终止。</li><li>unit<br>  参数keepAliveTime对应的时间单位，即TimeUnit类中有7种静态属性，eg:TimeUnit.SECONDS</li><li>workQueue<br>  阻塞队列，用来存储等待执行的任务。该参数的选择会对线程池运行过程产生重大影响。具体影响在下文谈到。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">一般有：ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue</span><br></pre></td></tr></table></figure><ul><li>threadFactory<br>  线程工厂，主要用来创建线程。</li><li>handler：表示当拒绝处理任务时的策略，有以下四种取值，具体有什么不同也会在下文详细描述。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 </span><br><span class="line">ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 </span><br><span class="line">ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</span><br><span class="line">ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</span><br></pre></td></tr></table></figure><ol><li>在组织结构上</li></ol><p>ThreadPoolExecutor类继承自AbstractExecutorService，AbstractExecutorService实现了ExecutorService接口，ExecutorService接口又继承自Executor接口。<br>顶层接口：Executor，只有execute()方法，用来定义执行任务的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br></pre></td></tr></table></figure></p><p>二级接口：ExecutorService，定义了 shutdown()、submit()、invokeAll()等主要方法。<br>三级实现类：AbstractExecutorService，实现了ExecutorService接口中的方法。<br>四级实现类：ThreadPoolExecutor进一步扩展功能，主要实现了execute()方法。同时多了些状态获取，控制的方法。并且，定义了四种拒绝处理任务时的策略。</p><ol><li>execute()方法 VS submit()方法</li></ol><p>execute()方法在Executor中声明，在ThreadPoolExecutor进行实现，通过这个方法可以向线程池提交一个任务，交由线程池去执行。没有返回值。</p><p>​        submit()方法中调用了execute()方法，只是在返回值方面，使用了Future<span data-type="color" style="color:inherit">&lt;T&gt;</span></p><ol><li>整体的运行过程<strong>（重要！）</strong></li></ol><ul><li>如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；</li><li>如果当前线程池中的线程数目&gt;=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；<strong>若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务；</strong></li><li>如果当前线程池中的线程数目达到maximumPoolSize，则会<strong>采取任务拒绝策略</strong>进行处理；</li><li>如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止。</li></ul><p>二、<strong>任务缓存队列及排队策略</strong></p><ol><li>使用直接提交策略，即<strong>SynchronousQueue</strong>。</li></ol><p>SynchronousQueue是无界的，也就是说他存数任务的能力是没有限制的，但是由于该Queue本身的特性，<strong>在某次添加元素后必须等待其他线程取走后才能继续添加</strong>。</p><ol><li>使用无界队列策略，即<strong>LinkedBlockingQueue</strong>。</li></ol><p>在达到corePoolSize线程数目之后，<strong>因为是无界，所以任务总是可以加入队列的，因而永远也不会触发产生新的线程！</strong>corePoolSize大小的线程数会一直运行，忙完当前的，就从队列中拿任务开始运行。<strong>如果当前线程数处理不过来，队列会出现OOM，内存溢出！</strong></p><ol><li>有界队列，使用<strong>ArrayBlockingQueue</strong>。</li></ol><p>顾名思义，因为有界，达到corePoolSize线程数目之后，可以创建新的线程。并且，线程数目达到maximumPoolSize，之后采用拒绝策略。故而可以防止资源耗尽的情况发生。</p><p>三、<strong>拒绝策略</strong></p><p>在ThreadPoolExecutor中定义。</p><p>四种策略</p><p>​    1、AbortPolicy 丢弃任务并抛出RejectedExecutionException异常（常用）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2、DiscardPolicy 丢弃当前将要加入队列的任务本身，无异常抛出。</span><br></pre></td></tr></table></figure></p><p>​    3、DiscardOldestPolicy 丢弃任务队列中最旧任务，随后重新尝试执行任务。</p><p>​    4、CallerRunsPolicy 不进入线程池执行，任务将有调用者线程去执行。</p><h5 id="四、常见应用场景"><a href="#四、常见应用场景" class="headerlink" title="四、常见应用场景"></a>四、常见应用场景</h5><p>场景</p><blockquote><p>描述: 前端一次请求要求3s内返回结果，否则走打底逻辑。很多情况下前端需要的数据是由多个数据源的数据组成，且彼此间没有依赖关系。<br>解决思路<br>如果这些数据采用串行获取，大概率出现超时，所以对于没有依赖关系的数据，则可以并发执行访问。<br>具体执行时，可以采用，传递response引用的方式，多个数据源实例向response中放值。<br>main-idea：将所有submit线程的对应future，放入公共的list中，然后对该list的每个future进行get获取结果&amp;设置超时时间。<br>具体步骤</p></blockquote><h6 id="第一步-规范数据源访问"><a href="#第一步-规范数据源访问" class="headerlink" title="第一步  规范数据源访问"></a>第一步  规范数据源访问</h6><p>定义接口： BaseBuilder<r, s>，同时定义具体方法 build方法：build(R request, S response);</r,></p><p>数据源访问的类 用类ABuilder、BBuilder和CBuilder表示。</p><p>在本次请求中，所有需要访问数据源的类ABuilder、BBuilder和CBuilder都需要实现BaseBuilder接口和build方法。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ABuilder</span> <span class="keyword">implements</span> <span class="title">BaseBuilder</span>&lt;<span class="title">Request</span>, <span class="title">Response</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(Request request, Response response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取A数据源的数据</span></span><br><span class="line">            A aResult = aservice.getA(request);</span><br><span class="line">            response.setA(aResult);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="comment">// 异常处理</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 统计信息</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="第二步-定义线程池信息"><a href="#第二步-定义线程池信息" class="headerlink" title="第二步  定义线程池信息"></a>第二步  定义线程池信息</h6><p>定义类 BaseThreadPoolExecutor<r, s></r,></p><p>定义成员变量：线程池exec</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ExecutorService exec = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">32</span>, <span class="number">128</span>, <span class="number">200</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(), <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br></pre></td></tr></table></figure><p>定义新增线程的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPool</span><span class="params">(List&lt;Future&gt; futureList,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">final</span> BaseBuilder&lt;R, S&gt; baseBuild, <span class="keyword">final</span> R r, <span class="keyword">final</span> S s)</span> </span>&#123;</span><br><span class="line">​</span><br><span class="line">        Future&lt;Void&gt; future = exec.submit(<span class="keyword">new</span> Callable&lt;Void&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Void <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                baseBuild.build(r, s);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        futureList.add(future);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取数据源结果的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 获取Future结果</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> futureList</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> expireTime 总超时时间 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getFutureList</span><span class="params">(List&lt;Future&gt; futureList, <span class="keyword">long</span> expireTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Future ft : futureList) &#123;</span><br><span class="line">            Long start = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ft.get(expireTime, TimeUnit.MILLISECONDS); <span class="comment">//阻塞，线程等待时间</span></span><br><span class="line">                Long timeUse = System.nanoTime() - start;</span><br><span class="line">                expireTime = expireTime - timeUse;</span><br><span class="line">                <span class="keyword">if</span> (expireTime &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> XXXException(<span class="string">"time out"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                ft.cancel(<span class="keyword">false</span>);</span><br><span class="line">                LoggerUtils.error(logger, e, <span class="string">""</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="第三步-调用"><a href="#第三步-调用" class="headerlink" title="第三步 调用"></a>第三步 调用</h6><p>实例化BaseThreadPoolExecutor，并注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> BaseThreadPoolExecutor&lt;Request, Response&gt; baseThreadPoolExecutor; <span class="comment">//成员变量</span></span><br></pre></td></tr></table></figure><p>在某个方法里开启多线程逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;Future&gt; futureList = Lists.newArrayList();</span><br><span class="line">baseThreadPoolExecutor.addPool(futureList, ABuilder, context, response);</span><br><span class="line">baseThreadPoolExecutor.addPool(futureList, BBuilder, context, response);</span><br><span class="line">baseThreadPoolExecutor.addPool(futureList, CBuilder, context, response);</span><br><span class="line">baseThreadPoolExecutor.getFutureList(futureList, <span class="number">3000000L</span>); <span class="comment">//超时时间为3000000s。</span></span><br></pre></td></tr></table></figure><p>此时response中就有我们需要的三个数据源A、B、C的数据了。当然，如果没有就超时或者报错了。</p><p>note：共同对response操作时，最好不要对同一个成员变量操作，以防止线程安全问题的出现。</p><h5 id="五、如何合理配置线程池的大小"><a href="#五、如何合理配置线程池的大小" class="headerlink" title="五、如何合理配置线程池的大小"></a>五、如何合理配置线程池的大小</h5><p>一般需要根据任务的类型来配置线程池大小，目标是整体上保证CPU不要闲着：</p><p>如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 CPU+1</p><p>如果是IO密集型任务，参考值可以设置为2<em>*</em>CPU</p><p>当然，这只是一个参考值，是具体情况而定。</p><h5 id="致谢-参考"><a href="#致谢-参考" class="headerlink" title="致谢-参考"></a>致谢-参考</h5><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZG9scGhpbjA1MjAvcC8zOTMyOTIxLmh0bWw=" title="https://www.cnblogs.com/dolphin0520/p/3932921.html">https://www.cnblogs.com/dolphin0520/p/3932921.html<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpZXl1b29vL2FydGljbGUvZGV0YWlscy84NzE4NzQx" title="https://blog.csdn.net/xieyuooo/article/details/8718741">https://blog.csdn.net/xieyuooo/article/details/8718741<i class="fa fa-external-link"></i></span></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>研三的某一天</title>
      <link href="/2017/11/05/%E7%A0%94%E4%B8%89%E7%9A%84%E6%9F%90%E4%B8%80%E5%A4%A9/"/>
      <url>/2017/11/05/%E7%A0%94%E4%B8%89%E7%9A%84%E6%9F%90%E4%B8%80%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<blockquote><p>吃过午饭，坐着102公交车来到东区图书馆。突然想写点东西。遂作此文。</p></blockquote><a id="more"></a><p> 在学校的这一段时间，悠然而舒适。天天翻翻书，看看电影，玩玩游戏，算不上努力，也谈不上荒废。</p><p> 学校秋招，我找工作蛮顺利的，已经拿到了各大厂的offer。在其它学校还在红红火火开展校园招聘时，我已经通过内推渠道获得了很多机会。这也是我很舒心的一件事儿，况且今年互联网企业的年薪又涨了一波。</p><p> 临近毕业，毕业答辩是非常重要的一件事情。室友洪文答辩在第二批，顺利地直接通过。而我因为盲审的缘故，非常非常心塞地被分到第五批答辩。前进的路上难免会有一些波折，这时候感觉心态更重要。</p><p><strong> 毕业，意味着面临选择。</strong></p><p> 我是选择北京、上海还是杭州？<br> 我是选择安逸轻松的生活还是劳累加班的日子？<br> 我选择做一份什么样的工作，这份工作对于我来说，是单纯的赚钱，还是以后的事业？</p><p> 这个问题，我也和父母、同学讨论过，我自己也思考过。每个人的想法都不尽相同，有的人求安稳，不求大富大贵，愿意平凡平稳地生活、舒服地工作。有的人较为激进，愿意将生活化成工作，拼命努力，希望在这个名利场中搏出一番天地。众说纷纭。</p><p><strong> 毕业，意味着开始面临社会的压力。</strong></p><p> 上周，大学时候的同学大飞联系我，问问杭州的环境如何。因为我在杭州实习过一年，对杭州有些大致的了解。说着说着，难免会说的房价的问题。刚刚走出校园的毕业生，看到急剧攀升的房价，特别是像我们这样从三四线城市走出的孩子来说，心里难免会有些压力。在一线城市，月薪1、2w的我们，付出了数倍的努力，却活出了四线城市月薪2k的生活水平。值不值呢？每个人心里都有一个自己的答案。面对压力，我更需要的是不急不躁的心态，和稳扎稳打的行动。</p><p><strong> 毕业，意味着更复杂。</strong></p><p> 我们需要从一个相对简单的环境，融入一个相对复杂的环境，而且要处理好各种复杂。角色转换之间，都需要做好份内的事情。</p><p> 公交车上，我靠着窗户边，任由秋天黄灿灿的阳光洒在脸上，暖洋洋的。我还有时间，还年轻，怕毛？</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 校园 </tag>
            
            <tag> 想法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx追加sticky的那些坑</title>
      <link href="/2017/09/26/Nginx%E8%BF%BD%E5%8A%A0sticky%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91/"/>
      <url>/2017/09/26/Nginx%E8%BF%BD%E5%8A%A0sticky%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p>问题：在集群中有多台服务器的情形下，开发者会在Cookie中记录一些字段，甚至是登录态。所以需要让访问者访问到某台机器后，后续的请求仍然在同一台服务器上处理。</p></blockquote><a id="more"></a><h4 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h4><blockquote><p>目前，负载分发问题的<strong>约束</strong>条件是：</p><ul><li>众多访问者的请求尽可能<strong>均匀地</strong>被分发到后端集群的机器中。</li><li>同一个访问者再次访问，多个请求被<strong>同一台机器</strong>处理。</li></ul><p><strong>解决方案</strong>：</p><ul><li>IP Hash：利用用户在上网时，一段时间内的ip是不会改变的原理。将用户的ip做哈希，对其请求进行分发。因为用户的ip暂时不变，所以其请求会被分发到同一台机器上。</li><li>基于Cookie做跟踪：第一次请求时，服务器给客户端下发一个cookie，具有特定cookie的请求会分配给同一个服务器。</li></ul><p>上述两种方案中显然第二种更优。因为约束条件第一条，请求尽可能均匀地被分发。用IP做Hash的情况，当属于某种类型IP的用户请求非常多的话，负载会出现不均匀的情况。另外，如果前置还有代理服务器的话，IP相同的情况，也会出现请求分布不均匀。所以采用第二种方案较好，Sticky第三方模块就是利用第二种方案的思路。</p></blockquote><h4 id="二、下载安装"><a href="#二、下载安装" class="headerlink" title="二、下载安装"></a>二、下载安装</h4><h5 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h5><blockquote><p>下载地址：<span class="exturl" data-url="aHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL25naW54LXN0aWNreS1tb2R1bGUvZG93bmxvYWRzL2xpc3Q=" title="http://code.google.com/p/nginx-sticky-module/downloads/list">http://code.google.com/p/nginx-sticky-module/downloads/list<i class="fa fa-external-link"></i></span></p></blockquote><p>或者</p><blockquote><p>wget <span class="exturl" data-url="aHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9uZ2lueC1zdGlja3ktbW9kdWxlL2Rvd25sb2Fkcy9kZXRhaWw/bmFtZT1uZ2lueC1zdGlja3ktbW9kdWxlLTEuMS50YXIuZ3o=" title="https://code.google.com/p/nginx-sticky-module/downloads/detail?name=nginx-sticky-module-1.1.tar.gz">https://code.google.com/p/nginx-sticky-module/downloads/detail?name=nginx-sticky-module-1.1.tar.gz<i class="fa fa-external-link"></i></span></p></blockquote><p>解压：<br>tar -xzvf nginx-sticky-module-1.1.tar.gz</p><p>我这里解压到</p><blockquote><p>/usr/local/nginx/sticky/nginx-sticky</p></blockquote><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>在Nginx源码编译的目录下，运行代码：</p><blockquote><p>./configure —prefix=/usr/local/nginx —add-module=<strong>/usr/local/nginx/sticky/nginx-sticky</strong></p><p>make<br>(不要make install，要不然就相当于重新安装了。)</p></blockquote><p>复制编译后的二进制文件到目录（拷贝前把服务停掉）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/local/nginx/nginx  /usr/local/nginx/nginx.bak</span><br><span class="line">cp /usr/local/nginx-1.9.3/objs/nginx  /usr/local/nginx/nginx</span><br></pre></td></tr></table></figure><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>在nginx.conf配置文件中，对upstream块添加sticky;即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">upstream myproject&#123;</span><br><span class="line">        #添加sticky模块后加入此配置</span><br><span class="line">        sticky;</span><br><span class="line">        #被代理的服务</span><br><span class="line">        server 192.168.1.100:8081;</span><br><span class="line">        server 192.168.1.101:8080;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h4 id="三、问题及解决"><a href="#三、问题及解决" class="headerlink" title="三、问题及解决"></a>三、问题及解决</h4><h5 id="编译出现类型转换错误"><a href="#编译出现类型转换错误" class="headerlink" title="编译出现类型转换错误"></a>编译出现类型转换错误</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cc1: warnings being treated as errors</span><br><span class="line">ngx_http_sticky_module.c: In function ‘ngx_http_get_sticky_peer’:</span><br><span class="line">/ngx_http_sticky_module.c:333: 警告：赋值时将整数赋给指针，未作类型转换</span><br><span class="line">ake[1]: *** [objs/addon/nginx-sticky-module-1.1/ngx_http_sticky_module.o] 错误 1</span><br></pre></td></tr></table></figure><p>解决：</p><p>第一步：根据资料 把ngx_http_sticky_misc.c 的281行修改如下:</p><blockquote><p>原digest-&gt;len = ngx_sock_ntop(in,digest<br>        -&gt;data, len, 1);</p><p>改成digest-&gt;len = ngx_sock_ntop(in,sizeof(struct sockaddr_in),digest<br>        -&gt;data, len, 1);</p></blockquote><p>第二步：对nginx-sticky-module-1.1/ngx_http_sticky_module.c文件也进行修改（主要是1.9.x版本会出现这问题）<br>修改两个地方，如下图：</p><p>第6行添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;nginx.h&gt;</span><br></pre></td></tr></table></figure><p>第340行左右修改（iphp-&gt;rrp.current = iphp-&gt;selected_peer;）为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iphp-&gt;rrp.current = peer;</span><br></pre></td></tr></table></figure><p>版本问题，修改stick代码后，问题得以解决。</p><hr><h5 id="编译出现hash和md5问题"><a href="#编译出现hash和md5问题" class="headerlink" title="编译出现hash和md5问题"></a>编译出现hash和md5问题</h5><p>问题描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ngx_http_sticky_misc.c: In function 「ngx_http_sticky_misc_md5」:</span><br><span class="line">ngx_http_sticky_misc.c:152:15: ERROR：「MD5_DIGEST_LENGTH」 undeclared (first use in this function)</span><br><span class="line">   u_char hash[MD5_DIGEST_LENGTH];</span><br></pre></td></tr></table></figure><p>解决：<br>解决方式就是在下载解压缩之后的sticky模块文件夹中，修改ngx_http_sticky_misc.c文件<br>将这两个模块 <openssl sha.h> and <openssl md5.h>包含到文件ngx_http_sticky_misc.c<br>下面红色标注地方</openssl></openssl></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;openssl/sha.h&gt;</span><br><span class="line">#include &lt;openssl/md5.h&gt;</span><br></pre></td></tr></table></figure><p>引入的问题，引入之后再重新编译就不会出现这种原因的错误了。</p><hr><h5 id="编译出现依赖的模块问题"><a href="#编译出现依赖的模块问题" class="headerlink" title="编译出现依赖的模块问题"></a>编译出现依赖的模块问题</h5><p>描述：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error: openssl/aes.h:No such file or directory</span><br></pre></td></tr></table></figure></p><p>解决：<br>尝试编译的程序使用OpenSSL，但是需要和OpenSSL链接的文件（库和头文件）在Linux平台系统上缺少。（其它类似的错误也可以照此处理）</p><p>要解决这个问题，安装OpenSSL。<br>要在Debian、Ubuntu或者其他衍生版上安装OpenSSL：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libssl-dev</span><br></pre></td></tr></table></figure></p><p>要在Fedora、CentOS或者RHEL上安装OpenSSL开发包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install openssl-devel</span><br></pre></td></tr></table></figure></p><p>安装完后，尝试重新编译程序。</p><h4 id="参考-amp-致谢"><a href="#参考-amp-致谢" class="headerlink" title="参考&amp;致谢"></a>参考&amp;致谢</h4><p><span class="exturl" data-url="aHR0cHM6Ly9iaXRidWNrZXQub3JnL25naW54LWdvb2RpZXMvbmdpbngtc3RpY2t5LW1vZHVsZS1uZy9jb21taXRzLzUxZWZhMTI0YTQzMzBlMTk0ZWY2NTFlNTk3YTYwMzhhNmY3OTc5ZGM=" title="https://bitbucket.org/nginx-goodies/nginx-sticky-module-ng/commits/51efa124a4330e194ef651e597a6038a6f7979dc">nginx-sticky-module文档<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9iaXRidWNrZXQub3JnL25naW54LWdvb2RpZXMvbmdpbngtc3RpY2t5LW1vZHVsZS1uZy9pc3N1ZXMvMTgvd29udC1jb21waWxlLW9uLW5naW54LTE5MA==" title="https://bitbucket.org/nginx-goodies/nginx-sticky-module-ng/issues/18/wont-compile-on-nginx-190">nginx-sticky-module-ng文档问题<i class="fa fa-external-link"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 校园 </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx使用及原理</title>
      <link href="/2017/09/20/Nginx%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86/"/>
      <url>/2017/09/20/Nginx%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要解释nginx.conf如何配置，和为什么这样配置。</p></blockquote><a id="more"></a><h4 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h4><h5 id="1、HTTP代理和反向代理"><a href="#1、HTTP代理和反向代理" class="headerlink" title="1、HTTP代理和反向代理"></a>1、HTTP代理和反向代理</h5><p>先不说教科书上的文绉绉的字段，我也记不住。</p><blockquote><p>我只说的我的理解：代理，相当于一个中间层，将服务的提供者和服务的使用者隔开。</p></blockquote><ul><li>服务提供者将服务（可以理解成数据）传送给代理服务器，但是不知道谁去使用该服务，这叫做<strong>正向代理</strong>。</li><li>服务使用者从代理服务器获取服务（数据），但不知道真正是哪台服务器提供的服务，这叫<strong>反向代理</strong>。</li></ul><blockquote><p>举个例子：如果小明去食堂吃饭，服务员端来饭菜，小明不知道这个菜是哪位厨师做的，这叫反向代理。厨师将饭菜做好后给服务员，但不知道谁去吃，这叫正向代理。</p></blockquote><p>那么为什么要用代理呢？</p><blockquote><p>我的理解主要有：</p><ul><li>一是，可以屏蔽某一方，用于保密；</li><li>二是，将服务单一化、统一化，方便使用；</li><li>三是，对于公共的一些处理，我们可以在代理服务器上统一处理。</li></ul></blockquote><h5 id="2、负载均衡"><a href="#2、负载均衡" class="headerlink" title="2、负载均衡"></a>2、负载均衡</h5><blockquote><p>负载均衡，可以有两个方面的含义：</p><ul><li>一方面，是将单一的重负载分担到多个网络节点上做并行处理，节点将任务处理完毕后汇总返回，这样提高网络系统的处理能力。我感觉，Elasticsearch这种搜索引擎就是采用这种”分而治之”思想。但是这种问题，需要能够划分成子问题。</li><li>另一方面，将大量前端并发访问分担到后端各个服务器节点上分别处理，这样可以有效减少前端用户的等待时间，减轻单机压力。Nginx服务器就是这种。</li></ul><p>Nginx服务器的负载均衡策略有很多，可以分为两个部分：</p><ul><li>内置策略：包括轮询、加权轮询、IP Hash。</li><li>扩展策略：是指第三方模块实现的策略，有url hash，包括我在使用的sticky策略。</li></ul></blockquote><h5 id="3、Web缓存"><a href="#3、Web缓存" class="headerlink" title="3、Web缓存"></a>3、Web缓存</h5><p>作为前置的服务器，可以缓存前端请求，将页面静态文件等资源缓存，从而提高性能。</p><h4 id="二、配置文件的基本结构"><a href="#二、配置文件的基本结构" class="headerlink" title="二、配置文件的基本结构"></a>二、配置文件的基本结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">work_process 1;</span><br><span class="line"></span><br><span class="line">events&#123;</span><br><span class="line">    worker_connections 10240;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http&#123;</span><br><span class="line">    include             mine.types;</span><br><span class="line">    default_type        application/octet-stream;</span><br><span class="line">    sendfile            on;</span><br><span class="line">    keepalive_timeout   60;</span><br><span class="line">    server&#123;</span><br><span class="line">        listen          80;</span><br><span class="line">        server_name     localhost;</span><br><span class="line">        location / &#123;</span><br><span class="line">            root html;</span><br><span class="line">            index index.html</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述配置文件中，将配置文件的骨架抽离出来了。<br>所有的配置和编程语言一样，括号外面的全局生效，里面的在{}范围内生效，出现冲突，也遵循就近原则。<br>整体上可以看成:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--nginx.conf</span><br><span class="line">    --全局块</span><br><span class="line">    --events块</span><br><span class="line">    --http块</span><br><span class="line">        --http全局块</span><br><span class="line">        --server块1</span><br><span class="line">        --server块2</span><br><span class="line">        --server块n</span><br></pre></td></tr></table></figure><h5 id="1、全局块："><a href="#1、全局块：" class="headerlink" title="1、全局块："></a>1、全局块：</h5><blockquote><p>影响全局，比如work_process指的是nginx可以生成几个进程共同处理请求。官方文档建议是1个，但是出于性能考虑，我认为和计算机的CPU核数相同就好。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker_process 2;     #存在2个work进程处理请求</span><br></pre></td></tr></table></figure><h5 id="2、events块"><a href="#2、events块" class="headerlink" title="2、events块"></a>2、events块</h5><blockquote><p>影响Nginx服务器与用户的网络连接。</p></blockquote><p>常用的设置有：</p><ul><li>是否对多个worker process序列化<blockquote><p>网络中有种现象叫做“<strong>惊群</strong>”，该问题产生于，当有个网络连接到来时，多个睡眠等待进程会被同时叫醒。但是，只有一个进程获得连接。如果每次叫醒的进程过多，对资源是一种浪费。</p></blockquote></li></ul><blockquote><p>处理方案:将接受连接的进程进行序列化，避免争抢。配置如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">accept_mutex on|off;</span><br></pre></td></tr></table></figure><ul><li>是否允许接受多个网络连接<blockquote><p>每个 work process是否接受多个连接，配置如下：</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multi_accept on|off;</span><br></pre></td></tr></table></figure><ul><li>选取哪一种事件驱动模型处理连接请求<blockquote><p>将每个消息看成一个事件，当消息来临时。采用什么样的方式处理该事件。有select、poll和epoll等方式。配置如下：</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use method;</span><br></pre></td></tr></table></figure><ul><li>每个work process可以同时支持的最大连接数目</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker_connections 512;</span><br></pre></td></tr></table></figure><h5 id="3、http块"><a href="#3、http块" class="headerlink" title="3、http块"></a>3、http块</h5><blockquote><p>重要部分！代理、缓存、日志定义等绝大多数功能都在其中。</p><ul><li>文件引入、MIME-TYPE定义。<br>用于Nginx区分资源，比如HTML、XML、GIF等，打开mime.types文件可以看到对应的定义。</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">include         mime.types</span><br><span class="line">default_type    application/octet-stream #处理类型</span><br></pre></td></tr></table></figure><ul><li><p>日志自定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">access_log path [format[buffer=size]]</span><br></pre></td></tr></table></figure></li><li><p>是否使用sendfile传输文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sendfile            on|off  #是否开启</span><br><span class="line">sendfile_max_chunk  size    #chunk的大小，nginx每次调用sendfile()传输大小不超过这个值</span><br></pre></td></tr></table></figure></li><li><p>连接超时时间。nginx与前端保持连接的时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keepalive_timeout timeout[header_timeout]</span><br></pre></td></tr></table></figure></li><li><p>单连接请求数上限。通过某一连接发送的次数，默认100</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keepalive_requests number;</span><br></pre></td></tr></table></figure></li></ul><h5 id="4、server块"><a href="#4、server块" class="headerlink" title="4、server块"></a>4、server块</h5><p>server块 代表虚拟主机的概念。目的是节约硬件成本，用一台主机对外可以表现出多个机器的感觉。</p><p>每个server块 就相当于一台虚拟主机。</p><ul><li>配置监听<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">listen 80;</span><br><span class="line">server_name ip|域名;</span><br></pre></td></tr></table></figure></li></ul><h5 id="5、location块"><a href="#5、location块" class="headerlink" title="5、location块"></a>5、location块</h5><p>其实是server块中的一个命令，用来匹配请求，然后对该请求进行重写、转发等功能。正则匹配url后进行处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    proxy_pass http://defaultServer ; #将请求分发给defaultServer  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三、Nginx服务器事件驱动模型"><a href="#三、Nginx服务器事件驱动模型" class="headerlink" title="三、Nginx服务器事件驱动模型"></a>三、Nginx服务器事件驱动模型</h4><blockquote><p>记得有一次面试，面试官是网易金融的架构师。问到了事件驱动模型，我一脸懵逼，囧。所以现在遇到了，单独拉出来记录一下。</p><p>在Java的SpringMVC那一套中，每个请求都是实打实的请求request，然后交给dispacherServlet来处理各个请求。Servlet就一个实例。然后nginx采用的这套模型和java中的不同。</p><p>事件驱动模型是由<strong>事件收集器、事件发送器和事件处理器</strong>三部分基本单元构成。</p><p>在nginx中，基于事件驱动模型，这些消息事件在“事件处理器”中采用的方式是：</p><ul><li>“事件发送器”每传递过来一个请求，“消息事件”就将其放到一个待处理的事件的列表中，使用非阻塞I/O方式调用“事件处理器”来处理请求。</li><li>事件驱动处理 就是 多路I/O复用方法。在Nginx中，最常见的是：select模型、poll模型和epoll模型。</li></ul></blockquote><h5 id="1、select模型"><a href="#1、select模型" class="headerlink" title="1、select模型"></a>1、select模型</h5><ol><li>创建所关注事件的描述符集合。关注该描述符的Read、Write和Exception事件，所以创建三类事件描述符集合。</li><li>调用select()函数，等待事件发生。</li><li>轮询所有事件描述符集合中的每个事件的描述符，检查是否有相应事件发生，有了就处理。</li></ol><h5 id="2、poll模型"><a href="#2、poll模型" class="headerlink" title="2、poll模型"></a>2、poll模型</h5><p>poll模型与select模型类似，创建-&gt;等待-&gt;轮询。<br>区别在于poll模型没有针对Read、Write和Exception事件分别做集合，而是只有一个集合，在描述符的对应结构上分别设置这三个事件。poll是select的升级版。</p><h5 id="3、epoll模型"><a href="#3、epoll模型" class="headerlink" title="3、epoll模型"></a>3、epoll模型</h5><p>epoll是poll的变种，非常优秀！<br>之前的流程是 创建事件列表-&gt;将列表传入内核-&gt;返回结果后轮询列表；<br>当列表事件很多时，效率较低。<br>epoll让内核创建事件描述符。事件发生后，内核将事件的描述符返回给epoll，从而进行处理。所以没有轮询操作。</p><h4 id="四、参考-amp-致谢"><a href="#四、参考-amp-致谢" class="headerlink" title="四、参考&amp;致谢"></a>四、参考&amp;致谢</h4><blockquote><p>《Nginx高性能Web服务器详解》   苗泽编著</p><p>《Mastering Nginx》                  [瑞士]Dimitri Aivaliotis 著</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 校园 </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx小试</title>
      <link href="/2017/09/19/Nginx%E5%B0%8F%E8%AF%95/"/>
      <url>/2017/09/19/Nginx%E5%B0%8F%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>遇到将单台服务器变成集群的需求，之前一直是运维同学负责部署维护，自己只是使用者的角色，这次我来部署和维护，正好试一试。</p></blockquote><a id="more"></a><blockquote><p>介绍：Nginx首先是个服务器，且功能丰富。可以作为HTTP服务器、反向代理服务器和邮件服务器。<br>常用功能主要有：</p><ul><li>HTTP代理和反向代理</li><li>负载均衡</li><li>Web缓存</li></ul></blockquote><p>好，大致先有个了解，先让它跑起来再逐步尝试其功能、理解其工作原理。</p><h3 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h3><p>首先说明，下面安装步骤适用于Ubuntu和RedHat系统，笔者亲测。其他系统如要安装本文只做参考。</p><h4 id="系统设置"><a href="#系统设置" class="headerlink" title="系统设置"></a>系统设置</h4><blockquote><p>真实的应用中，Linxu有打开文件描述符的限制。</p></blockquote><p>通过命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -n</span><br></pre></td></tr></table></figure><p>可以查看linux系统里打开文件描述符的最大值，一般缺省值是1024，对一台繁忙的服务器来说，这个值偏小。</p><p>修改方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/security/limits.conf</span><br></pre></td></tr></table></figure><p>最后一行追加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*                -       nofile           65535</span><br></pre></td></tr></table></figure><p>然后<strong>重新远程登录</strong>，用ulimit -n命令校验，判断是否为65535。</p><h4 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h4><h5 id="1、GCC"><a href="#1、GCC" class="headerlink" title="1、GCC"></a>1、GCC</h5><blockquote><p>GCC——GNU编译器集合（GCC可以使用默认包管理器的仓库（repositories）来安装，包管理器的选择依赖于你使用的Linux发布版本，包管理器有不同的实现：yum是基于Red Hat的发布版本；apt用于Debian和Ubuntu；yast用于SuSE Linux等等。）</p></blockquote><p>RedHat中安装GCC：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc</span><br></pre></td></tr></table></figure><p>Ubuntu中安装GCC：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install gcc</span><br></pre></td></tr></table></figure><h5 id="2、PCRE库"><a href="#2、PCRE库" class="headerlink" title="2、PCRE库"></a>2、PCRE库</h5><blockquote><p>PCRE库（Nginx编译需要PCRE（Perl Compatible Regular Expression），因为Nginx的Rewrite模块和HTTP核心模块会使用到PCRE正则表达式语法。这里需要安装两个安装包pcre和pcre-devel。第一个安装包提供编译版本的库，而第二个提供开发阶段的头文件和编译项目的源代码，这正是我们需要的理由。）</p></blockquote><p>RedHat中安装PCRE：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install pcre pcre-devel</span><br></pre></td></tr></table></figure><p>Ubuntu中安装PCRE：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install libpcre3 libpcre3-dev</span><br></pre></td></tr></table></figure><h5 id="3、zlib库"><a href="#3、zlib库" class="headerlink" title="3、zlib库"></a>3、zlib库</h5><blockquote><p>zlib库（zlib库提供了开发人员的压缩算法，在Nginx的各种模块中需要使用gzip压缩。如同安装PCRE一样，同样需要安装库和它的源代码：zlib和zlib-devel。）</p></blockquote><p>RedHat中安装zlib：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install zlib zlib-devel</span><br></pre></td></tr></table></figure><p>Ubuntu中安装zlib：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install zlib1g zlib1g-dev</span><br></pre></td></tr></table></figure><h5 id="4、OpenSSL库"><a href="#4、OpenSSL库" class="headerlink" title="4、OpenSSL库"></a>4、OpenSSL库</h5><blockquote><p>OpenSSL库（在Nginx中，如果服务器提供安全网页时则会用到OpenSSL库，我们需要安装库文件和它的开发安装包（openssl和openssl-devel）。）</p></blockquote><p>RedHat中安装OpenSSL：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install openssl openssl-devel</span><br></pre></td></tr></table></figure><p>Ubuntu中安装OpenSSL：（注：Ubuntu14.04的仓库中没有发现openssl-dev）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install openssl openssl-dev</span><br></pre></td></tr></table></figure><blockquote><p><strong>Tip</strong>:上述安装过程中，如果已经安装过了，可以跳过。<br>如果安装失败，建议自行下载tar.gz然后解压、编译并安装。</p></blockquote><h4 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h4><p>安装了一堆，终于步入正题了~</p><p>首先，在网上下载一个nginx.tar.gz的源码。然后操作如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf nginx-1.12.0.tar.gz</span><br><span class="line">cd nginx-1.12.0/</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>正常安装后，在该目录下的objs文件夹下，会产生nginx执行文件。将该文件复制到/usr/sbin/下。</p><p>然后可以输入如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nginx   //启动nginx</span><br><span class="line"></span><br><span class="line">nginx -t  //查看相关配置文件</span><br><span class="line"></span><br><span class="line">nginx -v  //查看版本号</span><br></pre></td></tr></table></figure><p>启动成功后，访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localhost:80</span><br></pre></td></tr></table></figure><p>就会显示Nginx的欢迎的页面啦，意味着安装成功~</p><h3 id="二、-初步使用Nginx"><a href="#二、-初步使用Nginx" class="headerlink" title="二、 初步使用Nginx"></a>二、 初步使用Nginx</h3><p>如果要用Nginx进行负载的话，我先给个Nginx配置的Demo，至于每个字段的含义，我会在另一篇Blog再进行阐述。这是在conf文件夹下，nginx.conf的文件的demo。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">user  www-data;  </span><br><span class="line">worker_processes  auto;  </span><br><span class="line">  </span><br><span class="line">error_log  /var/log/nginx/error.log warn;  </span><br><span class="line">pid        /run/nginx.pid;  </span><br><span class="line">  </span><br><span class="line">events &#123;  </span><br><span class="line">    worker_connections  1024;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">http &#123;  </span><br><span class="line">    include       mime.types;  </span><br><span class="line">    default_type  application/octet-stream;  </span><br><span class="line">  </span><br><span class="line">    log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;  </span><br><span class="line">                      &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;  </span><br><span class="line">                      &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;  </span><br><span class="line">  </span><br><span class="line">    access_log  /var/log/nginx/access.log  main;  </span><br><span class="line">  </span><br><span class="line">    sendfile        on;  </span><br><span class="line">    #tcp_nopush     on;  </span><br><span class="line">  </span><br><span class="line">    keepalive_timeout  65;  </span><br><span class="line">  </span><br><span class="line">    #gzip  on;  </span><br><span class="line">    upstream defaultServer &#123;  </span><br><span class="line">      server ip:端口号;  </span><br><span class="line">      server ip2:端口号2;  </span><br><span class="line">    &#125;    </span><br><span class="line">  </span><br><span class="line">    server &#123;     </span><br><span class="line">        listen       需要监听的端口号;     </span><br><span class="line">        server_name  需要监听的域名;     </span><br><span class="line">        charset utf-8;     </span><br><span class="line">        location / &#123;     </span><br><span class="line">            proxy_pass        http://defaultServer ;     </span><br><span class="line">            proxy_set_header  X-Real-IP  $remote_addr;     </span><br><span class="line">            client_max_body_size  100m;  </span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、常用指令"><a href="#三、常用指令" class="headerlink" title="三、常用指令"></a>三、常用指令</h3><p>开启：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx</span><br></pre></td></tr></table></figure><p>关闭：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep nginx  //查询nginx主进程的pid</span><br><span class="line">kill -QUIT pid    //上个命令获取的pid。此命令是平滑关闭</span><br></pre></td></tr></table></figure><p>配置更新，修改nginx.conf后无需重启。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><h3 id="四、番外"><a href="#四、番外" class="headerlink" title="四、番外"></a>四、番外</h3><blockquote><p>如果你读到这里，终于安装好了！</p><p>那么，恭喜你，我其实还有更简单的安装方法~~</p></blockquote><p>在ubuntu系统中，输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nginx</span><br></pre></td></tr></table></figure><p>完毕！自动安装上述依赖。</p><p>别的系统也可以类似在线安装。把apt-get换成yum。</p><blockquote><p>那么我为什么要用如此大的篇幅来阐述如何编译安装而不采用在线安装呢？因为我发现，这种方式没有源代码，意味着无法引入第三方代码来进行重新编译，从而达到扩展的目的。故这种方式，只能用一些原生的功能。</p></blockquote><h3 id="参考-amp-致谢"><a href="#参考-amp-致谢" class="headerlink" title="参考&amp;致谢"></a>参考&amp;致谢</h3><blockquote><p>1、<span class="exturl" data-url="aHR0cDovL25vdGUueW91ZGFvLmNvbS8=" title="http://note.youdao.com/">Nginx安装<i class="fa fa-external-link"></i></span></p><p>2、<span class="exturl" data-url="aHR0cDovL25vdGUueW91ZGFvLmNvbS8=" title="http://note.youdao.com/">Ubuntu/CentOS 系统上安装与配置Nginx<i class="fa fa-external-link"></i></span></p><p>3、<span class="exturl" data-url="aHR0cDovL25vdGUueW91ZGFvLmNvbS8=" title="http://note.youdao.com/">nginx依赖模块pcre、zlib、openssl 安装<i class="fa fa-external-link"></i></span></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 校园 </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch与kibana流水账</title>
      <link href="/2017/03/26/ElasticSearch%E4%B8%8Ekibana%E6%B5%81%E6%B0%B4%E8%B4%A6/"/>
      <url>/2017/03/26/ElasticSearch%E4%B8%8Ekibana%E6%B5%81%E6%B0%B4%E8%B4%A6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>近期需要进行日志收集，将各主机中的日志收集起来，放到elasticSearch中。然后利用es进行统计、搜索。简单介绍一下~</p></blockquote><a id="more"></a><blockquote><p>介绍：ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。</p></blockquote><h4 id="安装ElasticSearch"><a href="#安装ElasticSearch" class="headerlink" title="安装ElasticSearch"></a>安装ElasticSearch</h4><p>Es篇：安装Es </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.elastic.co/elasticsearch/elasticsearch/elasticsearch-1.7.3.zip </span><br><span class="line">unzip elasticsearch-1.7.3.zip </span><br><span class="line">cd elasticsearch</span><br></pre></td></tr></table></figure><h4 id="安装Marvels"><a href="#安装Marvels" class="headerlink" title="安装Marvels"></a>安装Marvels</h4><blockquote><p>Marvel是一个插件，可在Elasticsearch目录中运行以下命令来下载和安装：</p><p>./bin/plugin    -i    elasticsearch/marvel/latest</p><p>你如果想要禁用监控，你可以通过以下命令关闭Marvel：</p><p>echo    ‘marvel.agent.enabled:    false’    &gt;&gt;    ./config/elasticsearch.yml</p></blockquote><h4 id="运行Elasticsearch"><a href="#运行Elasticsearch" class="headerlink" title="运行Elasticsearch"></a>运行Elasticsearch</h4><blockquote><p>Elasticsearch已经准备就绪，执行以下命令可在前台启动：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/elasticsearch</span><br></pre></td></tr></table></figure><blockquote><p>启动后，如果只有本地可以访问，尝试修改配置文件    elasticsearch.yml<br>中network.host(注意配置文件格式不是以    #    开头的要空一格，        ：    后要空一格) 为    </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">network.host:0.0.0.0</span><br></pre></td></tr></table></figure><blockquote><p>如果想在后台以守护进程模式运行，添加    -d    参数。</p><p>打开另一个终端进行测试：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl&apos;http://localhost:9200/?pretty&apos;</span><br></pre></td></tr></table></figure><blockquote><p>你能看到以下返回信息：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-33-207-ubuntu:~$ curl &apos;http://localhost:9200/?pretty&apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;status&quot; : 200,</span><br><span class="line">  &quot;name&quot; : &quot;chengshuoNode&quot;,</span><br><span class="line">  &quot;cluster_name&quot; : &quot;chengshuo_cluster&quot;,</span><br><span class="line">  &quot;version&quot; : &#123;</span><br><span class="line">    &quot;number&quot; : &quot;1.7.3&quot;,</span><br><span class="line">    &quot;build_hash&quot; : &quot;05d4530971ef0ea46d0f4fa6ee64dbc8df659682&quot;,</span><br><span class="line">    &quot;build_timestamp&quot; : &quot;2015-10-15T09:14:17Z&quot;,</span><br><span class="line">    &quot;build_snapshot&quot; : false,</span><br><span class="line">    &quot;lucene_version&quot; : &quot;4.10.4&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;tagline&quot; : &quot;You Know, for Search&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这说明你的ELasticsearch集群已经启动并且正常运行</p></blockquote><h4 id="head"><a href="#head" class="headerlink" title="head"></a>head</h4><p>这是一个非常简单实用的插件，类似于Navicat之于Mysql。方便我们查找数据。</p><p>通过head，可以查看集群几乎所有信息，还能进行简单的搜索查询，观察自动恢复的情况等等。<br>执行下面的命令开始安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./bin/plugin -install mobz/elasticsearch-head</span><br></pre></td></tr></table></figure><p>安装完成之后， 可以通过浏览器输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://ip:9200/_plugin/head/</span><br></pre></td></tr></table></figure><p>可以查看显示效果。</p><h4 id="bigdesk"><a href="#bigdesk" class="headerlink" title="bigdesk"></a>bigdesk</h4><p>bigdesk是elasticsearch的一个集群监控工具，可以通过它来查看es集群的各种状态，如：cpu、内存使用情况，索引数据、搜索情况，http连接数等。项目git地址： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/lukas-vlcek/bigdesk。</span><br></pre></td></tr></table></figure><p>和head一样，它也是个独立的网页程序，使用方式和head一样。<br>插件安装运行： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.bin/plugin -install lukas-vlcek/bigdesk </span><br><span class="line">2.运行es </span><br><span class="line">3.打开http://localhost:9200/_plugin/bigdesk/</span><br></pre></td></tr></table></figure><p>当然，也可以直接下载源码运行index.html </p><p>安装显示 kibana</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.elasticsearch.org/kibana/kibana/kibana-3.1.2.zip</span><br><span class="line">unzip kibana-3.1.2.zip</span><br><span class="line">mv kibana-3.1.2/* &lt;tomcat-path&gt;/webapps/kibana</span><br></pre></td></tr></table></figure><p>访问<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4MC9raWJhbmEvaW5kZXguaHRtbA==" title="http://localhost:80/kibana/index.html">http://localhost:80/kibana/index.html<i class="fa fa-external-link"></i></span></p><h4 id="出现问题"><a href="#出现问题" class="headerlink" title="出现问题"></a>出现问题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kibana-returns-connection-failed</span><br></pre></td></tr></table></figure><p>解决方法</p><p>在elasticSearch的conf文件中 elasticsearch.yml 添加如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http.cors.allow-origin: &quot;/.*/&quot;</span><br><span class="line">http.cors.enabled: true</span><br></pre></td></tr></table></figure></p><p>访问<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4MC9raWJhbmEvaW5kZXguaHRtbA==" title="http://localhost:80/kibana/index.html">http://localhost:80/kibana/index.html<i class="fa fa-external-link"></i></span><br>OK</p><p>至于flume的开发呢，我的方式是从github上下载源码，根据具体业务定制一个flume。</p><h4 id="使用ES查询例子"><a href="#使用ES查询例子" class="headerlink" title="使用ES查询例子"></a>使用ES查询例子</h4><p>1、Range与过滤的组合，用于查找uv</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GET flume_index-2017-03-03/flume_type/_search?search_type=count</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot; : &#123;</span><br><span class="line">        &quot;filtered&quot;: &#123;</span><br><span class="line">            &quot;filter&quot;: &#123;</span><br><span class="line">                &quot;range&quot;: &#123;</span><br><span class="line">                    &quot;timeNum&quot;: &#123;</span><br><span class="line">                        &quot;gte&quot;: 1487606000000,</span><br><span class="line">                        &quot;lt&quot;:  1487606060000</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;aggs&quot;:&#123;&quot;uniq_attr&quot;: &#123;&quot;cardinality&quot;: &#123;&quot;field&quot;: &quot;ip&quot;&#125;&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、使用bool进行组合查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">GET flume_index-2017-03-03/flume_type/_search?search_type=count</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot; : &#123;</span><br><span class="line">        &quot;bool&quot;: &#123;</span><br><span class="line">            &quot;must&quot;: &#123;</span><br><span class="line">                &quot;range&quot;: &#123;</span><br><span class="line">                    &quot;timeNum&quot;: &#123;</span><br><span class="line">                        &quot;gte&quot;: 1487606000000,</span><br><span class="line">                        &quot;lt&quot;:  1487606060000</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;must&quot;:&#123;</span><br><span class="line">              &quot;term&quot;:&#123;</span><br><span class="line">                  &quot;spreadId&quot;:&quot;12&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;aggs&quot;:&#123;&quot;uniq_attr&quot;: &#123;&quot;cardinality&quot;: &#123;&quot;field&quot;: &quot;ip&quot;&#125;&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、聚合查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /flume_index-2017-03-03/flume_type/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;aggs&quot; : &#123;</span><br><span class="line">        &quot;ipProportion&quot; : &#123;</span><br><span class="line">            &quot;terms&quot; : &#123; &quot;field&quot; : &quot;body.ip&quot; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参考致谢"><a href="#参考致谢" class="headerlink" title="参考致谢"></a>参考致谢</h4><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxhc3RpYy5jby9wcm9kdWN0cy9raWJhbmE=" title="https://www.elastic.co/products/kibana">kibana官网<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxhc3RpYy5jby9wcm9kdWN0cy9lbGFzdGljc2VhcmNo" title="https://www.elastic.co/products/elasticsearch">Elasticsearch官网<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5saW51eGlkYy5jb20vTGludXgvMjAxNS0wMi8xMTMyODkuaHRt" title="http://www.linuxidc.com/Linux/2015-02/113289.htm">Kibana使用安装<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWluZ18zMTEvYXJ0aWNsZS9kZXRhaWxzLzUwNjE5ODU5" title="http://blog.csdn.net/ming_311/article/details/50619859">Kibana基本使用<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9oYW55aW5nbG9uZy9wLzU0MDkwMDMuaHRtbA==" title="http://www.cnblogs.com/hanyinglong/p/5409003.html">Elasticsearch初步使用(安装、Head配置、分词器配置)<i class="fa fa-external-link"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Linux的TCP相关参数的整理</title>
      <link href="/2017/02/05/%E5%85%B3%E4%BA%8ELinux%E7%9A%84TCP%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0%E7%9A%84%E6%95%B4%E7%90%86/"/>
      <url>/2017/02/05/%E5%85%B3%E4%BA%8ELinux%E7%9A%84TCP%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0%E7%9A%84%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>虽然学习过TCP的三次握手与四次挥手，但是对于Linux服务器的这方面参数所知甚少。故在网上搜集了一下，整理如下：<br><a id="more"></a></p></blockquote><p>net.ipv4.tcp_syncookies = 1</p><blockquote><p>表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；</p></blockquote><p>net.ipv4.tcp_tw_reuse = 1</p><blockquote><p>表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；</p></blockquote><p>net.ipv4.tcp_tw_recycle = 1</p><blockquote><p>表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭；</p></blockquote><p>net.ipv4.tcp_fin_timeout</p><blockquote><p>修改系統默认的 TIMEOUT 时间。</p></blockquote><p>net.ipv4.tcp_keepalive_time = 1200</p><blockquote><p>表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为20分钟。linux内核包含对keepalive的支持。其中使用了三个参数：tcp_keepalive_time（开启keepalive的闲置时长）tcp_keepalive_intvl（keepalive探测包的发送间隔） 和tcp_keepalive_probes （如果对方不予应答，探测包的发送次数）；</p></blockquote><p>net.ipv4.ip_local_port_range = 10000 65000</p><blockquote><p>表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为10000到65000。（注意：这里不要将最低值设的太低，否则可能会占用掉正常的端口！）</p></blockquote><p>net.ipv4.tcp_max_syn_backlog = 8192</p><blockquote><p>表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。</p></blockquote><p>net.core.rmem_max = 16777216           </p><blockquote><p>最大socket读buffer,可参考的优化值:873200</p></blockquote><p>net.core.wmem_max = 16777216           </p><blockquote><p>最大socket写buffer,可参考的优化值:873200</p></blockquote><p>net.ipv4.tcp_synack_retries = 2</p><blockquote><p>为了打开对端的连接，内核需要发送一个SYN并附带一个回应前面一个SYN的ACK。也就是所谓三次握手中的第二次握手。这个设置决定了内核放弃连接之前发送SYN+ACK包的数量。</p></blockquote><p>net.ipv4.tcp_syn_retries = 2</p><blockquote><p>在内核放弃建立连接之前发送SYN包的数量。</p></blockquote><p>net.ipv4.tcp_tw_reuse = 1</p><blockquote><p>开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接。</p></blockquote><p>net.ipv4.tcp_wmem = 8192 436600 873200</p><blockquote><p>TCP写buffer,可参考的优化值: 8192 436600 873200</p></blockquote><p>net.ipv4.tcp_rmem  = 32768 436600 873200</p><blockquote><p>TCP读buffer,可参考的优化值: 32768 436600 873200</p></blockquote><p>net.ipv4.tcp_mem = 94500000 91500000 92700000</p><blockquote><p>同样有3个值,意思是:</p><ul><li>net.ipv4.tcp_mem[0]:低于此值，TCP没有内存压力。</li><li>net.ipv4.tcp_mem[1]:在此值下，进入内存压力阶段。</li><li>net.ipv4.tcp_mem[2]:高于此值，TCP拒绝分配socket。<br>上述内存单位是页，而不是字节。可参考的优化值是:786432 1048576 1572864</li></ul></blockquote><p>net.core.somaxconn</p><blockquote><p>定义了系统中每一个端口最大的监听队列的长度，这是个全局的参数。默认值128,优化值2048。</p></blockquote><p>经过这样的优化配置之后，你的服务器的TCP并发处理能力会显著提高。以上配置仅供参考，用于生产环境请根据自己的实际情况。</p><p>同时补充下相关概念：</p><blockquote><p>未连接队列：在三次握手协议中，服务器维护一个未连接队列，该队列为每个客户端的SYN包（syn=j）开设一个条目，该条目表明服务器已收到SYN包，并向客户发出确认，正在等待客户的确认包。这些条目所标识的连接在服务器处于Syn_RECV状态，当服务器收到客户的确认包时，删除该条目，服务器进入ESTABLISHED状态。 </p><p>Backlog参数：表示未连接队列的最大容纳数目。</p><p>SYN-ACK 重传次数　服务器发送完SYN－ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同。</p><p>半连接存活时间：是指半连接队列的条目存活的最长时间，也即服务从收到SYN包到确认这个报文无效的最长时间，该时间值是所有重传请求包的最长等待时间总和。有时我们也称半连接存活时间为Timeout时间、SYN_RECV存活时间。</p><p>修改/etc/sysctl.conf再执行以下命令，让修改结果立即生效：/sbin/sysctl -p</p></blockquote><p>参考：</p><ul><li><span class="exturl" data-url="aHR0cDovL21hY2hhZWwuYmxvZy41MWN0by5jb20vODI5NDYyLzIxMTk4OQ==" title="http://machael.blog.51cto.com/829462/211989">linux下使用TCP存活(keepalive)定时器<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9mY3pqdWV2ZXIvYXJjaGl2ZS8yMDEzLzA0LzE3LzMwMjY2OTQuaHRtbA==" title="http://www.cnblogs.com/fczjuever/archive/2013/04/17/3026694.html">Linux之TCPIP内核参数优化<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2luZHh4Zi9hcnRpY2xlL2RldGFpbHMvNjA0NTM4MQ==" title="http://blog.csdn.net/windxxf/article/details/6045381">linux 大量的TIME_WAIT解决办法<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL25ldHNlY3VyaXR5LjUxY3RvLmNvbS9hcnQvMjAwNjA4LzMwNDI4Lmh0bQ==" title="http://netsecurity.51cto.com/art/200608/30428.htm">SYN 攻击原理以及防范技术<i class="fa fa-external-link"></i></span></li></ul>]]></content>
      
      
      <categories>
          
          <category> 实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 整理 </tag>
            
            <tag> Linux </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小记-我的2016</title>
      <link href="/2017/01/25/%E5%B0%8F%E8%AE%B0-%E6%88%91%E7%9A%842016/"/>
      <url>/2017/01/25/%E5%B0%8F%E8%AE%B0-%E6%88%91%E7%9A%842016/</url>
      
        <content type="html"><![CDATA[<blockquote><p>今天是农历年前，在公司上班的最后一天。此刻，还是驻足回顾一下这一年的得与失，记录下自己的成长历程。</p></blockquote><a id="more"></a><h5 id="七月-离开"><a href="#七月-离开" class="headerlink" title="七月 - 离开"></a>七月 - 离开</h5><blockquote><p>七月之前，我和好哥们一起，用纸箱将一大摞书从301实验室哼哧哼哧地抱回宿舍。仿佛此刻 我们的学生生活从此结束了。</p><p>明鑫、洪文、诗琦、阳阳、高爽、雪志、伟仔……我们在一起吃过最后一顿饭，诗琦就踏上了前往帝都的高铁。紧接着，我也收拾行李，来到了杭州。一个陌生的城市。</p><p>出了校门，看着火车窗外飞驰过的绿油油的树木，心中有些小忐忑，但更多的走向社会，步入实习的激动。我拖着大大的行李箱，在火热的骄阳下，寻找住所。</p><p>在杭州，公司人性化地分配了两周的免费酒店，两人一间。“当当当”，和我一起住的是来自华南理工的森雨，高高瘦瘦，背个吉他，是个地地道道的南方人。他是在移动开发的部门，也是个实习生，对android比较精通。我呢，喜爱java，一直学习后端开发这个方面。两周很快结束，我在公司附近，余杭区找了个房子，因为不太懂签协议，就租了一年，违约金竟然高达3个月。这样，我就被绑在的余杭区。</p></blockquote><h5 id="八月九月-新地方"><a href="#八月九月-新地方" class="headerlink" title="八月九月 - 新地方"></a>八月九月 - 新地方</h5><blockquote><p>进入公司，我发现，公司和我在学校里学习的那些还是有不少的出入，好在基础语言还是java，计算机基础我还是比较扎实。所以在实习的前两周，都是疯狂地学习各种中间件，什么HSF，TDDL，Tair，对着些，让我感受比较大的就是 知道了互联网公司是如何进行开发软件的，如何进行迭代和上线的。</p><p>其中，印象比较深的就是 关于事务的理解。之前在学校里感觉为了安全 把很多操作都写成事务，然而，在大型互联网公司，为了实现高并发，减少回滚用的不是事务，而是消息机制，比如说notify等。类似这种点，都让我豁然开朗，颇觉得有点意思~~</p><p>历史惊人的相似，和本科一样，我的研究生那些同学陆陆续续地都去了北京，只有极少数人在杭州实习，有的时候就在微信里和北京的同学瞎扯，交流下实习的感想。</p><p>时间飞逝。</p></blockquote><h5 id="九月-波折"><a href="#九月-波折" class="headerlink" title="九月 - 波折"></a>九月 - 波折</h5><blockquote><p>因为我是18年春季毕业，所以说虽然转正答辩还可以，结局还是被HRG依照公司的规定撵走了。有些无奈。</p><p>就这样，我突然漂泊在了杭州。</p><p>两周后，网易打来电话，恭喜我可以去入职。于是我有辗转到了网易。</p></blockquote><h5 id="九月以后-渐稳"><a href="#九月以后-渐稳" class="headerlink" title="九月以后 - 渐稳"></a>九月以后 - 渐稳</h5><blockquote><p>来到网易后，结识了更多的小伙伴，大都和我年龄差距不大，所以很有共同语言。一起吃饭 ，拍代码，加班，上线。</p><p>老大也会经常带我们出去吃大餐，各种美味，加上网易食堂伙食本来就很棒，关键是不要钱。于是，在接下来的几个月，我就胖了十来斤。</p><p>之前租的房子压在手里，只好硬着头皮住下去。所以，我每天6点半就起床坐公交，因为位置偏远，就连班车也不往这边开。大概九点钟可以赶到公司，吃完饭，就开始一天的忙碌。<br>晚上基本9点回去，到住的地方就10点半了。</p><p>每天早晨，尤其是大冬天，天气灰蒙，就得离开温暖的被窝，迎着冰冷的冬风，去公交站等车。睡意朦胧，不幸中的万幸就是，在311公交站旁，大概在6：50都会有一大帮小学生在那里等校车。叽叽喳喳的，家长在后面跟着，这些小学生有的拿着豆浆包子，有的叫着打着，哭闹着，为这这寒冷的早晨添加了不少欢喜。有时候，我就想，这么小的小孩都能起来，我也能起来啊，我也是从小学生过来的。</p><p>在网易的四个月，拍了不少代码，原来不懂得、不了解的也都逐步理解。上线也变得驾轻就熟。</p></blockquote><h5 id="一月-事故"><a href="#一月-事故" class="headerlink" title="一月 - 事故"></a>一月 - 事故</h5><blockquote><p>接老大安排，做了年会投票、抽奖的系统。服务器需要提供650+的websocket的长连接。</p><p>年会当天,服务器在主持人呼吁大家开始绑定建立连接后，瞬间爆炸！很不幸，服务器崩了。我当着总监+全部门+外邀嘉宾，大概700+人，当场调试线上服务器代码。这中感觉也是没谁了~~</p><p>事后，既然发生了，老大顶着。我只能仔细分析原因，吃一堑长一智。对性能、压力测试这一块，还要仔细深入探究。</p><p>没弄崩过服务器，以后怎么做架构师？</p><p>不过，代价挺大。</p></blockquote><h5 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h5><blockquote><p>这一年，从校园转变到社会，从学生转变到实习生。</p><p>这一年，没赚到什么钱，全交房租了~~，但是对于软件开发那点事儿知道了不少。</p><p>这一年，没什么功绩，但多了些经历。</p><p>希望来年会更好。</p></blockquote><p>&gt;<br>&gt;<br>&gt;<br>&gt;</p>]]></content>
      
      
      <categories>
          
          <category> 实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于年会系统要点的总结</title>
      <link href="/2017/01/22/%E5%85%B3%E4%BA%8E%E5%B9%B4%E4%BC%9A%E7%B3%BB%E7%BB%9F%E8%A6%81%E7%82%B9%E7%9A%84%E6%80%BB%E7%BB%93/"/>
      <url>/2017/01/22/%E5%85%B3%E4%BA%8E%E5%B9%B4%E4%BC%9A%E7%B3%BB%E7%BB%9F%E8%A6%81%E7%82%B9%E7%9A%84%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><blockquote><p>这两周老大安排我做了年会系统的后端开发工作，这里面有消息的推送websocket相关技术，也有关于易信开发的相关技术，由于我之前没有应用过，在这里做个总结。</p></blockquote><a id="more"></a><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><blockquote><p>这里面需求映射为技术的话无非就对数据库的增删查改的操作，只是比普通的需求点多了这两个特殊的需求。</p><p>需求一，当总监在台上点击pad上的“开始抽奖”按钮时，页面左部份出现奖品的滚动操作，右部分每一秒中出现一个获奖者，并同时滚动。此刻，中奖名单也每秒一个的速度推送至台下的员工，从而模拟奖品的分发，当然中奖是随机的。</p><p>需求二，用户通过关注易信号，获取进入员工绑定页面的图文消息（这里面有个操作就是易信号的openid与员工信息的绑定），同时通过回复关键词获取自己的序号，。不仅如此，员工余下的操作都是在易信打开的页面完成的。</p><p>上述就是主要的两个需求点。</p></blockquote><h4 id="关于websocket"><a href="#关于websocket" class="headerlink" title="关于websocket"></a>关于websocket</h4><p>摘自 <span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvV2ViU29ja2V0" title="https://zh.wikipedia.org/wiki/WebSocket">维基百科<i class="fa fa-external-link"></i></span></p><h5 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h5><blockquote><p>WebSocket一种在单个TCP连接上进行全双工通讯的协议。</p><p>WebSocket通信协议于2011年被IETF定为标准RFC 6455，并被RFC7936所补充规范。WebSocket API也被W3C定为标准。</p><p>WebSocket 使得客户端和服务器之间的数据交换变得更加简单，<strong>允许服务端主动向客户端推送数据</strong>。在 WebSocket API 中，浏览器和服务器<strong>只需要完成一次握手</strong>，两者之间就直接可以创建持久性的连接，并进行<strong>双向数据传输</strong>。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">客户端请求</span><br><span class="line">GET / HTTP/1.1</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Host: example.com</span><br><span class="line">Origin: http://example.com</span><br><span class="line">Sec-WebSocket-Key: sN9cRrP/n9NdMgdcy2VJFQ==</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">服务器回应</span><br><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: fFBooB7FAkLlXgRSz0BT3v4hq5s=</span><br><span class="line">Sec-WebSocket-Location: ws://example.com/</span><br></pre></td></tr></table></figure><h5 id="与及其他技术的比较"><a href="#与及其他技术的比较" class="headerlink" title="与及其他技术的比较"></a>与及其他技术的比较</h5><blockquote><p>现在，很多网站为了实现推送技术，所用的技术都是轮询。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。</p><p>而比较新的技术去做轮询的效果是Comet。这种技术虽然可以双向通信，但依然需要反复发出请求。而且在Comet中，普遍采用的长链接，也会消耗服务器资源。</p><p>Websocket使用ws或wss的统一资源标志符，类似于HTTPS，其中wss表示在TLS之上的Websocket。</p><p>优点：</p><ol><li><blockquote><p>较少的控制开销。在连接创建后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对较小。在不包含扩展的情况下，对于服务器到客户端的内容，此头部大小只有2至10字节（和数据包长度有关）；对于客户端到服务器的内容，此头部还需要加上额外的4字节的掩码。相对于HTTP请求每次都要携带完整的头部，此项开销显著减少了。</p></blockquote></li><li><blockquote><p>更强的实时性。由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少；即使是和Comet等类似的长轮询比较，其也能在短时间内更多次地传递数据。</p></blockquote></li><li><blockquote><p>保持连接状态。于HTTP不同的是，Websocket需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息。而HTTP请求可能需要在每个请求都携带状态信息（如身份认证等）。</p></blockquote></li><li><blockquote><p>更好的二进制支持。Websocket定义了二进制帧，相对HTTP，可以更轻松地处理二进制内容。</p></blockquote></li><li><blockquote><p>可以支持扩展。Websocket定义了扩展，用户可以扩展协议、实现部分自定义的子协议。如部分浏览器支持压缩等。</p></blockquote></li><li><blockquote><p>更好的压缩效果。相对于HTTP压缩，Websocket在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率。</p></blockquote></li></ol></blockquote><h4 id="关于一些坑和事故"><a href="#关于一些坑和事故" class="headerlink" title="关于一些坑和事故"></a>关于一些坑和事故</h4><blockquote><p><strong>问题一</strong>：在本地进行性能测试的时候，chrome连接到250左右个websocket的时候出现连接错误。</p></blockquote><p>原因是：谷歌浏览器 最多支持250个websocket连接。</p><blockquote><p><strong>问题二</strong>：建立大量socket连接时，出现connection refused。</p></blockquote><p>原因是：tomcat的配置文件server.xml里有两个参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;</span><br><span class="line">               connectionTimeout=&quot;20000&quot;</span><br><span class="line">               redirectPort=&quot;8443&quot;</span><br><span class="line">               maxThreads=&quot;800&quot; acceptCount=&quot;1000&quot;/&gt;</span><br></pre></td></tr></table></figure><p>其中最后两个参数意义如下：</p><p>maxThreads：tomcat起动的最大线程数，即同时处理的任务个数，默认值为200</p><p>acceptCount：当tomcat起动的线程数达到最大时，接受排队的请求个数，默认值为100</p><p>后来我设置这两个参数我都设置成1500。然后本地测试 建立连接后， 服务器 cpu 大概在60%-70%</p><blockquote><p><strong>问题三</strong>：在最后实际上线的时候，650+同时建立websocket连接，服务器cpu到达300%。无法进行访问。</p></blockquote><p>这个问题我没有办法。后来谷歌了一些资料，同时也请教了一些同学。知道自己要改进的地方还有很多：</p><blockquote><p>下面贴一下Tomcat 的三种(bio,nio.apr) 高级 Connector 运行模式，来自于网络。</p></blockquote><p>1)bio </p><blockquote><p>默认的模式,性能非常低下,没有经过任何优化处理和支持. </p></blockquote><p>2)nio </p><blockquote><p>利用java的异步io护理技术,no blocking IO技术.<br>想运行在该模式下，直接修改server.xml里的Connector节点</p><p><connector port="80" protocol="org.apache.coyote.http11.Http11NioProtocol"><br>启动后,就可以生效。 </connector></p></blockquote><p>3)apr </p><blockquote><p>修改protocol为org.apache.coyote.http11.Http11AprProtocol。<br>需要安装，从操作系统级别来解决异步的IO问题,大幅度的提高性能。<br>如果不用APR，一个线程同一时间只能处理一个用户，势必会造成阻塞。所以生产环境下 用apr是非常必要的。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">安装APR</span><br><span class="line">#apr-1.3.8.tar.gz</span><br><span class="line">#tar zxvf apr-1.3.8.tar.gz</span><br><span class="line">#cd apr-1.3.8</span><br><span class="line">#./configure</span><br><span class="line">#make</span><br><span class="line">#make install</span><br><span class="line">安装在/usr/local/apr</span><br><span class="line"></span><br><span class="line">#apr-util-1.3.9.tar.gz</span><br><span class="line">#tar zxvf apr-util-1.3.9.tar.gz</span><br><span class="line">#cd apr-util-1.3.9 </span><br><span class="line">#./configure --with-apr=/usr/local/apr </span><br><span class="line">#make </span><br><span class="line">#make install </span><br><span class="line">安装在/usr/local/apr/lib</span><br><span class="line"></span><br><span class="line">安装 tomcat-native</span><br><span class="line">#cd /usr/local/tomcat5.5/bin </span><br><span class="line">#tar zxvf tomcat-native.tar.gz </span><br><span class="line">#cd tomcat-native-1.1.3/jni/native </span><br><span class="line">#./configure --with-apr=/usr/local/apr</span><br><span class="line">#make </span><br><span class="line">#make install</span><br></pre></td></tr></table></figure><p><strong>==WARNING:==</strong><br>生产使用</p><p>虽然WebSocket实现可以与任何HTTP连接器一起工作，但是<strong>不推荐WebSocket和BIO HTTP连接器配合使用</strong>。因为WebSocket的典型使用并不适合HTTP BIO连接器，HTTP BIO 连接器要求为每个连接分配一个线程，而不管是否有空闲的连接。</p><blockquote><p>据报告(56304)，Linux会花费大量时间来报告丢掉的连接。当以BIO HTTP连接器使用WebSocket时，这可能会导致该时段内写入出现阻塞。这似乎是不可取的。通过使用内核网络参数/proc/sys/net/ipv4/tcp_retries2，可以减少因连接丢失所花费的报告时间。此外，他们使用了非阻塞IO，可以让Tomcat实现自己的超时机制从而处理这些情况，你也可以使用其他的HTTP连接器。</p></blockquote><p>同时，<strong>有同学指出</strong>：<br>tomcat 里有相关的websocket的配置参数，我查了一下 ，确实如此：</p><blockquote><p>Java WebSocket 1.0 规范要求在一个不同的线程上执行到发起写入的线程的异步写入回调。<br>由于容器线程池不是通过Servlet API被暴露，因此WebSocket实现必须提供自己的线程池。该线程池可以通过下列servlet context初始化参数被控制：</p></blockquote><p>org.apache.tomcat.websocket.executorCoreSize</p><blockquote><p>executor线程池的核心大小。如果不设置，则默认为0。</p></blockquote><p>org.apache.tomcat.websocket.executorMaxSize</p><blockquote><p>executor线程池所允许的最大值。如果不设置，则默认为200。</p></blockquote><p>org.apache.tomcat.websocket.executorKeepAliveTimeSeconds</p><blockquote><p>executor线程池中空闲进程所保留的最大时间。如果未指定，则默认为60秒。</p></blockquote><p>那么设置方法如何呢？<br>web.xml中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--websocket executor 线程池的核心容量大小 --&gt;</span><br><span class="line">&lt;context-param&gt;</span><br><span class="line">&lt;param-name&gt;org.apache.tomcat.websocket.executorCoreSize&lt;/param-name&gt;</span><br><span class="line">&lt;param-value&gt;200&lt;/param-value&gt;</span><br><span class="line">&lt;/context-param&gt;</span><br><span class="line">&lt;!--websocket executor 线程池的最大容量大小 --&gt;</span><br><span class="line">&lt;context-param&gt;</span><br><span class="line">&lt;param-name&gt;org.apache.tomcat.websocket.executorMaxSize&lt;/param-name&gt;</span><br><span class="line">&lt;param-value&gt;1000&lt;/param-value&gt;</span><br><span class="line">&lt;/context-param&gt;</span><br></pre></td></tr></table></figure><h4 id="关于Linux的优化网络，修改-etc-sysctl-cnf文件"><a href="#关于Linux的优化网络，修改-etc-sysctl-cnf文件" class="headerlink" title="关于Linux的优化网络，修改/etc/sysctl.cnf文件"></a>关于Linux的优化网络，修改/etc/sysctl.cnf文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1. 修改/etc/sysctl.cnf文件，在最后追加如下内容： </span><br><span class="line"> </span><br><span class="line">net.core.netdev_max_backlog = 32768 </span><br><span class="line">net.core.somaxconn = 32768 </span><br><span class="line">net.core.wmem_default = 8388608 </span><br><span class="line">net.core.rmem_default = 8388608 </span><br><span class="line">net.core.rmem_max = 16777216 </span><br><span class="line">net.core.wmem_max = 16777216 </span><br><span class="line">net.ipv4.ip_local_port_range = 1024 65000 </span><br><span class="line">net.ipv4.route.gc_timeout = 100 </span><br><span class="line">net.ipv4.tcp_fin_timeout = 30 </span><br><span class="line">net.ipv4.tcp_keepalive_time = 1200 </span><br><span class="line">net.ipv4.tcp_timestamps = 0 </span><br><span class="line">net.ipv4.tcp_synack_retries = 2 </span><br><span class="line">net.ipv4.tcp_syn_retries = 2 </span><br><span class="line">net.ipv4.tcp_tw_recycle = 1 </span><br><span class="line">net.ipv4.tcp_tw_reuse = 1 </span><br><span class="line">net.ipv4.tcp_mem = 94500000 915000000 927000000 </span><br><span class="line">net.ipv4.tcp_max_orphans = 3276800 </span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 65536 </span><br><span class="line"> </span><br><span class="line">2. 保存退出，执行sysctl -p生效</span><br></pre></td></tr></table></figure><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><blockquote><p>后来SA建议我说对于高并发，一定得测试，然后调整参数。<br>本篇博客 还会再做修正。同时简单介绍下易信/微信的接口开发。</p></blockquote><h4 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h4><ul><li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3VwZXJfbWFyaW9saS9hcnRpY2xlL2RldGFpbHMvMjcyNDA2Mzk=" title="http://blog.csdn.net/super_marioli/article/details/27240639">tomcat优化-有改protocol 和 缓存 集群方案<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGlsbHMvYXJ0aWNsZS9kZXRhaWxzLzM5MzY4OTUx" title="http://blog.csdn.net/hills/article/details/39368951">Apache Tomcat 8 WebSocket How-To 中文翻译版<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvV2ViU29ja2V0" title="https://zh.wikipedia.org/wiki/WebSocket">websocket维基百科<i class="fa fa-external-link"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9seWhlcm8xMS9wLzYxMjQyNzEuaHRtbA==" title="http://www.cnblogs.com/lyhero11/p/6124271.html">Tomcat 7.x/8.x 优化<i class="fa fa-external-link"></i></span></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的使用小结</title>
      <link href="/2016/11/26/Redis%E7%9A%84%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/"/>
      <url>/2016/11/26/Redis%E7%9A%84%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言：之前的系统需要将数据库中的数据，作为List放到缓存里，然后由两台服务器取访问缓存。这个操作用Memcached非常之不方便，因为Memcached没有支持那么多数据结构。故上周五将redis加入到系统中，今天做个小结~</p></blockquote><a id="more"></a><h4 id="Redis的介绍"><a href="#Redis的介绍" class="headerlink" title="Redis的介绍"></a>Redis的介绍</h4><blockquote><p>以下两段介绍 摘自 百度百科，将redis的优点说的比较清晰。</p><p>redis是一个key-value存储系统。和Memcached类似，它支持存储的<strong>value类型相对更多</strong>，包括string(字符串)、list(链表)、set(集合)、zset(sorted set —有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是<strong>redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件</strong>，并且在此基础上实现了master-slave(主从)同步。</p><p>Redis 是一个高性能的key-value数据库。 redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部 分场合可以对关系数据库起到很好的补充作用。它提供了Java，C/C++，C#，PHP，JavaScript，Perl，Object-C，Python，Ruby，Erlang等客户端，使用很<strong>方便</strong>。</p></blockquote><h4 id="Redis的下载"><a href="#Redis的下载" class="headerlink" title="Redis的下载"></a>Redis的下载</h4><blockquote><p>下载地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL01TT3BlblRlY2gvcmVkaXMvcmVsZWFzZXPjgII=" title="https://github.com/MSOpenTech/redis/releases。">https://github.com/MSOpenTech/redis/releases。<i class="fa fa-external-link"></i></span></p></blockquote><h4 id="Redis-服务的安装开启"><a href="#Redis-服务的安装开启" class="headerlink" title="Redis 服务的安装开启"></a>Redis 服务的安装开启</h4><p>(参考 自 菜鸟教程)</p><p>Windows下</p><blockquote><ol><li>cmd 进入Redis的安装目录</li><li>在指令上输入 redis-server.exe redis.windows.conf</li><li>另启一个cmd窗口，原来的不要关闭，不然就无法访问服务端了。<br>切换到redis目录下运行 redis-cli.exe -h 127.0.0.1 -p 6379 。</li></ol></blockquote><p>Linux 下安装</p><blockquote><p>下载地址：<span class="exturl" data-url="aHR0cDovL3JlZGlzLmlvL2Rvd25sb2Fk77yM5LiL6L295pyA5paw5paH5qGj54mI5pys44CC" title="http://redis.io/download，下载最新文档版本。">http://redis.io/download，下载最新文档版本。<i class="fa fa-external-link"></i></span></p><p>$ wget <span class="exturl" data-url="aHR0cDovL2Rvd25sb2FkLnJlZGlzLmlvL3JlbGVhc2VzL3JlZGlzLTIuOC4xNy50YXIuZ3o=" title="http://download.redis.io/releases/redis-2.8.17.tar.gz">http://download.redis.io/releases/redis-2.8.17.tar.gz<i class="fa fa-external-link"></i></span></p><p>$ tar xzf redis-2.8.17.tar.gz</p><p>$ cd redis-2.8.17</p><p>$ make</p><p>make完后 redis-2.8.17目录下会出现编译后的redis服务程序redis-server,还有用于测试的客户端程序redis-cli,两个程序位于安装目录 src 目录下：</p><p>下面启动redis服务.</p><p>$ cd src</p><p>$ ./redis-server</p><p>注意这种方式启动redis 使用的是默认配置。也可以通过启动参数告诉redis使用指定配置文件使用下面命令启动。</p><p>$ cd src</p><p>$ ./redis-server redis.conf</p><p>redis.conf是一个默认的配置文件。我们可以根据需要使用自己的配置文件。<br>启动redis服务进程后，就可以使用测试客户端程序redis-cli和redis服务交互了。 比如：</p><p>$ cd src</p><p>$ ./redis-cli</p><p>redis&gt; set foo bar</p><p>redis&gt; get foo</p></blockquote><h4 id="如何将Redis融入Java-Springmvc"><a href="#如何将Redis融入Java-Springmvc" class="headerlink" title="如何将Redis融入Java(Springmvc)"></a>如何将Redis融入Java(Springmvc)</h4><h5 id="Maven依赖-新增"><a href="#Maven依赖-新增" class="headerlink" title="Maven依赖(新增)"></a>Maven依赖(新增)</h5><pre><code>&lt;properties&gt;    &lt;spring-data-redis.version&gt;1.5.0.RELEASE&lt;/spring-data-redis.version&gt;&lt;/properties&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;    &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;    &lt;version&gt;${spring-data-redis.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;redis.clients&lt;/groupId&gt;    &lt;artifactId&gt;jedis&lt;/artifactId&gt;    &lt;version&gt;2.7.3&lt;/version&gt;&lt;/dependency&gt;</code></pre><h5 id="新增配置文件"><a href="#新增配置文件" class="headerlink" title="新增配置文件"></a>新增配置文件</h5><pre><code>redis.properties 用于存放redis的相关参数applicationContext-redis-context.xml 用于实现redis相关的注入</code></pre><p>[redis.properties]</p><ul><li>redis.host=127.0.0.1</li><li>redis.port=6379</li><li>redis.pass=</li><li>redis.timeout=2000</li><li>redis.maxTotal=100</li><li>redis.maxIdle=8</li><li>redis.minIdle=8</li><li>redis.masterName=</li><li>redis.sentinels=</li></ul><p>[redis.properties]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line">       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">       http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">      http://www.springframework.org/schema/tx</span><br><span class="line">      http://www.springframework.org/schema/tx/spring-tx.xsd</span><br><span class="line">       http://www.springframework.org/schema/context</span><br><span class="line">       http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">       &lt;!-- scanner redis properties  --&gt;</span><br><span class="line">    &lt;context:property-placeholder location=&quot;redis.properties&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;jedisPoolConfig&quot; class=&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;maxTotal&quot; value=&quot;$&#123;redis.maxTotal&#125;&quot;/&gt; &lt;!-- 控制一个pool可分配多少个jedis实例 --&gt;</span><br><span class="line">        &lt;property name=&quot;maxIdle&quot; value=&quot;$&#123;redis.maxIdle&#125;&quot;/&gt;&lt;!-- 最大能够保持idel状态的对象数 --&gt;</span><br><span class="line">        &lt;property name=&quot;minIdle&quot; value=&quot;$&#123;redis.minIdle&#125;&quot;/&gt;&lt;!-- 最大能够保持idel状态的对象数 --&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;jedisConnectionFactory&quot;</span><br><span class="line">          class=&quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&quot;&gt;</span><br><span class="line">        &lt;constructor-arg ref=&quot;jedisPoolConfig&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;hostName&quot; value=&quot;$&#123;redis.host&#125;&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;port&quot; value=&quot;$&#123;redis.port&#125;&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;password&quot; value =&quot;$&#123;redis.pass&#125;&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;timeout&quot; value =&quot;$&#123;redis.timeout&#125;&quot; /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--&lt;bean id=&quot;redisTemplate&quot; class=&quot;org.springframework.data.redis.core.StringRedisTemplate&quot;&gt;--&gt;</span><br><span class="line">    &lt;bean id=&quot;redisTemplate&quot; class=&quot;org.springframework.data.redis.core.RedisTemplate&quot;&gt;</span><br><span class="line">              &lt;property name=&quot;connectionFactory&quot;   ref=&quot;jedisConnectionFactory&quot; /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h5 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h5><blockquote><p>建立Service</p><p>注：Coupon是我的实体类 需要 implements Serializable</p><p>RedisService是Redis服务公共接口</p><p>AbstractRedisService 是抽象的公共实现</p><p>RedisCouponServiceImpl 是具体实现</p></blockquote><p>层次结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Service(&quot;redisCouponService&quot;)</span><br><span class="line">public class RedisCouponServiceImpl&lt;String,Coupon&gt; extends AbstractRedisService&lt;String,Coupon&gt; implements RedisService&lt;String,Coupon&gt; &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>具体代码如下：</p><p>[RedisService]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public interface RedisService&lt;K,V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public void setKeyAndValue(K key, V value);</span><br><span class="line"></span><br><span class="line">    public void setKeyAndValueWithTime(K key, V value, Long time, TimeUnit unit);</span><br><span class="line"></span><br><span class="line">    public V getValue(K key);</span><br><span class="line"></span><br><span class="line">    public void rPushList(K key, V value);</span><br><span class="line"></span><br><span class="line">    public V lPopList(K key);</span><br><span class="line"></span><br><span class="line">    public void delKey(K key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[AbstractRedisService]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractRedisService&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    protected RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    // 设置redisTemplate</span><br><span class="line">    public void setRedisTemplate(RedisTemplate&lt;K, V&gt; redisTemplate) &#123;</span><br><span class="line">        this.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public RedisTemplate&lt;K, V&gt; getRedisTemplate() &#123;</span><br><span class="line">        return redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setKeyAndValue(K key, V value) &#123;</span><br><span class="line">        getRedisTemplate().opsForValue().set(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     //有过期时间的set</span><br><span class="line">    public void setKeyAndValueWithTime(K key, V value, Long time, TimeUnit unit) &#123;</span><br><span class="line">        getRedisTemplate().opsForValue().set(key, value, time, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public V getValue(K key) &#123;</span><br><span class="line">        return getRedisTemplate().opsForValue().get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void rPushList(K key, V value) &#123;</span><br><span class="line">        getRedisTemplate().opsForList().rightPush(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public V lPopList(K key) &#123;</span><br><span class="line">        return getRedisTemplate().opsForList().leftPop(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void delKey(K key) &#123;</span><br><span class="line">        getRedisTemplate().delete(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h5><p>使用带过期时间的使用，这里过期时间是20秒</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(&#123; &quot;/applicationContext-dao.xml&quot;,</span><br><span class="line">    &quot;/applicationContext-service.xml&quot;,</span><br><span class="line">    &quot;/applicationContext-service-lmswitch.xml&quot;,</span><br><span class="line">    &quot;/applicationContext-redis-context.xml&quot;&#125;</span><br><span class="line">)</span><br><span class="line">public class RedisServiceTest &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisService&lt;String,Coupon&gt; redisCouponService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testRedisListTime()&#123;</span><br><span class="line"></span><br><span class="line">        Coupon coupon = new Coupon();</span><br><span class="line">        coupon.setId(1);</span><br><span class="line">        coupon.setCodeType(1);</span><br><span class="line">        coupon.setCouponCode(&quot;FD1111&quot;);</span><br><span class="line"></span><br><span class="line">        redisCouponService.setKeyAndValueWithTime(&quot;test&quot;, coupon, 20L, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testRedisListTimeGet()&#123;</span><br><span class="line">        Coupon coupon = (Coupon) redisCouponService.getValue(&quot;test&quot;);</span><br><span class="line">        if (coupon != null) &#123;</span><br><span class="line">            System.out.println(coupon.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h4><blockquote><p>目前，我自己测试通过。以后具体会遇到哪些坑，我会边填边走~~</p><p>Go 且行且尝试</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的秒杀总结</title>
      <link href="/2016/11/24/%E6%88%91%E7%9A%84%E7%A7%92%E6%9D%80%E6%80%BB%E7%BB%93/"/>
      <url>/2016/11/24/%E6%88%91%E7%9A%84%E7%A7%92%E6%9D%80%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>近期 接到一个十万数量的秒杀任务，后台完全由我写。因为之前对秒杀的处理所知甚少，故趁此机会学习了一下。当然，这里 秒杀 只涉及到 “抢” 的环节，没有下单、支付等，故对性能要求不是那么高。最终，“跌跌撞撞”地还是让系统上线了，目前运行良好。</p></blockquote><a id="more"></a><h4 id="项目环境"><a href="#项目环境" class="headerlink" title="项目环境"></a>项目环境</h4><blockquote><p>两台业务的服务器，还有一台缓存服务器和一台数据库服务器。<br>在整个项目 的 前端部分 自然离不开 负载均衡。故 这里 还是采用 Nginx 来实现。具体方式采用默认的配置，即轮询的方式。</p></blockquote><h4 id="关于“抢”的环节"><a href="#关于“抢”的环节" class="headerlink" title="关于“抢”的环节"></a>关于“抢”的环节</h4><blockquote><p>intro：一天分为几个时段开抢，每个时段有几分钟的时间抢（该时段的奖品抢完了或者时间到了，该时段抢购就结束了），对于没有抢完的奖品，要求自动“滚到”下一轮。</p><p>为了满足如上要求，自然得从数据库开始设计。在系统运行前，将十万奖品 批量输入 至数据库。我给 所有奖品 设计了一个<strong>生效时间</strong> 和一个 <strong>是否被抢</strong> 的标志。</p><p>这里我采用的技巧是（<strong>解决方案</strong>）：<br>每个奖品 都有一个生效时间，这个生效时间是每个时间段的开始时间，只有当前时间大于生 效时间该奖品才可以抢（具体可以用sql控制，这里时间采用ms，时间越往后时间越大）。</p><p>再 声明 一下抢奖品的<strong>策略</strong>：只有当前时间大于奖品的生效时间，该奖品才可以抢。这样设计解决了对于后面的几轮秒杀可以秒杀到之前没抢完的奖品（因为后面几轮的当前时间大于前面奖品的生效时间）的要求。同时 ，又可以避免 前一时段的秒杀环节 抢到 后面时段的奖品。原因自然是 当前时间比后面几轮的生效时间小。</p><p>性能方面：为了避免每一次都要去数据库查取符合条件的奖品（生效时间和是否被抢），++我自然需要将奖品一次性地多拿几个放到内存里++。这里 我使用 队列 来存放 符合条件的奖品，每来一个用户，抢走（弹出）队列头部的奖品。后面的用户来了 再弹出一个。从而避免 用户“同时”拿到同一个奖品，从而避免“超卖”现象。</p><p>那么队列我具体采用什么样的数据结构呢？如下<br>基于链接节点的无界线程安全队列（这个名字很霸气~~）</p></blockquote><pre><code>    private static volatile Queue&lt;Coupon&gt; couponQueue;    static{        if (null == couponQueue) {            LOG.info(&quot;QueueServiceImpl init!!&quot;);            couponQueue = new ConcurrentLinkedQueue&lt;Coupon&gt;();             }    }</code></pre><blockquote><p>具体弹出采用什么代码呢？</p></blockquote><pre><code>@Overridepublic  Coupon getPoll(String uid) {    Coupon coupon = null;    synchronized(this){        coupon = couponQueue.poll();        if (coupon == null) {            setQueue();//从数据库里取奖品放入队列的方法            coupon = couponQueue.poll();        }        if (coupon!=null){            int row =  couponDao.allocateCoupon(coupon.getId(),uid,CouponConst.Status.USED,System.currentTimeMillis());            if (row!=1){                coupon = null;            }        }    }    //打日志    if (coupon!=null) {        LOG.info(                &quot;getPoll uid:{},couponId:{}&quot;,                new Object[]{uid, coupon.getId()});    }    return coupon;}</code></pre><blockquote><p>这里有个synchronized，是为了线程安全，避免多个人访问同一段代码产生冲突。<br>那么为什么把“弹出”（如果内存队列里没有了，还会去数据库里一次性取100奖品来放入内存）和update奖品是否被抢状态的代码同时锁住呢？</p><p>试想这样一种<strong>场景</strong>：内存里原本放100个奖品的队列，经过一段时间后还剩下两个奖品。此时，甲、乙两个用户过来弹出了最后的两个奖品，还未来的及修改奖品状态。此时此刻，丙冲了过来，结果发现队列里没有了，coupon==null，就去setQueue()从数据库里拿符合条件的100个奖品放入内存队列。然而！，甲乙还没来得及将其抢到的奖品修改状态，就是说这两个奖品还没有被标记已经抢过。所以 这两个奖品又会被丙放入内存队列，接着弹出！由后来者再去抢。从而造成一种现象，最后的奖品被多个用户抢到，从而形成冲突。解决方案：加锁！</p><p>是不是这样就可以了呢？？</p><p>回答是No！因为我在学校 一般都写的是 一个业务服务器，这里是两个！亲，两个和一个有着巨大差别，这是放在内存里，不是缓存服务器里。所以A服务器取了100个符合条件的奖品，B服务器也取了100个符合条件的奖品，然而！，A和B可能取得都是前100个奖品，就是说，这俩服务器取得是相同的奖品，然后进行发放！怎么办呢？？</p><p><strong>解决方案</strong>：我首先想到的是将奖品队列放入缓存服务器（1台）里？这样就避免冲突。可是 缓存 用的是 xmemcached，不是redis！没法支持那么多数据结构，而且xmemcached的CAS用起来并不舒服，，，<br>那么，该怎么处理呢~上代码：</p></blockquote><pre><code>    int flag = -1 ;//因为 线上有两台服务器， 所以 为避免两台服务器 取 相同的 coupon 放入自己的内存；故采用 id%2==flag 分开。</code></pre><p>​<br>        int ip = LocalIPGetter.getLocalServerIpTail(); //获取当前服务器ip<br>        if (ip == 223) { //如果是A服务器 取id为奇数的奖品放入内存队列<br>            flag = 1;<br>        }else {         //如果是B服务器 取id为偶数的奖品放入内存队列<br>            flag = 0;<br>        }</p><pre><code>    List&lt;Coupon&gt; couponList = couponDao.selectByStatusValidate(CouponConst.Status.INIT,current,100,flag); //两台服务器根据奇偶数进行分类去数据库取奖品。</code></pre><blockquote><p>上述代码就是我的解决思路,是不是太简单了点，把数据库表分成两块，两个服务器互不干扰。</p><p>还有缓存服务器，我将获奖者名单放在里面，减少对数据库的访问。</p></blockquote><h4 id="关于“抢”的环节-多次点击问题"><a href="#关于“抢”的环节-多次点击问题" class="headerlink" title="关于“抢”的环节 多次点击问题"></a>关于“抢”的环节 多次点击问题</h4><blockquote><p>我遇到这样一个问题（一位用户只能秒杀成功一次）：</p><p>试想这样一个<strong>场景</strong>，对于某用户甲，点击了“秒杀”按钮。但是由于网速、性能等原因，用户甲比较着急，连续点了好几次。</p><p>当第一次请求发来时：数据库里没有该用户的记录，资格认证，发现没有秒杀记录，将要添加用户，想进入秒杀流程。注意：这里是将要，还没有添加用户。此刻！！！<br>该用户的第二次点击请求发了过来，资格认证，发现没有秒杀记录，将要添加用户。然而！！！第一次请求添加用户成功，第二次请求又来添加，数据库主键冲突！500！</p><p><strong>解决方案</strong>：<br>每次点击，收到请求检查缓存没有该账户信息，第一件事放入 缓存(key值为其账户主键)中，同时设置2s后失效。<br>如果 缓存中 有该账户信息，说明 2s 内该用户 访问过，返回411，访问过于频繁。<br>OK</p></blockquote><h4 id="疏忽！"><a href="#疏忽！" class="headerlink" title="疏忽！"></a>疏忽！</h4><blockquote><p>在活动开始的前一天，QA正在火急火燎地测试。自然，线上测试用的是测试数据，奖品的中奖码都是模拟的。注意，我说的是线上测试。<br>晚上，22:00测试完毕。我把数据库里的数据库变成真实数据，就屁颠屁颠地回家了。</p><p>我想说的是，然而！！！两台业务服务器里的两个奖品队列还是测试的模拟数据，然后我就，，，这个坑，，，<br>切记<br>切记，清空缓存，清空内存<br>重要事情说三遍，清空缓存，清空内存。<br>情空缓存，清空内存</p></blockquote><h4 id="后续的想法"><a href="#后续的想法" class="headerlink" title="后续的想法"></a>后续的想法</h4><blockquote><p>我能不能将抽取、改变状态的 流程 写在数据库里，作为存储过程来调用会不会更快？？<br>然后我就开始写存储过程，，，，</p><p>然而！！！后来DBA告诉我：</p><p>存储过程 与 触发器 都不允许。<br>计算尽量不要放在数据库来,<br>数据库主要完成数据存取的功能。</p><p>如果我这么做，有可能会导致数据库死锁，，，，</p></blockquote><h4 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h4><blockquote><p>我想我如果再写秒杀系统的话 自然会做的更好，以上都是我自己的摸索。后续我会尝试 消息队列（Notify？MetaQ？），用redis？什么有损服务？什么熔断机制？</p><p>继续探索吧~</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于JSONP的原理</title>
      <link href="/2016/10/15/%E5%85%B3%E4%BA%8EJSONP%E7%9A%84%E5%8E%9F%E7%90%86/"/>
      <url>/2016/10/15/%E5%85%B3%E4%BA%8EJSONP%E7%9A%84%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>由于前端需要用jsonp的格式，之前没用过。特此在网上查了一下，并把学习的内容和大家分享一下。</p></blockquote><a id="more"></a><h4 id="Json与Jsonp"><a href="#Json与Jsonp" class="headerlink" title="Json与Jsonp"></a>Json与Jsonp</h4><ul><li><p>json</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">什么是json：</span><br><span class="line">Json 是一种基于文本的数据描述格式。</span><br><span class="line">    1. 基于纯文本，跨平台传递极其简单；</span><br><span class="line">    2. Javascript原生支持，后台语言几乎全部支持；</span><br><span class="line">    3. 轻量级数据格式，占用字符数量极少，特别适合互联网传递；</span><br><span class="line">    4. 可读性较强(合理的依次缩进之后)；</span><br><span class="line">    5. 容易编写和解析；</span><br><span class="line"></span><br><span class="line">json的格式：</span><br><span class="line">    1. JSON只有两种数据类型描述符，大括号&#123;&#125;和方括号[]，其余英文冒号:是映射符，英文逗号,是分隔符，英文双引号&quot;&quot;是定义符。</span><br><span class="line">    2. 大括号&#123;&#125;用来描述一组“不同类型的无序键值对集合”（每个键值对可以理解为OOP的属性描述），方括号[]用来描述一组“相同类型的有序数据集合”（可对应OOP的数组）。</span><br><span class="line">    3. 上述两种集合中若有多个子项，则通过英文逗号,进行分隔。</span><br><span class="line">    4. 键值对以英文冒号:进行分隔，并且建议键名都加上英文双引号”，以便于不同语言的解析。</span><br><span class="line">    5. JSON内部常用数据类型无非就是字符串、数字、布尔、日期、null，字符串必须用双引号引起来。</span><br><span class="line">　　JSON实例：</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;cheng&quot;,</span><br><span class="line">        &quot;Age&quot;: 24</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>jsonp</p></li></ul><blockquote><p>关于jsonp：我的理解是jsonp是一种借用json作为参数的 数据交换方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">引入：</span><br><span class="line">    1. Ajax直接请求普通文件存在跨域无权限访问的问题。（JavaScript出于安全方面的考虑，不允许跨域调用其他页面的对象。eg：a.com 域名下的js无法操作b.com或是c.a.com域名下的对象。）</span><br><span class="line">    2. 但是，Web页面上调用js文件时则不受是否跨域的影响(具有src属性的标签都具有跨域的能力，iframe，image，script)</span><br><span class="line">    3. 所以,那就是在远程服务器上设法把数据（以json的格式）装进&lt;script&gt;的标签里，供前端处理。</span><br><span class="line">    4. 为了便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP。</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="代码原理示例"><a href="#代码原理示例" class="headerlink" title="代码原理示例"></a>代码原理示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;</span><br><span class="line">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var localHandler = function(data)&#123;</span><br><span class="line">        alert(&apos;我是本地函数，远程js带来的数据是：&apos; + data.result);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &lt;script type=&quot;text/javascript&quot; src=&quot;http://remoteserver.com/remote.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>服务器有个文件remote.js文件代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localHandler(&#123;&quot;result&quot;:&quot;我是远程js带来的数据&quot;&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">相当于服务器的文件remote.js里的localHandler(xxxx)触发了前端的localHandler(data)去执行。</span><br><span class="line">那么问题来了，服务器的文件remote.js是如何知道去调用前端的哪个函数呢？</span><br><span class="line">so，前端需要把函数名用get的方式?callback=localHandler传给服务器。</span><br><span class="line">服务器知道函数名称返回数据：localHandler(&#123;&quot;result&quot;:&quot;我是远程js带来的数据&quot;&#125;)。</span><br><span class="line">客户端接到数据（其实这数据就是一段代码）成功之后，把它放入&lt;script&gt;中执行即可。</span><br><span class="line"></span><br><span class="line">其实关于客户端的这些步骤jquery都封装好了。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"> jQuery(document).ready(function()&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">         type: &quot;get&quot;,</span><br><span class="line">         async: false,</span><br><span class="line">         url: &quot;http://flightQuery.com/jsonp/flightResult.aspx&quot;,</span><br><span class="line">         dataType: &quot;jsonp&quot;,</span><br><span class="line">         jsonp: &quot;callback&quot;,//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback)</span><br><span class="line">         jsonpCallback:&quot;flightHandler&quot;,//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写&quot;?&quot;，jQuery会自动为你处理数据</span><br><span class="line">         success: function(json)&#123;</span><br><span class="line">             alert(&apos;你的名字&apos; + json.name);</span><br><span class="line">         &#125;,</span><br><span class="line">         error: function()&#123;</span><br><span class="line">             alert(&apos;fail&apos;);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line"> &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>这里， jQuery可以自动生成的随机函数名。我会有个大大的疑问，类似与localHandler的回调函数我并没有写啊。其实，善解人意的jquery自动帮我生成回调函数并把数据取出来供success属性方法来调用。</p><p>至此，jsonp的机制原理我就全明白了。</p><p>上述资源、思想来源于互联网。</p></blockquote><p>感谢</p><p><span class="exturl" data-url="aHR0cDovL2tiLmNuYmxvZ3MuY29tL3BhZ2UvMTM5NzI1Lw==" title="http://kb.cnblogs.com/page/139725/">http://kb.cnblogs.com/page/139725/<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5qYjUxLm5ldC9hcnRpY2xlLzQ2NDYzLmh0bQ==" title="http://www.jb51.net/article/46463.htm">http://www.jb51.net/article/46463.htm<i class="fa fa-external-link"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9yYWlubWFuL2FyY2hpdmUvMjAxMS8wMi8yMC8xOTU5MzI1Lmh0bWw=" title="http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html">http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html<i class="fa fa-external-link"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实习两周技术回顾</title>
      <link href="/2016/10/08/%E5%AE%9E%E4%B9%A0%E4%B8%A4%E5%91%A8%E6%8A%80%E6%9C%AF%E5%9B%9E%E9%A1%BE/"/>
      <url>/2016/10/08/%E5%AE%9E%E4%B9%A0%E4%B8%A4%E5%91%A8%E6%8A%80%E6%9C%AF%E5%9B%9E%E9%A1%BE/</url>
      
        <content type="html"><![CDATA[<blockquote><p>实习小记录，做个技术的简单总结。</p></blockquote><a id="more"></a><h4 id="关于日志文件"><a href="#关于日志文件" class="headerlink" title="关于日志文件"></a>关于日志文件</h4><p>intro：</p><blockquote><p>SLF4J不同于其他日志类库，与其它有很大的不同。<br>SLF4J(Simple logging Facade for Java)不是一个真正的日志实现，而是一个抽象层（ abstraction layer），它允许你在后台使用任意一个日志类库。<br>如果是在编写供内外部都可以使用的API或者通用类库，使用你类库的客户端不必一定使用你选择的日志类库。</p><p>如果一个项目已经使用了log4j，而你加载了一个类库，比方说 Apache Active MQ——它依赖于于另外一个日志类库logback(<em>Logback是由log4j创始人Ceki Gülcü设计的又一个开源日志组件。logback当前分成三个模块：logback-core,logback- classic和logback-access。</em>)，那么你就需要把它也加载进去。但如果Apache Active MQ使用了SLF4J，你可以继续使用你的日志类库而无语忍受加载和维护一个新的日志框架的麻烦。</p><p>总的来说，SLF4J使你的代码独立于任意一个特定的日志API，这是一个对于开发API的开发者很好的思想。</p><p>main content：日志选择和业务分离</p></blockquote><p>implement:</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;    &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;    &lt;version&gt;1.6.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;    &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;    &lt;version&gt;1.0.13&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;    &lt;artifactId&gt;logback-core&lt;/artifactId&gt;    &lt;version&gt;1.0.13&lt;/version&gt;&lt;/dependency&gt;</code></pre><hr><pre><code>[WebAjaxController.java]import org.slf4j.Logger;import org.slf4j.LoggerFactory;@Controllerpublic class WebAjaxController extends AbsAjaxController {    private static final Logger LOG = LoggerFactory.getLogger(&quot;STAT_LOG&quot;);    public void method(){        ...         LOG.info(&quot;[opt:method,uid:{},from:{},type:{}]&quot;, new Object[] {                    uid, fromLog, typeLog });    }    ...}</code></pre><hr><pre><code>[LogBack.xml] &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration&gt;     &lt;appender name=&quot;stat_appender&quot;        class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;    &lt;file&gt;/home/logs/statistics/lepro3.log&lt;/file&gt;    &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;        &lt;fileNamePattern&gt;/home/logs/mylog.log.%d{yyyy-MM-dd}&lt;/fileNamePattern&gt;    &lt;/rollingPolicy&gt;    &lt;append&gt;true&lt;/append&gt;    &lt;encoder&gt;        &lt;pattern&gt;%d %t %-5level %c{0}.%M:%L -%m%n&lt;/pattern&gt;    &lt;/encoder&gt;        &lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;            &lt;level&gt;INFO&lt;/level&gt;        &lt;/filter&gt;    &lt;/appender&gt;&lt;logger name=&quot;STAT_LOG&quot;&gt;    &lt;level value=&quot;INFO&quot;/&gt;    &lt;appender-ref ref=&quot;stat_appender&quot; /&gt;&lt;/logger&gt;&lt;root level=&quot;INFO&quot;&gt;&lt;/root&gt;    &lt;/configuration&gt;</code></pre><hr><pre><code>[web.xml]&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; version=&quot;3.0&quot; id=&quot;WebApp&quot;&gt;    &lt;context-param&gt;         &lt;param-name&gt;logbackConfigLocation&lt;/param-name&gt;         &lt;param-value&gt;classpath:logback.xml&lt;/param-value&gt;    &lt;/context-param&gt;&lt;/web-app&gt;</code></pre><blockquote><p>note:Logback的核心对象：Logger、Appender、Layout</p><p>Logback主要建立于Logger、Appender 和 Layout 这三个类之上。</p><p>Logger:日志的记录器，把它关联到应用的对应的context上后，主要用于存放日志对象，也可以定义日志类型、级别。Logger对象一般多定义为静态常量。</p><p>Appender:用于指定日志输出的目的地，目的地可以是控制台、文件、远程套接字服务器、 MySQL、 PostreSQL、Oracle和其他数据库、 JMS和远程UNIX Syslog守护进程等。</p><p>Layout:负责把事件转换成字符串，格式化的日志信息的输出。具体的Layout通配符，可以直接查看帮助文档。</p><p>Level 有效级别。Logger可以被分配级别。级别包括：TRACE、DEBUG、INFO、WARN和ERROR，定义于ch.qos.logback.classic.Level类。程序会打印高于或等于所设置级别的日志，设置的日志等级越高，打印出来的日志就越少。如果设置级别为INFO，则优先级高于等于INFO级别（如：INFO、 WARN、ERROR）的日志信息将可以被输出,小于该级别的如DEBUG将不会被输出。为确保所有logger都能够最终继承一个级别，根logger总是有级别，默认情况下，这个级别是DEBUG。</p><p>[note] 以上参考</p><p><span class="exturl" data-url="aHR0cDovL3d3dy5jbmJsb2dzLmNvbS95b25nemUxMDMvYXJjaGl2ZS8yMDEyLzA1LzA1LzI0ODQ3NTMuaHRtbA==" title="http://www.cnblogs.com/yongze103/archive/2012/05/05/2484753.html">http://www.cnblogs.com/yongze103/archive/2012/05/05/2484753.html<i class="fa fa-external-link"></i></span>，感谢。</p></blockquote><h4 id="关于spring-scheme定时任务"><a href="#关于spring-scheme定时任务" class="headerlink" title="关于spring scheme定时任务"></a>关于spring scheme定时任务</h4><blockquote><p>note: spring3.0 自带的task</p></blockquote><pre><code>[applicationContext-task.xml]&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;xmlns:task=&quot;http://www.springframework.org/schema/task&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:lang=&quot;http://www.springframework.org/schema/lang&quot;xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd http://www.springframework.org/schema/lang http://www.springframework.org/schema/lang/spring-lang-2.5.xsd http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-3.1.xsd&quot;&gt;&lt;task:scheduler id=&quot;myScheduler&quot; pool-size=&quot;10&quot; /&gt;&lt;task:annotation-driven scheduler=&quot;myScheduler&quot; /&gt;&lt;/beans&gt;</code></pre><hr><pre><code>[web.xml]&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; version=&quot;3.0&quot; id=&quot;WebApp&quot;&gt;    &lt;context-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;        ...         classpath:applicationContext-service.xml         classpath:applicationContext-dao.xml         classpath:applicationContext-task.xml        ...    &lt;/param-value&gt;    &lt;/context-param&gt;&lt;/web-app&gt;</code></pre><hr><pre><code>[TipEmailTask.java]import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Lazy;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;import java.util.concurrent.atomic.AtomicBoolean;@Component(&quot;tipEmailTask&quot;)@Lazy(false)public class TipEmailTask {    private volatile AtomicBoolean starting = new AtomicBoolean(false);    @Autowired    private UserService userService;    @Scheduled(cron = &quot;0 0 */2 * * ?&quot;)    public void shcedule() {        try {            execute();        } catch (Exception e) {            e.printStackTrace();        }    }    private void execute() {        if (starting.compareAndSet(false, true)) {            try {                boolean result = userService.sendTipMail();            } catch (Exception e) {        } finally {            starting.set(false);        }    }}</code></pre><blockquote><p>note @Scheduled(cron = “0 0 <em>/2 </em> * ?”) 每两小时触发一次，实际是0,2…22点触发。</p><p>资料包 cron=({秒} {分} {时} {日期（具体哪天）} {月} {星期})</p><ul><li>秒：必填项，允许的值范围是0-59，支持的特殊符号包括*/n，表示特定的每n秒可以整除的才会触发任务。</li><li>分：必填项，允许的值范围是0-59，支持的特殊符号和秒一样，含义类推。</li><li>时：必填项，允许的值范围是0-23，支持的特殊符号和秒一样，含义类推。</li><li>日期：必填项，允许的值范围是1-31，支持的特殊符号相比秒多了?，表示与{星期}互斥，即意味着若明确指定{星期}触发，则表示{日期}无意义，以免引起冲突和混乱。</li><li>月：必填项，允许的值范围是1-12（JAN-DEC），支持的特殊符号与秒一样，含义类推</li><li>星期：必填项，允许值范围是1~7(SUN-SAT),1代表星期天（一星期的第一天），以此类推，7代表星期六，支持的符号相比秒多了?，表达的含义是与{日期}互斥，即意味着若明确指定{日期}触发，则表示{星期}无意义。</li></ul><p>参考文档：<span class="exturl" data-url="aHR0cHM6Ly9zcHJpbmcuaW8vZ3VpZGVzL2dzL3NjaGVkdWxpbmctdGFza3MvI2luaXRpYWw=" title="https://spring.io/guides/gs/scheduling-tasks/#initial">https://spring.io/guides/gs/scheduling-tasks/#initial<i class="fa fa-external-link"></i></span>，感谢。</p></blockquote><h4 id="关于xmemcache缓存"><a href="#关于xmemcache缓存" class="headerlink" title="关于xmemcache缓存"></a>关于xmemcache缓存</h4><pre><code>[applicationContext-service-lmswitch.xml]&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd    http://www.springframework.org/schema/context    http://www.springframework.org/schema/context/spring-context-3.0.xsd    http://www.springframework.org/schema/aop     http://www.springframework.org/schema/aop/spring-aop-3.0.xsd&quot;&gt;&lt;bean id=&quot;memcachedClientBuilder&quot; class=&quot;net.rubyeye.xmemcached.XMemcachedClientBuilder&quot; &gt;      &lt;constructor-arg&gt;         &lt;list&gt;             &lt;bean class=&quot;java.net.InetSocketAddress&quot;&gt;                  &lt;constructor-arg value=&quot;缓存服务器ip&quot; /&gt;                 &lt;constructor-arg value=&quot;11211&quot; /&gt;             &lt;/bean&gt;         &lt;/list&gt;     &lt;/constructor-arg&gt;     &lt;property name=&quot;connectionPoolSize&quot; value=&quot;5&quot; /&gt;      &lt;property name=&quot;commandFactory&quot;&gt;             &lt;bean class=&quot;net.rubyeye.xmemcached.command.TextCommandFactory&quot; /&gt;        &lt;/property&gt;        &lt;property name=&quot;sessionLocator&quot;&gt;             &lt;bean class=&quot;net.rubyeye.xmemcached.impl.KetamaMemcachedSessionLocator&quot; /&gt;        &lt;/property&gt;        &lt;property name=&quot;transcoder&quot;&gt;             &lt;bean class=&quot;net.rubyeye.xmemcached.transcoders.SerializingTranscoder&quot; /&gt;        &lt;/property&gt;&lt;/bean&gt; &lt;bean id=&quot;memcachedClient&quot; factory-bean=&quot;memcachedClientBuilder&quot;      factory-method=&quot;build&quot; destroy-method =&quot;shutdown&quot; /&gt; &lt;/beans&gt;</code></pre><hr><pre><code>[web.xml]&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; version=&quot;3.0&quot; id=&quot;WebApp&quot;&gt;    &lt;context-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;        ...        classpath:applicationContext-service-lmswitch.xml        ...    &lt;/param-value&gt;    &lt;/context-param&gt;&lt;/web-app&gt;</code></pre><hr><pre><code>[CacheService.java]import net.rubyeye.xmemcached.Counter;public interface CacheService {/** * 放入缓存 */public Object put(String cacheName, String key, Object value);/** * 获得缓存 */public Object get(String cacheName, String key);/** * 删除缓存 */public void delete(String cacheName, String key);/** * 删除缓存*/public void delete(String cacheName);public Counter getCounter(String counterName, long defaultVal);}</code></pre><hr><pre><code>[MemCacheServiceImpl.java]import java.util.concurrent.TimeoutException;import net.rubyeye.xmemcached.Counter;import net.rubyeye.xmemcached.MemcachedClient;import net.rubyeye.xmemcached.exception.MemcachedException;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import com.netease.mail.activity.service.complex.CacheService;@Component(&quot;memCacheService&quot;)public class MemCacheServiceImpl implements CacheService {@Autowiredprivate MemcachedClient memcachedClient;@Overridepublic Object put(String cacheName, String key, Object value) {    long startTime = System.currentTimeMillis();    boolean result = false;    result = memcachedClient.set(getComposedKey(cacheName, key), 0,value);//0代表30天，含义永久；    return null;}@Overridepublic Object get(String cacheName, String key) {    long startTime = System.currentTimeMillis();    Object value = null;    value = memcachedClient.get(getComposedKey(cacheName, key));    return value == null ? null : value.toString();}@Overridepublic void delete(String cacheName, String key) {}@Overridepublic void delete(String cacheName) {}private String getComposedKey(String cacheName, String key) {    StringBuilder sb = new StringBuilder();    sb.append(cacheName).append(&quot;_&quot;).append(key);    return sb.toString();}@Overridepublic Counter getCounter(String counterName, long defaultVal) {    return memcachedClient.getCounter(counterName, defaultVal);}}</code></pre><blockquote><p>note: 以上是缓存处理的service实现，通过@注入，自动扫描。为了表达清楚含义，去掉了trycatch，应用时自己添加。<br>下面配上缓存的实际应用，为获取获奖者名单的应用方法。</p></blockquote><pre><code>methodprivate static final Gson gson = new Gson();@RequestMapping(&quot;/ajax/getWinners.do&quot;)@ResponseBodypublic void getWinners(HttpServletRequest request,    HttpServletResponse response) throws IOException {    Object winnersObj = memcachedService.get(MemcacheConst.CACHE_NAME,        MemcacheConst.CACHE_WINNERS);    Map&lt;String, Object&gt; result = new HashMap&lt;String, Object&gt;();    if (null == winnersObj) {//不存在从数据库中取，并放入缓存；        List&lt;WinnerVo&gt; winners = winnerService.getWinners();        if (null == winners) {            winners = new ArrayList&lt;WinnerVo&gt;();        }        result.put(&quot;winners&quot;, winners);        String winnersJson = gson.toJson(winners);        memcachedService.put(MemcacheConst.CACHE_NAME,            MemcacheConst.CACHE_WINNERS, winnersJson);        writeJsonP(request, response,            initAjaxResult(RetCode.SUCCESS.code, result));        return;    } else {//如果存在的话，返回即可；        String winnerJson = (String) winnersObj;        List&lt;WinnerVo&gt; winners = gson.fromJson(winnerJson,new TypeToken&lt;List&lt;WinnerVo&gt;&gt;() {}.getType());        if (null == winners) {            winners = new ArrayList&lt;WinnerVo&gt;();        }        result.put(&quot;winners&quot;, winners);        writeJsonP(request, response,            initAjaxResult(RetCode.SUCCESS.code, result));        return;    }}</code></pre><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>代码写下来，感觉controller中代码过重，应放入业务层service中。同时if-else过多嵌套。<br>另外，关于测试的问题，尤其是线上测试，开关注意把控，合理设计。因为这个问题重新编译了两次。<br>关于发布流程，每一次更新（哪怕一点点更新）必须先在测试环境编译部署，最后再在线上编译部署。</p><p>同时，关于nginx的部署、使用、原理还不了解。只是在用人家部署好的，这次使用两台业务服务器一台缓存服务器，所以接下来也需要学习一下nginx，亲自试一试。</p><p>以上是这十天阶段的开发感悟。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小记五月中</title>
      <link href="/2016/05/25/%E5%B0%8F%E8%AE%B0%E5%BD%95%E4%BA%94%E6%9C%88%E4%B8%AD/"/>
      <url>/2016/05/25/%E5%B0%8F%E8%AE%B0%E5%BD%95%E4%BA%94%E6%9C%88%E4%B8%AD/</url>
      
        <content type="html"><![CDATA[<blockquote><p>生活小记录</p></blockquote><a id="more"></a><h4 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h4><blockquote><p>现在，每天都敲敲代码，看看书，享受一下最后的校园生活。<br>明天还有政治考试，是时候组织一波复习了哈！<br>离散数学还有好多没看，翻一翻，划一划。还有即将到来的高级计算机网络的课程。</p></blockquote><h4 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h4><blockquote><p>在这安静的光阴里，时不时和哥们儿互相调侃下，说着什么要来一顿海底捞大餐，却一直没去。老实本分的洪文签实习去了北京，幽默诙谐的明鑫还在犹豫不定。这一年，大家伙儿还算认真，一起coding，一起调bug，为了一个算法争论不休，一起成长。<br>我的生活便在这片安宁静谧的时光中慢慢游荡。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 校园 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程（c语言实践）总结</title>
      <link href="/2015/11/20/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%EF%BC%88c%E8%AF%AD%E8%A8%80%E5%AE%9E%E8%B7%B5%EF%BC%89%E6%80%BB%E7%BB%93/"/>
      <url>/2015/11/20/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%EF%BC%88c%E8%AF%AD%E8%A8%80%E5%AE%9E%E8%B7%B5%EF%BC%89%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>【张城硕(sa15226451) + 《软件工程（C编码实践篇）》MOOC课程作业<span class="exturl" data-url="aHR0cDovL21vb2Muc3R1ZHkuMTYzLmNvbS9jb3Vyc2UvVVNUQy0xMDAwMDAyMDA2" title="http://mooc.study.163.com/course/USTC-1000002006">http://mooc.study.163.com/course/USTC-1000002006<i class="fa fa-external-link"></i></span> 】</p><blockquote><p>学习软件工程两个月来，我在孟宁老师的教导下确实获益匪浅。我从一开始对不知如何使用vim和git的无知，逐渐演变到软件设计模块化的熟练。下面， 我将谈谈这两个月学习软件工程线上课程的具体体会。</p></blockquote><a id="more"></a><h3 id="关于软件工程"><a href="#关于软件工程" class="headerlink" title="关于软件工程"></a>关于软件工程</h3><blockquote><p>首先，我先谈谈我对软件工程的理解。软件工程在我的脑海里就是如何利用工程化管理的技术来做软件。为什么会诞生软件工程呢？孟老师不止一次的提到，随着代码量的增大，人对代码的掌控能力越来越弱，代码的逻辑、进度和成本越来越不好控制，产生了软件危机！为了解决软件危机，软件工程应运而生。我比较喜欢线上编程，基本上每次线上课程我都投入了大量的时间和精力。</p><h3 id="关于代码"><a href="#关于代码" class="headerlink" title="关于代码"></a>关于代码</h3><p>在代码上，我在软件工程中学习到的是。<br>在细节上：</p><ul><li>第一、需要遵守代码规范，好处是便于修改和维护。让别人看的清楚你的代码；</li><li>第二、数据和业务逻辑的分离。我们需要将代码进行模块化，从而更好地维护和复用代码；</li><li>第三、懂得合理地设计接口，既不能面面俱到，也不能太过笼统，够用就好。比如说：链表的接口设计和菜单的接口设计就有所不同。链表需要增删查改的接口，而菜单的接口就无需如此太过细节化；</li><li>第三、掌握代码的运用技巧，比如说回调函数的使用；</li><li>第四、非功能性需求，比如说安全性。这里尤其需要谈到的是线程安全，如何利用加锁的机制构建出写出安全的代码；</li><li>第五、设计思想，这里需要应用一些前人总结的设计模式，比如说工场模式、观察者模式、适配器模式等。应用这些模式能大大增加代码的延展性，更好地包容变化，更好地复用代码。当然，为了拓展视野，孟老师也提到函数式、形式化方法的编程；<h3 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h3>总之，学习软件工程我最大的收获，就是理解了软件工程，初步设计软件，明白软件开发的流程。特别是，由于孟老师有着丰富的软件开发经验，所以比只讲软件工程理论要来的有趣、更好理解得多！最大的遗憾是，我希望线上课程能让我和同学共同协作，通过规定接口来完成一个软件项目，因为我感觉软件工程离不开沟通协作。<br>最后，深深感谢孟宁老师给我带来了如此生动、有趣而又丰富的软件工程课程。<h3 id="实验报告"><a href="#实验报告" class="headerlink" title="实验报告"></a>实验报告</h3>下面附上我的实验报告链接(全5分，也是对我尽力编程的认可吧)：</li></ul></blockquote><ol><li>实验一：写一个hello world小程序</li></ol><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuc2hpeWFubG91LmNvbS9jb3Vyc2VzL3JlcG9ydHMvNjQ1NzE4" title="https://www.shiyanlou.com/courses/reports/645718">https://www.shiyanlou.com/courses/reports/645718<i class="fa fa-external-link"></i></span></p><ol><li>实验二：命令行菜单小程序V1.0</li></ol><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuc2hpeWFubG91LmNvbS9jb3Vyc2VzL3JlcG9ydHMvNjU5ODcy" title="https://www.shiyanlou.com/courses/reports/659872">https://www.shiyanlou.com/courses/reports/659872<i class="fa fa-external-link"></i></span></p><ol><li>实验三：内部模块化的命令行菜单小程序V2.0</li></ol><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuc2hpeWFubG91LmNvbS9jb3Vyc2VzL3JlcG9ydHMvNjgzNzI4" title="https://www.shiyanlou.com/courses/reports/683728">https://www.shiyanlou.com/courses/reports/683728<i class="fa fa-external-link"></i></span></p><ol><li>实验四：用可重用的链表模块来实现命令行菜单小程序V2.5</li></ol><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuc2hpeWFubG91LmNvbS9jb3Vyc2VzL3JlcG9ydHMvNzAxNTU1" title="https://www.shiyanlou.com/courses/reports/701555">https://www.shiyanlou.com/courses/reports/701555<i class="fa fa-external-link"></i></span></p><ol><li>实验五：用callback增强链表模块来实现命令行菜单小程序V2.8</li></ol><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuc2hpeWFubG91LmNvbS9jb3Vyc2VzL3JlcG9ydHMvNzE1ODAw" title="https://www.shiyanlou.com/courses/reports/715800">https://www.shiyanlou.com/courses/reports/715800<i class="fa fa-external-link"></i></span></p><ol><li>实验六：可重入函数的相关测试，一次小测验。</li></ol><ol><li>实验七：将menu设计为可重用的子系统</li></ol><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuc2hpeWFubG91LmNvbS9jb3Vyc2VzL3JlcG9ydHMvNzUwNDkx" title="https://www.shiyanlou.com/courses/reports/750491">https://www.shiyanlou.com/courses/reports/750491<i class="fa fa-external-link"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 校园 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
